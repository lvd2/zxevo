        AVReAl -- программирование AVR через LPT
        v1.25rev5

Новые версии, описание и FAQ лежат на:
http://www.ln.com.ua/~real/avreal

Внимание!!! Письма по поводу avreal с аттачами в виде скриншотов,
WORD-овских и прочеофисовских документов не будут даже читаться,
не говоря уже об ответах

Компилируется в следующих вариантах
  -- 16-битном DOS, для работы на процессорах начиная с 286.
  -- 32-битном WIN32
  -- Linux
  -- FreeBSD

Для работы Win32-версии необходимы
W95/W98         -- DLportIO.DLL
NT, W2K, WinXP  -- DLportIO.DLL  и DLportIO.sys

       Это файлы из комплекта DriverLINX от Scientific Software Tools, Inc.
(http://www.sstnet.com) Его поставка достаточно громоздкая, с примерами
работы на C и VisualBASIC, автоматической инсталляцией DLportIO.SYS
для WindowsNT и т.д. - итого файл port95nt.exe имеет размер 1.6Mb.
В урезанном виде без описания и примеров применения лежит у меня на сайте
http://www.ln.com.ua/~real/avreal/dlportio.zip


Варианты подключения LPT к чипу
  -- только проводки (аналогично fbprg.exe, есть и такой программатор)
  -- через Altera ByteBlaster (ключ -ab)
  -- через Atmel-овский адаптер для STK200/STK300 (ключ -as)

Подключение выводов процессоров для режимов "fbprg" и "AlteraByteBlaster"

Сигнал      LPT        Byte        XILINX             н о г и
          "fbprg"      Blaster               1200/2313    8515  mega103/603
/RESET    D4(pin6)     TMS(pin5)  TMS(pin9)      1         9       20
SCK       D6(pin8)     TCK(pin1)  TCK(pin4)     19         8       11
MOSI      D5(pin7)     TDI(pin9)  TDI(pin7)     17         6        2 (PDI)
MISO      ACK(pin10)   TDO(pin3)  TDO(pin6)     18         7        3 (PDO)
XTAL1     D3(pin5)      pin8 (*)      -          5        19       24

(*) -- нет в "штатном" ByteBlaster и ByteBlasterMV от Альтера (должен быть
изготовлен согласно схеме у меня на страничке), есть в ByteBlaster-II.

В режиме "fbprg" незадействованные выходы данных LPT могут
быть использованы как питание чипа (ключ -ap). Также возможна генерация
XTAL программой (ключ -o0), данный режим может оказаться полезен и при
наличии кварца в плате (LPT-порт легко его пересилит) для "обхода"
ошибок кристалов "не читается содержимое EEPROM данных при частотах
кварца, близких к максимальной".

При использовании буферированных адаптеров (все кроме FBPRG)
программа рассчитана на программирование в плате с штатными
питанием и кварцем.
Возможна генерация XTAL1 по линии LED в STK*00 и по
дополнительной линии, выведенной на контакт 8 в ByteBlaster.


  В качестве входных и выходных файлов avreal использует INTEL HEX
(при использовании avrasm необходимо в его командной строке добавить
ключ -i).
  HEX-файл загружается не в массив, а в список. Т.е. различается
ситуация "байт 0xFF в .hex" и "неупомянутый байт" В результате есть
возможность шить только то, что надо, остальное только проверять
при необходимости (см. ключ -v+).

  Для любителей вносить изменения прямо в HEX-файл: если не совпадает
контрольная сумма строки, то задается вопрос -- "игнорировать?". При
ответе 'Y' (или 'y') эта и все остальные ошибки CSUM игнорируются (но
сами символы контрольной суммы должны присутствовать, иначе программа
завершится с кодом ошибки 50 еще раньше -- по недопустимому символу в строке).
  Для облегчения таких патчей (особенно "форматных" записей в EEPROM)
реализована особенность, подсмотренная у программы от VMK@real.kiev.ua для
программирования PIC через Tait-совместимое железо: перед анализом
строки из нее убираются пробелы и табуляции. В итоге HEX-файл может
содержать, например, такую строку:
:08 0001 00   00 01 0203 0405 0 6 0 7    DB
Также игнорируются пустые строки и строки, начинающиеся с '#', последнее
предназначено для помещения комментариев о версии непосредственно в
HEX-файлы.

  Проверяется верхний адрес в HEX-файле, если не влазит в заданный
тип кристалла, то никаких действий (кроме выдачи сообщения об ошибке)
не осуществляется.
  Проверяется перекрытие адресов записей в HEX файле. При нахождении
первого перекрытия производится выход из программы с указанием диапазона
адресов перекрывающихся данных. Перекрытие адресов (т.е. наличие в HEX-файле
более одной записи для одного и того же адреса памяти) как правило
свидетельствут о неправильном задании ключей линкеру, производящему
сборку проекта.

 Для mega103 необходим расширенный формат HEX-файла (обычный не
поддерживает объем больше 64KB). Запись прочитанных данных в файл всегда
производится с дополнительными записями тип '04' -- Extended Linear
Address Record, как не имеющим разночтений. Чтение из HEX-файла записей
типа '02' Extended Segment Address Record производится в соответствии с
формированием их в AVRASM by Atmel (_без_ предусмотренного документацией
Intel сворачивания адреса смещения по модулю 64KB).

                                 ВЫЗОВ

avreal [ключи] [[-c] имя_файла_кода [[-d] имя_файла_данных]]
 или
avreal [ключи] -d имя_файла_данных   (когда код трогать желания нет)

При пустой командной строке (ни имен, ни ключей) не делается никаких
операций с портами/чипом.

Если есть только имена файлов, но нет относящихся к ним ключей (-r -w -v),
то файлы игнорируются.
Подробнее про работу с файлами и про ключи -c, -d  рассказано
после описания остальных ключей.

Ключи (признак ключа -- символ '-' или '/', регистр букв не важен).

-? (-h)  выдать ключи и перечень поддерживаемых кристаллов
        Пометка "not tested" означает, что я не тестировал сам и не
        получил подтверждения о нормальной работе от нескольких человек.
        Поэтому если в свежей версии кристалл помечен таким образом,
        а у вас всё работает нормально -- не поленитесь сообщить.
        avreal +name -?
        (+name должен быть задан _раньше_ ключа -?)
        выдает список fuses, поддерживаемых в режиме ISP для чипа name

+name   установить тип кристалла, <name> допускается задавать как с префиксом
	'AT', так и без него, в том виде, в котором имена выдаются по -h.
	Регистр букв не важен. Например, at90s1200, attiny22l, atmega103
	либо 90s1200, tiny22l, mega103.
        Обязательный ключ, никаких действий по умолчанию не производится.
        Если задан только чип (больше нет ни ключей, ни имен файлов),
        то он будет сброшен импульсом на входе reset и выдана информация
        о его наличии, если есть доступные по ISP fuses -- их состояние.

-p<число1>[,<число2>]
        "число1", шестнадцатеричное
            set Port  1,2,3 - номер LPT порта, >0x100 -- базовый адрес порта
             если задан номер -- адрес из BIOS MEMORY (не работает
            для win32 и linux версий, в этих версиях avreal принято,
            что LPT1/2/3 имеют базовые адреса 378/278/3BC соответственно).
            Адрес и в виде -p3BC, и в виде -p0x3BC воспринимается как число
            в шестнадцатеричном формате.
            По умолчанию -p2 (LPT2)
        "число2", с плавающей _точкой_, необязательный параметр
            если указан, то не производится настройка на скорость порта,
            время обращения принимается равным <число2> микросекунд.
            В win32 и linux версиях настройка не производится никогда, если
            не указано -- считается, что обращение к порту не быстрее 1мкс.

-a<буква> группа ключей "адаптер"
       -ab  работа через Altera ByteBlaster
            (включая ByteBlasterMV, ByteBlaster-II)
       -as  работа через адаптер Atmel STK*00
       -aa  автоматический выбор ByteBlaster/STK
       -ax  работа через XILINX parallel download cable
       -az  пытаться переводить выходы LPT в Z-состояние для "отключения"
            программатора от схемы ("byte-blaster для ленивых")
       -ar  инверсия полярности сброса (например, для подачи его
            через резистор в базу присутствующего в схеме транзистора)
       -ai# установить время неактивного Reset после стирания равным #mS.
            Необходимо устанавливать большим времени задержки снятия
            сброса присутствующим в схеме супервизором.
       -ap  подавать питание чипа через свободные выходы данных LPT
            (несовместимо с -ab,-as,-aa)
            Рекомендуется поближе к чипу установить блокировочный
            конденсатор по питанию [Andy Chernyshenko]
       -am=mapfile.txt использовать файл mapfile.txt для задания конфигурации
            адаптера программирования (см. ниже)

-o<число> Задать частоту установленного кварца для настройки скорости SPI
        <число>=<частота> допускается с плавающей точкой и единицами
        измерения частоты Hz, kHz, MHz, например,
            -o3.686MHZ
            -o14745600hz
        При отсутствии единиц измерения для совместимости с
        предыдущими версиями считается, что частота в килогерцах.
        При отсутствии ключа частота по умолчанию 800 (0.8MHz)
-o0[,#] 0 в качестве частоты означает необходимость генерации XTAL из программы
        Можно указать дополнительный делитель для генерации более меделнного
        сигнала SCK, что необходимо для работы ключа -o0 с кристаллами с
        прошитым CKDIV. Допустимые значения делителя #=1..32
        У STK*00 для генерации XTAL используется линия LED.
        ByteBlaster (ByteBlasterMV)  должен быть доработан,
        см. http://www.ln.com.ua/~real/avreal/adapters.html#ABB
        ByteBlaster-II уже имеет подключение к выводу 8 колодки.
        XILINX parallel download cable не имеет свободных линий и ключ
        -o0 не может быть использован с ним.

-n[<число>]  Использовать последние 2 байта кода как счетчик стираний.
        Если указано <число>, то для записи счетчика используется оно,
        а не инкрементированное прочитанное значение.
        При -ewn если последние 2 байта заняты кодом то -n игнорируется
        При -w   если в чипе записан счетчик а последние 2 байта заняты
        кодом то производится принудительное стирание.

-e[-]   Стереть чип
        '-' задает сохранение содержимого EEPROM способом
        прочесть/стереть/записать. Для кристаллов, имеющих fuse EESAVE,
	по -e- также применяется этот способ. Если же хочется пользоваться
	имеющимся fuse EESAVE, следует установить его (-fe или -feesv=0)
	отдельным запуском avreal и применять обычную форму ключа -e.

-1,-2,-3,-4,-5
        Увеличить задержки на программирование в 1.5, 2, 3, 4, 5 раз
        соответственно (для программирования при пониженном напряжении питания)

-b      Проверить на чистоту
        -bc - проверить на чистоту только код (flash)
        -bd - проверить на чистоту только данные (eeprom)

-r      Прочитать из чипа в файл[ы]

-w[+][p] Записать в чип файлы кода/данных, заданные в командной строке fuses.
        '+' -- если чип в этом задании не стирался и задана запись в EEPROM,
        то прописать FF в ячейки EEPROM, не заданные в HEX.
        Верификация этих ячеек на значение FF будет производится даже если
        был задан просто -v, а не -v+, так как в эти ячейки писалось.
        'p' -- использовать поллинг для определения конца записи.
        Если в течении времени, равного восьмикратному номинальному времени
        записи поллинг не даёт положительного результата - выдаётся сообщение
        об ошибке и завершение программы.

-v[+]   Верифицировать (только то, что есть в hex)
        дополнительный '+' вызывает проверку на FF "свободных"
        с точки зрения HEX-файла позиций

-l[+]#  -l#   Установить уровень защиты # = 1 (LB2=1,LB1=0) или 2 (LB2=0,LB1=0)
        -l+#  То же самое, только lock биты прошиваются до зашивки fuses
              (необходимо для включения BODEN и залочки 90s4433 в одном цикле
               подачи питания)


-f<fuselist> -- список fuses для тех чипов, в которых они шьются по ISP.
        <fuselist> выглядит как fusename=value,fusename=value,bytename=value...
        value - ШЕСТНАДЦАТЕРИЧНОЕ значение без префиксов и суффиксов.
        Для однобитовых fuse добавлены значения ON и OFF (прошить и стереть,
        0 и 1 соответственно).
        ВНИМАНИЕ! Начиная с версии 1.23 НЕ ПОДДЕРЖИВАЮТСЯ однобуквенные
        синонимы для fuses.
        При наличии "пересекающихся" name=val выдается сообщение об ошибке.
        При наличии нескольких ключей -f действие имеет _только_последний_.
        Перечень fusename для конкретного чипа с диапазоном value и комментарием
        можно получить при помощи
           avreal +chipname -?
        Для сокращения строки возможно задание полного байта fuses при помощи
        специальных имен bytename, представляющие собой названия байтов
        по документации с лидирующим подчерком:
            _low,_high,_ext,_lock
        Нереализованные в данном байте биты рекомендуется устанавливать в '1'.
        Имя _lock относится к байту lock-битов и BLB, однако на состояние
        lock-битов НЕ ВЛИЯЕТ. Для блокировки кристалла по прежнему надо
        использовать ключ -l.
        Допускается комбинация отдельных fuse и байтов, однако они при этом
        не должны пересекаться, т.е. каждый байт fuses должен быть задан
        либо только через специальное имя, либо только через имена отдельных
        fuse. Например,
            допустимо:     -f_low=C3,_high=F4,blb2=1
            не допустимо:  -f_lock=F7,blb2=1
        Если работа с fuses по SPI поддерживается, то их состояние сообщается
        при любой операции с чипом, задание ключа -F необязательно.
        В случае наличия -F<fuselist> при -V производится верификация fuses.
        Для записи fuses _необходимо_ указать ключ -w.
        Неупомянутые fuse остаются неизменными (кроме BLB для mega161, mega163,
        так как они могут быть стерты по -E).
        AVReAl обеспечивает также расширенную поддержку osccal (см. ниже)
        Группа BLB относится скорее к lock-битам, записать 1 поверх уже
        запрограммированной в 0 fuse невозможно. Если запрошена
        такая операция и чип не стирался, то программа завершает работу
        с соответствующим предупреждением.
        Для tiny12, tiny15 поддерживается программирование SPIEN
        и RSTDSBL, будьте осторожны, SPIEN по умолчанию запрограмировано,
        ключ -fspien=1 (-fspien=off) _сотрет_ SPIEN и запретит дальнейшее
        низковольтное программирование. Запрет произойдет и при
        _программировании_ RSTDSBL (-frstdsbl=0 или -frstdsbl=off).

-%      Выдавать по ходу дела дополнительную информацию (производимые
        действия и ответы чипа). Внутри .bat файлов следует писать -%%
        (пожалуй, это был неудачный выбор -- символ, имеющий особый
        смысл в bat-файлах, но меняться уже не будет).

-!      Делать, что велено, даже если чип не распознан (или распознан
        "не так", как задано в +<имя чипа>), а также если не обнаружен
        указанный в командной строке адаптер. Попытка стереть нераспознанный
        (возможно просто залоченный) чип при наличии команды стирания
        производится и без -! после чего проводится повторное
        детектирование чипа.

возможны осмысленные комбинации:
-v -w       записать, проверить
-e- -w -v+  стереть с сохранением EEPROM, записать, верифицировать
            с проверкой на чистоту свободных участков.
-b -w       проверить на чистоту, если грязная - выход, иначе писать

ВНИМАНИЕ! в связи с усложнением форматов ключей во избежание разночтений
    в дальнейшем возможность указывать группу ключей одним аргументом
    (например, -ewv) может быть исключена

После ключа -d идет имя файла данных, после -c имя кода, в этом случае
порядок файлов не важен. Пробел между ключами -c/-d и именами не
обязателен, т.е. допустимо как  -cfoo.hex  так и  -c foo.hex.
Если дано два имени файла без ключей -c и -d, то первое имя -- файл кода,
второе -- файл данных (EEPROM).

Если имя одно и нет ключей -c/-d, то этот файл содержит данные для кода
и, если он содержит информацию после верхнего адреса FLASH для заданного
кристалла, то эта информация используется для программирования EEPROM данных.
Т.е. если, например, для 90s2313 hex-файл содержал данные в адресах
от 0x800 до 0x87F, то эти данные будут записаны в EEPROM по адресам
0x00-0x7F.

Для занесения в код и/или данные специальных параметров применяются
особые формы ключей -c и -d следующего вида:

-d*name=offset,ext  как байты в EEPROM данных
-c*name=offset,ext  как байты во FLASH кода (под команду LPM)
-с?name=offset,ext  как часть последовательных команд LDI начиная с offset

где

name - имя специального параметра, может состоять из собственно имени
  и уточняющего числа.
offset - адрес байта, начиная с которого производится запись специального
  значения, шестнадцатеричное значение без префиксов и суффиксов.
  Используется адрес _байта_, а не слова, в том числе и при обращении
  ко flash кода.
ext - дополнительный аргумент

Байты, необходимые для записи, должны существовать в исходном HEX-файле.
В качестве специальных параметров могут выступать:

OSCCAL
В качестве имени используется слово osccal с номером калибровочного байта.
При использовании нулевого байта OSCCAL указание номера 0 не обязательно.
Дополнительный аргумент ext - корректирующее значение к прочитанной из кристалла
величине osccal (может быть необходимо при напряжении питания, отличающемся
от напряжения калибровки на производстве). При выходе корректированного
значения за пределы [0..255] происходит ограничение значения и выдача
предупреждения.

Примеры.

1. Необходимо записать значение 3-го (считая с 0) байта osccal как байт
по адресу 0x3F в EEPROM данных. Используется ключ

-d*osccal3=3F


2. Необходимо записать значение 0-го байта osccal, уменьшенное на 3,
как часть команды LDI.

   public osccal_ldi
   ...
osccal_ldi:
   ldi R16,0xFF
   out OSCCAL,R16
   ...
Далее смотрим по MAP-файлу значение osccal_ldi, например оно вышло 0x120. Команда
примет вид:

avreal +tiny12 -ewv -c foo.hex -c?osccal=120,-3


SERNO.
Предназначено для присвоения последовательных серийных номеров програмируемым
изделиям. В качестве имени параметра используется слово serno с числом - длиной
номера в байтах от 1 до 4. Серийный номер записывается в двоичном виде,
младший байт записывается первым. Дополнительный аргумент ext - имя текстового
файла, в котором записан номер в десятичном виде. После успешной записи
в кристалл номер увеличивается на 1 и записывается назад в файл.
Файл при этом переписывается полностью, если после серийного номера в нём была
другая информация - она теряется.
При сбое верификации при команде -w -v номер не меняется.
Если в командной строке задана только верификация (без записи), то значение
серийного номера из файла используется, но не инкрементируется,
файл остаётся без изменений.

Примеры.

1. Необходимо записать значение 2-байтного серийного номера как 2 байта начиная
с адреса 0x12 в EEPROM данных. Сам номер записан в файле serno.txt
Используется ключ

 -d*serno2=12,serno.txt


2. Необходимо записать значение 3-байтового серийного номера как часть
команд LDI. Номер записан в файле proj.serno

   public serno_load
   ...
serno_load:
   ldi R16,0xFF ; младший байт
   ldi R17,0xFF ; средний байт
   ldi R18,0xFF ; старший байт

Пусть значение serno_load по map-файлу вышло 0x120. Используется ключ:
 -c?serno3=120,proj.serno


ПРОИЗВОЛЬНАЯ ПОСЛЕДОВАТЕЛЬНОСТЬ БАЙТОВ
Предназначено для записи произвольных данных.
В качестве имени параметра используется слово bytes с числом записываемых байтов.
Дополнительный аргумент ext - шестнадцатеричная строка, число букв (hex-цифр)
должно быть равно удвоенному числу байтов.
Младший байт в hexstr должен быть расположен первым, т.е. для записи числа
0xDEADBEEF надо задать

  -c*bytes4=addr,EFBEADDE



Порядок ключей не важен, выполнение производится в порядке E B W V L.
Если проверка (B, V) дала отрицательный результат, то дальнейшая работа
не производится. Т.е.
 -e -b -w -v -l2
Стереть, _если_стерлась_ - писать, _если_верифицировалась_ - залочить.

-ab -p1 +tiny12 -w -c foo.hex -c*osccal=1f3,10 -c*serno2=1f4,serno.txt -fcksel=3,boden=0

Для tiny12 при помощи подключенного к порту 1 байт-бластера
записать во флеш кода файл foo.hex
по адресу 0x1F3 занести прочитанное из чипа и увеличенное на 10 значение OSCCAL
по адресу 0x1F4 записать серийный номер из файла serno.txt
запрограммировать fuse boden и установить fuse CKSEL в бинарное значение 0011


	ФОРМАТ ФАЙЛА КОНФИГУРАЦИИ АДАПТЕРА
  Файл конфигурации позволяет задать соответствие сигналов ISP-программатора
выводам LPT-порта, а также название адаптера, испльзуемое при выводе
диагностических сообщений. Файл состоит из отдельных записей вида
<параметр> = <значение>
по одной на строке.
  Название адаптера (параметр 'name') задаётся записью
name = <произвольная строка>
  Сигналы программатора (параметры mosi, miso, sck, reset, xtal) задаются
записями вида
signal_name = [~]lpt_pin_name
Признак инверсии '~' означает, что между выводом LPT и выводом микроконтроллера
присутствует инвертор. Внутренняя инверсия контроллера LPT учитывается автоматически.
Допустимые имена выводов LPT: d0..d7 alf init strobe select ask busy error pe online.
    Внимание! В настоящее время для выходных сигналов программатора
    можно использовать только выводы d0..d7 порта LPT.
Существуют специальные группы выводов set, power, enable, в записях для этих
групп допускается перечисление нескольких выводов LPT через запятую.
Признак инверсии при каждом выводе означает, что на вывод необходимо выдать
низкий уровень. Перед началом работы в заданное (активное) состояние
устанавливаются выводы группы set. Затем активируются выводы группы power,
выдерживается пауза около 0.3секунды и активируются выводы enable. По
окончании работы в пассивное состояние переводятся выводы enable, затем
выводы power. Выводы set остаются в установленном в начале состоянии.
  Примеры описания адаптера для системы, состоящей из двух микроконтроллеров
AVR, связанных между собой по SPI. Пусть выводы reset, mosi, miso
контроллеров объединены и поданы на соответствующеи выводы колодки
модифицированного байт-бластера, а выводы sck соединены между собой через
резистор 1кОм, вывод sck первого контроллера подан на вывод sck
байт-бластера, а второго контроллера - на вывод xtal байт-бластера. При
высокоимпедансном состоянии адаптера программирования или его отсутствии
контроллеры могут свободно обмениваться информацией по последовательному
интерфейсу.
  Для программирования первого микроконтроллера необходимо использовать
следующий конфигурационный файл.
name=1'st controller programmer
mosi=D6
miso=BUSY
sck = D0
reset = D1
enable=~ALF
set =~D3

  Для программирования второго контроллера конфигурация адаптера должна
быть следующая.
name=2'nd controller programmer
mosi=D6
miso=BUSY
set = ~D0
reset = D1
enable=~ALF
sck = D3


     Возвращаемый ERRORLEVEL

 0 - все заказанное сделалось
10 - not blank при -B, несравнение при -V[+]
20 - Невозможность осуществить запрошенную операцию
        HEX кода или данных слишком большой для распознанного чипа.
        Запрошенное для записи состояние BLB нельзя записать, не стерев чип
        (а команды стирания не было)
30 - не распознан конкретный чип (бывает при защищенном чипе, поэтому
     при -E все равно делается попытка стереть и если после этого тоже
     не распознан -- выход.
40 - кабель не подключен, не удалось войти в программирование по
     алгоритму для AVR
50 - ошибка при чтении (не найден, "не те" символы, не совпала
     контрольная сумма, ошибка чтения, ...) или записи (есть защищённый
     от перезаписи с таким же именем, ...) HEX-файла.
60 - недостаточно памяти для списков кода/данных
70 - недопустимая командная строка (в т.ч. задан номер отсутствующего LPT)


           СВЕТЛОЕ БУДУЩЕЕ (список унылостей в настоящем :-)
Раздел убран в силу нехватки времени и изменения моих собственных
потребностей.
Коммунизм нам тоже когда-то обещали к 80 году, так что лучше я ничего
обещать не буду, а вот если что-то интересное смогу, то будет сюрприз :-)


-----------------------------
Александр Редчук
real@real.kiev.ua

При обнаружении неприятностей просьба сообщать версию и _очень_
желательно копию расширенной выдачи программы по -%
(перенаправив выдачу в файл).
Общение по поводу avreal предпочтительно отправлять по адресу

avreal@real.kiev.ua

меньше вероятность потери письма в куче других :-)
