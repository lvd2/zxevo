
























Alfred Arnold




Makroassembler AS V1.42
--------------------------------------------

Benutzeranleitung




Stand Janua 2010















IBM,  PPC403Gx,  OS/2  und  PowerPC  sind eingetragene Warenzeichen der
IBM Corporation.

Intel,  MCS-48, MCS-51, MCS-251, MCS-96,  MCS-196 und MCS-296 sind ein-
getragene Warenzeichen der Intel Corp. .

Motorola  und  ColdFire  sind  eingetragene  Warenzeichen  von Motorola
Inc. .

PicoBlaze ist ein eingetragenes Warenzeichen der Xilinx Inc.

UNIX ist ein eingetragenes Warenzeichen der Open Group.

Linux ist ein eingetragenes Warenzeichen von Linus Thorvalds.

Microsoft,  Windows und  MS-DOS sind  eingetragene Warenzeichen der Mi-
crosoft Corporation.

Alle  anderen Warenzeichen, die nicht  ausdrÅcklich in diesem Abschnitt
genannt  wurden und in diesem  Handbuch verwendet werden, sind Eigentum
der entsprechenden EigentÅmer.




















Dieses  Dokument wurde  mit dem  LaTeX-Satzsystem unter dem Betriebssy-
stem Linux angefertigt und formatiert.



        Inhalt

     1. Allgemeines

      1.1. Lizenzbedingungen

      1.2. allgemeine FÑhigkeiten des Assemblers

      1.3. UnterstÅtzte Plattformen

     2. Benutzung des Assemblers

      2.1. Hardware-Anforderungen

      2.2. Lieferumfang

      2.3. Installation

      2.4. Aufruf, Parameter

      2.5. Format der Eingabedateien

      2.6. Format des Listings

      2.7. Symbolkonventionen

      2.8. TemporÑre Symbole

       2.8.1. TemporÑre Symbole mit Namen

       2.8.2. Zusammengesetzte temporÑre Symbole

      2.9. FormelausdrÅcke

       2.9.1. Integerkonstanten

       2.9.2. Gleitkommakonstanten

       2.9.3. Stringkonstanten

       2.9.4. Evaluierung

       2.9.5. Operatoren

       2.9.6. Funktionen

      2.10. VorwÑrtsreferenzen und andere Desaster

      2.11. Registersymbole

      2.12. Sharefile

      2.13. Prozessor-Aliasse

     3. Pseudobefehle

      3.1. Definitionen

       3.1.1. SET, EQU und CONSTANT

       3.1.2. SFR und SFRB

       3.1.3. XSFR und YSFR

       3.1.4. LABEL

       3.1.5. BIT

       3.1.6. DBIT

       3.1.7. PORT

       3.1.8. REG und NAMEREG

       3.1.9. LIV und RIV

       3.1.10. CHARSET

       3.1.11. CODEPAGE

       3.1.12. ENUM

       3.1.13. PUSHV und POPV

      3.2. Codebeeinflussung

       3.2.1. ORG

       3.2.2. CPU

       3.2.3. SUPMODE, FPU, PMMU

       3.2.4. FULLPMMU

       3.2.5. PADDING

       3.2.6. PACKING

       3.2.7. MAXMODE

       3.2.8. EXTMODE und LWORDMODE

       3.2.9. SRCMODE

       3.2.10. BIGENDIAN

       3.2.11. WRAPMODE

       3.2.12. SEGMENT

       3.2.13. PHASE und DEPHASE

       3.2.14. SAVE und RESTORE

       3.2.15. ASSUME

       3.2.16. EMULATED

       3.2.17. BRANCHEXT

      3.3. Datendefinitionen

       3.3.1. DC[.size]

       3.3.2. DS[.size]

       3.3.3. DB,DW,DD,DQ & DT

       3.3.4. DS, DS8

       3.3.5. BYT oder FCB

       3.3.6. BYTE

       3.3.7. DC8

       3.3.8. ADR oder FDB

       3.3.9. WORD

       3.3.10. DW16

       3.3.11. LONG

       3.3.12. SINGLE, DOUBLE und EXTENDED

       3.3.13. FLOAT und DOUBLE

       3.3.14. EFLOAT, BFLOAT, TFLOAT

       3.3.15. Qxx und LQxx

       3.3.16. DATA

       3.3.17. ZERO

       3.3.18. FB und FW

       3.3.19. ASCII und ASCIZ

       3.3.20. STRING und RSTRING

       3.3.21. FCC

       3.3.22. DFS oder RMB

       3.3.23. BLOCK

       3.3.24. SPACE

       3.3.25. RES

       3.3.26. BSS

       3.3.27. DSB und DSW

       3.3.28. DS16

       3.3.29. ALIGN

       3.3.30. LTORG

      3.4. Makrobefehle

       3.4.1. MACRO

       3.4.2. IRP

       3.4.3. IRPC

       3.4.4. REPT

       3.4.5. WHILE

       3.4.6. EXITM

       3.4.7. SHIFT

       3.4.8. MAXNEST

       3.4.9. FUNCTION

      3.5. Strukturen

       3.5.1. Definition

       3.5.2. Nutzung

       3.5.3. geschachtelte Strukturen

       3.5.4. Unions

       3.5.5. Strukturen und Sektionen

      3.6. bedingte Assemblierung

       3.6.1. IF / ELSEIF / ENDIF

       3.6.2. SWITCH / CASE / ELSECASE / ENDCASE

      3.7. Listing-Steuerung

       3.7.1. PAGE

       3.7.2. NEWPAGE

       3.7.3. MACEXP

       3.7.4. LISTING

       3.7.5. PRTINIT und PRTEXIT

       3.7.6. TITLE

       3.7.7. RADIX

       3.7.8. OUTRADIX

      3.8. lokale Symbole

       3.8.1. Grunddefinition (SECTION/ENDSECTION)

       3.8.2. Verschachtelung und Sichtbarkeitsregeln

       3.8.3. PUBLIC und GLOBAL

       3.8.4. FORWARD

       3.8.5. Geschwindigkeitsaspekte

      3.9. Diverses

       3.9.1. SHARED

       3.9.2. INCLUDE

       3.9.3. BINCLUDE

       3.9.4. MESSAGE, WARNING, ERROR und FATAL

       3.9.5. READ

       3.9.6. RELAXED

       3.9.7. END

     4. Prozessorspezifische Hinweise

      4.1. 6811

      4.2. PowerPC

      4.3. DSP56xxx

      4.4. H8/300

      4.5. SH7000/7600/7700

      4.6. MELPS-4500

      4.7. 6502UNDOC

      4.8. MELPS-740

      4.9. MELPS-7700/65816

      4.10. M16

      4.11. 4004/4040

      4.12. MCS-48

      4.13. MCS-51

      4.14. MCS-251

      4.15. 8085UNDOC

      4.16. 8086..V35

      4.17. 8X30x

      4.18. XA

      4.19. AVR

      4.20. Z80UNDOC

      4.21. Z380

      4.22. TLCS-900(L)

      4.23. TLCS-90

      4.24. TLCS-870

      4.25. TLCS-47

      4.26. TLCS-9000

      4.27. 29xxx

      4.28. 80C16x

      4.29. PIC16C5x/16C8x

      4.30. PIC17C4x

      4.31. ST6

      4.32. ST7

      4.33. ST9

      4.34. 6804

      4.35. TMS3201x

      4.36. TMS320C2x

      4.37. TMS320C3x

      4.38. TMS9900

      4.39. TMS70Cxx

      4.40. TMS370xxx

      4.41. MSP430

      4.42. COP8 & SC/MP

      4.43. SC144xxx

      4.44. 75K0

      4.45. 78K0

      4.46. 78K2

      4.47. uPD772x

      4.48. F2MC16L

     5. Dateiformate

      5.1. Code-Dateien

      5.2. Debug-Dateien

     6. Hilfsprogramme

      6.1. PLIST

      6.2. BIND

      6.3. P2HEX

      6.4. P2BIN

      6.5. AS2MSG

     A. Fehlermeldungen von AS

     B. E/A-Fehlermeldungen

     C. HÑufig gestellte Fragen

     D. Pseudobefehle gesammelt

     E. Vordefinierte Symbole

     F. Mitgelieferte Includes

      F.1. BITFUNCS.INC

      F.2. CTYPE.INC

     G. Danksagungen

     H. énderungen seit Version 1.3

     I. Hinweise zum Quellcode von AS

      I.1. Verwendete Sprache

      I.2. Abfangen von SystemabhÑngigkeiten

      I.3. SystemunabhÑngige Dateien

       I.3.1. Von AS genutzte Module

       I.3.2. ZusÑtzliche Module fÅr die Hilfsprogramme

      I.4. WÑhrend der Erzeugung von AS gebrauchte Module

      I.5. Generierung der Nachrichtendateien

       I.5.1. Format der Quelldateien

      I.6. Dokumentationserzeugung

      I.7. Testsuite

      I.8. EinhÑngen eines neuen Zielprozessors

      I.9. Lokalisierung auf eine neue Sprache




        1. Allgemeines
        ==============

Diese  Anleitung wendet  sich an  Leute, die  bereits in Assembler pro-
grammiert  haben und sich  darÅber informieren mîchten,  wie man mit AS
umgeht.  Sie hat eher die Form  eines Referenz- und nicht Benutzerhand-
buches.  Als solches macht  sie weder den  Versuch, die Sprache Assemb-
ler  an sich zu  erklÑren, noch erlÑutert  sie die Architektur bestimm-
ter  Prozessoren. Im Literaturverzeichnis habe ich weiterfÅhrende Lite-
ratur  aufgelistet, die bei der  Implementation der einzelnen Codegene-
ratoren  ma·gebend war.  Um Assembler  von Grund  auf zu  lernen, kenne
ich  kein Buch;  ich habe  es im  wesentlichen im  ,,Trial and error''-
Verfahren gelernt.


        1.1. Lizenzbedingungen
        ----------------------

Bevor es in medias res geht, erst einmal der unvermeidliche Prolog:

AS  in der vorliegenden  Version untersteht der  Gnu General Public Li-
cense  (GPL); die Details dieser Lizenz  kînnen Sie in der beiliegenden
Datei  COPYING nachlesen. Falls Sie diese  nicht mit AS erhalten haben,
beschweren Sie sich bei demjenigen, von dem Sie AS erhalten haben!

Kurz gesagt, beinhaltet die GPL folgende Punkte:

  - Auf AS aufbauende Programme mÅssen ebenfalls der GPL unterstehen;
  - Weiterverbreitung ausdrÅcklich erlaubt;
  - expliziter  Haftungsausschlu· fÅr  durch die  Anwendung dieses Pro-
    grammes entstehende SchÑden.

...aber  fÅr die  Details bitte  ich wirklich,  in den Originaltext der
GPL zu schauen!

Um   eine   mîglichst   schnelle   Fehlerdiagnose   und  -korrektur  zu
ermîglichen, bitte ich, Fehlerberichten folgende Angaben beizufÅgen:

  - Hardware:
      - Prozessortyp (mit/ohne Koprozessor)
      - Speicherausbau
      - Grafikkarte
      - Festplatte und Typ deren Interfaces
  - Software:
      - Betriebssystem (MS/DR/Novell-DOS, OS/2, Windows) und Version
      - installierte speicherresidente Programme
      - benutzte Version von AS + Datum des EXE-Files
  - mîglicht die Quelldatei, bei der der Fehler auftritt

Zu erreichen bin ich folgenderma·en:

  - per Post:
        Alfred Arnold
        Hirschgraben 29
        52062 Aachen
  - per E-Mail: alfred@ccac.rwth-aachen.de

Wer  mir persînlich  Fragen stellen  will (und  in der  NÑhe von Aachen
wohnt),  kann dies  mit hoher  Wahrscheinlichkeit donnerstags von 20.00
bis    21.00    Uhr    im    Computerclub    an    der    RWTH   Aachen
(Eilfschornsteinstra·e 16, Keller PhilosophengebÑude RÅckseite).

Von  Telefonanrufen bitte ich abzusehen. Erstens, weil sich die kompli-
zierten  ZusammenhÑnge am  Telefon nur  Ñu·erst schwer  erîrten lassen,
und zweitens ist die Telekom schon reich genug...

Die  neueste Version von AS  (DOS, DPMI, OS/2, C)  findet sich auf fol-
gendem Server:

 http://john.ccac.rwth-aachen.de:8000/as

oder auch kurz

 http://www.alfsembler.de

Die  Quellen der  C-Version kînnen  weiterhin von  folgendem Server ge-
holt werden:

 sunsite.unc.edu
   Verzeichnis pub/Linux/devel/lang/assemblers/asl-<version>.tar.gz

...und damit natÅrlich von jedem Sunsite-Spiegel der Welt!

Wer  Åber keinen  FTP-Zugang verfÅgt,  kann den  Assembler auch von mir
anfordern.  Ich  werde  aber  nur  Anfragen  beantworten, die einen CD-
Rohling  und einen passenden,  frankierten RÅckumschlag enthalten. KEIN
Geld schicken!!!

So.  Nach diesem unvermeidlichen  Vorwort kînnen wir  wohl beruhigt zur
eigentlichen Anleitung schreiten:


        1.2. allgemeine FÑhigkeiten des Assemblers
        ------------------------------------------

AS  bietet im  Gegensatz zu  normalen Assemblern  die Mîglichkeit, Code
fÅr  vîllig verschiedene Prozessoren zu erzeugen. Momentan sind folgen-
de Prozessorfamilien implementiert:

  - Motorola 68000..68040,683xx inkl. Koprozessor und MMU
  - Motorola ColdFire
  - Motorola DSP5600x,DSP56300
  - Motorola/IBM MPC601/MPC505/PPC403
  - Motorola M-Core
  - Motorola 6800, 68(HC)11(K4) sowie Hitachi 6301
  - Motorola/Freescale 6805, 68HC(S)08
  - Motorola 6809 / Hitachi 6309
  - Motorola/Freescale 68HC12(X) inklusive XGATE
  - Freescale 68RS08
  - Motorola 68HC16
  - Hitachi H8/300(H)
  - Hitachi H8/500
  - Hitachi SH7000/7600/7700
  - Rockwell 6502 und 65(S)C02
  - CMD 65816
  - Mitsubishi MELPS-740
  - Mitsubishi MELPS-7700
  - Mitsubishi MELPS-4500
  - Mitsubishi M16
  - Mitsubishi M16C
  - Intel 4004/4040
  - Intel MCS-48/41
  - Intel MCS-51/251, Dallas DS80C390
  - Intel MCS-96/196(Nx)/296
  - Intel 8080/8085
  - Intel i960
  - Signetics 8X30x
  - Signetics 2650
  - Philips XA
  - Atmel (Mega-)AVR
  - AMD 29K
  - Siemens 80C166/167
  - Zilog Z80, Z180, Z380
  - Zilog Z8, eZ8
  - Xilinx KCPSM/KCPSM3 ('PicoBlaze')
  - LatticeMico8
  - Toshiba TLCS-900(L)
  - Toshiba TLCS-90
  - Toshiba TLCS-870
  - Toshiba TLCS-47
  - Toshiba TLCS-9000
  - Microchip PIC16C54..16C57
  - Microchip PIC16C84/PIC16C64
  - Microchip PIC17C42
  - SGS-Thomson ST6
  - SGS-Thomson ST7
  - SGS-Thomson ST9
  - SGS-Thomson 6804
  - Texas Instruments TMS32010/32015
  - Texas Instruments TMS3202x
  - Texas Instruments TMS320C3x
  - Texas Instruments TMS320C20x/TMS320C5x
  - Texas Instruments TMS320C54x
  - Texas Instruments TMS320C6x
  - Texas Instruments TMS9900
  - Texas Instruments TMS7000
  - Texas Instruments TMS370xxx
  - Texas Instruments MSP430
  - National Semiconductor SC/MP
  - National Semiconductor INS807x
  - National Semiconductor COP4
  - National Semiconductor COP8
  - National Semiconductor SC144xx
  - Fairchild ACE
  - NEC ÊPD78(C)1x
  - NEC ÊPD75xxx (alias 75K0)
  - NEC 78K0
  - NEC 78K2
  - NEC ÊPD7720/7725
  - NEC ÊPD77230
  - Fujitsu F˝MC8L
  - Fujitsu F˝MC16L
  - Symbios Logic SYM53C8xx (ja, die kann man programmieren!)
  - Intersil CDP1802/1805

in Arbeit / Planung / öberlegung :

  - NEC 78K4
  - Intel 8008
  - Analog Devices ADSP21xx
  - SGS-Thomson ST20
  - Texas Instruments TMS320C4x
  - Texas Instruments TMS320C8x
  - Toshiba TC9331

Noch gesucht werden Unterlagen fÅr:

  - die ganze Palette der OKI-Controller

ungeliebt, aber doch vorhanden :

  - Intel 8086, 80186, NEC V30&V35 inkl. Koprozessor 8087

Die  Umschaltung des Codegenerators  darf dabei auch  mitten in der Da-
tei erfolgen, und das beliebig oft!

Der  Grund fÅr diese  FlexibilitÑt ist, da·  AS eine Vorgeschichte hat,
die  auch in der  Versionsnummer deutlich wird:  AS ist als Erweiterung
eines  Makroassemblers fÅr die 68000er-Familie entstanden. Auf besonde-
ren  Wunsch habe ich den ursprÅnglichen  Assembler um die FÑhigkeit zur
öbersetzung  von 8051-Mnemonics erweitert, und  auf dem Weg (Abstieg?!)
vom  68000  zum  8051  sind  eine  Reihe anderer fast nebenbei abgefal-
len...die  restlichen Prozessoren  wurden allesamt  auf Benutzeranfrage
hin  integriert. Zumindest beim prozessorunabhÑngigen Kern kann man al-
so  getrost davon ausgehen, da· er  gut ausgetestet und von offensicht-
lichen  Bugs frei  ist. Leider  habe ich  aber hÑufig mangels passender
Hardware  nicht  die  Mîglichkeit,  einen neuen Codegenerator praktisch
zu  testen,  so  da·  bei  Neuerungen öberraschungen nie ganz auszusch-
lie·en  sind.  Das  in  Abschnitt  1.1  gesagte  hat  also schon seinen
Grund...

Diese  FlexibilitÑt bedingt  ein etwas  exotisches Codeformat, fÅr des-
sen  Bearbeitung ich  einige Tools  beigelegt habe.  Deren Beschreibung
findet sich in Abschnitt 6.

AS  ist ein Makroassembler, d.h.  dem Programmierer ist die Mîglichkeit
gegeben,   sich   mittels   Makros   neue  ,,Befehle''  zu  definieren.
ZusÑtzlich  beherrscht  er  die  bedingte  Assemblierung. Labels in Ma-
krorÅmpfen werden automatisch als lokal betrachtet.

Symbole  kînnen  fÅr  den  Assembler  sowohl Integer-, String- als auch
Gleitkommawerte  haben. Diese werden ---  wie Zwischergebnisse bei For-
meln  --- mit einer Breite  von 32 Bit fÅr  Integerwerte, 80/64 Bit fÅr
Gleitkommawerte  und 255 Zeichen fÅr Strings gespeichert. FÅr eine Rei-
he  von Mikrokontrollern besteht  die Mîglichkeit, durch Segmentbildung
die  Symbole bestimmten Klassen zuzuordnen.  Dem Assembler kann man auf
diese  Weise  die  ---  begrenzte  ---  Mîglichkeit  geben, Zugriffe in
falsche Adre·rÑume zu erkennen.

Der  Assembler kennt keine expliziten BeschrÑnkungen bzgl. Verschachte-
lungstiefe  von Includefiles oder Makros,  eine Grenze bildet lediglich
die  durch den  Hauptspeicher beschrÑnkte  Rekursionstiefe. Ebenso gibt
es  keine Grenze fÅr die SymbollÑnge,  diese wird nur durch die maxima-
le ZeilenlÑnge begrenzt.

Ab  Version 1.38 ist AS ein Mehrpass-Assembler. Dieser hochtrabende Be-
griff  bedeutet nicht  mehr, als  das die  Anzahl der  DurchgÑnge durch
die    Quelltexte   nicht    mehr   zwei    sein   mu·.    Sind   keine
VorwÑrtsreferenzen  im  Quellcode  enthalten,  so  kommt  AS  mit einem
Durchgang  aus. Stellt  sich dagegen  im zweiten  Durchgang heraus, da·
ein  Befehl mit einer  kÅrzeren oder lÑngeren  Kodierung benutzt werden
mu·,  so wird  ein dritter  (vierter, fÅnfter...)  Durchgang eingelegt,
um  alle Symbolreferenzen  richtig zu  stellen. Mehr  steckt hinter dem
Begriff  ,,Multipass'' nicht...er  wird im  weiteren Verlauf dieser An-
leitung deswegen auch nicht mehr auftauchen.

Nach  soviel Lobhudelei  ein dicker  Wermutstropfen: AS  erzeugt keinen
linkfÑhigen  Code. Eine Erweiterung  um einen Linker  wÑre mit erhebli-
chem Aufwand verbunden und ist momentan nicht in Planung.

Wer  einen Blick in die  Quellen von AS werfen  will, besorge sich ein-
fach  die Unix-Version von  AS, die als  Quelltext zum SelberÅbersetzen
kommt.  Die Quellen sind mit Sicherheit  nicht in einem Format, da· das
VerstÑndnis  mîglichst  leicht  macht  -  an vielen Stellen schaut noch
der  originale  Pascal-Quellcode  heraus,  und  ich teile einige hÑufig
vertretene Ansichten Åber 'guten' C-Stil nicht...


        1.3. UnterstÅtzte Plattformen
        -----------------------------

Obwohl  AS als ein reines DOS-Programm  angefangen hat, stehen auch ei-   DOS
ne  Reihe von  Versionen zur  VerfÅgung, die  etwas mehr  als den Real-
Mode  eines Intel-Prozessors ausnutzen kînnen.  Diese sind in ihrer Be-
nutzung  soweit als mîglich kompatibel gehalten zur DOS-Version, es er-
geben  sich natÅrlich  bisweilen Unterschiede  in der  Installation und
der  Einbindung in die  jeweilige Betriebssystemumgebung. Abschnitte in
dieser  Anleitung, die  nur fÅr  eine bestimmte  Version von AS gelten,
sind  mit einer entsprechenden Randbemerkung  (an diesem Absatz fÅr die
DOS-Version)  gekennzeichnet.  Im  einzelnen  existieren die folgenden,
weiteren Versionen (die als getrennte Pakete distributiert werden):

FÅr  den Fall, da· man bei  der öbersetzung gro·er, komplexer Programme   DPMI
unter  DOS Speicherplatzprobleme  bekommt, existiert  eine DOS-Version,
die  mittels eines DOS-Extenders  im Protected Mode  ablÑuft und so das
komplette  Extended Memory eines ATs  nutzen kann. Die öbersetzung wird
durch  den  Extender  merklich  langsamer,  aber immerhin lÑuft es dann
noch...

FÅr  Freunde von  IBM's Betriebssystem  OS/2 gibt  es eine native OS/2-   OS/2
Version  von AS. Seit 1.41r8 ist  diese nur eine volle 32-bittige OS/2-
Anwendung,  was natÅrlich  zur Folge  hat, da·  OS/2 2.x und ein 80386-
Prozessor jetzt zwingend erforderlich sind.

Den  reinen PC-Bereich verlÑ·t man mit der C-Version von AS, die so ge-   UNIX
halten  wurde,  da·  sie  auf  einer  mîglichst  gro·en  Zahl von UNIX-
artigen  Systemen (dazu zÑhlt aber auch  OS/2 mit dem emx-Compiler) oh-
ne  gro·artige Verrenkungen Åbersetzbar ist. Im Gegensatz zu den vorhe-
rigen  Versionen (die  auf den  auf Anfrage erhÑltlichen Pascal-Sourcen
basieren)  wird die C-Version  im Quellcode ausgeliefert,  d.h. man mu·
sich  mittels eines  Compilers selbst  die Binaries  erzeugen. Dies ist
aber  (fÅr mich) der eindeutig einfachere  Weg, als ein Dutzend Binari-
es  fÅr Maschinen  vorzukompilieren, auf  die ich  auch nicht immer Zu-
griff habe...

Wer  die bisherige AufzÑhlung  liest, wird feststellen,  da· das meist-   ???
verkaufte  Betriebssystem  der  Welt  aus  Redmont in dieser AufzÑhlung
fehlt.  Wer  mich  persînlich  kennt,  wei·,  da· ich Windows (egal, ob
3.X,  95 oder NT) nicht fÅr das  Ei des Kolumbus halte. Kurzgesagt, ich
bin  ein ,,Windows-Hasser''. Auch wenn eine  gro·e Zahl an Leuten diese
Einstellung  fÅr Åberholt bis lÑcherlich erachten und mir jetzt vorhal-
ten,  ich wÅrde hier einem gro·en Teil potentieller Anwender AS vorent-
halten,  so werden sie sich doch  damit abfinden mÅssen: Ich treibe die
Entwicklung  an AS primÑr weiter,  weil sie mir Spa·  macht; AS ist ein
nicht-kommerzielles  Projekt und  ich nehme  mir deswegen die Freiheit,
nicht  auf  potentielle  Marktanteile  zu  schielen.  Ich suche mir die
Plattformen  aus, auf denen das Programmieren  mir Spa· macht, und Pro-
grammieren  unter  Windows  macht  mir  definitiv keinen Spa·! Ich habe
Åbrigens  durchaus schon einmal  Windows-Programme schreiben mÅssen, es
ist  also  nicht  so,  da·  ich  hier  ohne  Erfahrung etwas daherreden
wÅrde.  Sofern irgendjemand AS in  diese Richtung portieren will, werde
ich  mich ihm nicht in den Weg  stellen, Åber die Sourcen hinaus hat er
aber  nicht viel  Hilfe von  mir zu  erwarten (und  mu· sich selber mit
den  Anfragen  der  QualitÑt  herumschlagen,  warum AS denn jetzt nicht
mehr  lÑuft, nachdem man  den Brummi-CAD 18.53-Eintrag  in der Registry
von Gro·- in Kleinbuchstaben geÑndert hat...).


        2. Benutzung des Assemblers
        ===========================


    Scotty: Captain, we din' can reference it!
    Kirk: Analysis, Mr. Spock?
    Spock: Captain, it doesn't appear in the symbol table.
    Kirk: Then it's of external origin?
    Spock: Affirmative.
    Kirk: Mr. Sulu, go to pass two.
    Sulu: Aye aye, sir, going to pass two.



        2.1. Hardware-Anforderungen
        ---------------------------

Je nach Version von AS variieren die Hardware-Anforderungen deutlich:

Die  DOS-Version lÑuft prinzipiell auf allen IBM-kompatiblen PCs, ange-   DOS
fangen  vom PC/XT mit vierkommawenig Megaherz  bis hin zum Pentium. Wie
bei  vielen  anderen  Programmen  aber  auch, steigt der Lustgewinn mit
der  Hardware-Ausstattung.  So  dÅrfte  ein XT-Benutzer ohne Festplatte
erhebliche  Probleme haben, die Åber  500 Kbyte gro·e Overlay-Datei von
AS  auf einer  Diskette unterzubringen...eine  Festplatte sollte der PC
also  schon haben,  allein um  vernÅnftige Ladezeiten  zu erreichen. Im
Hauptspeicherbedarf  ist AS recht genÅgsam:  Das Programm selber belegt
knapp  300 Kbyte Hauptspeicher, AS  sollte also ab einer Hauptspeicher-
grî·e von 512 Kbyte ausfÅhrbar sein.

Die   Version  von  AS   fÅr  das  DOS-Protected-Mode-Interface  (DPMI)   DPMI
benîtigt  zum  Ablaufen  mindestens  einen  80286-Prozessor und 1 Mbyte
freies  extended memory. Daher stellen  2 Mbyte Hauptspeicher das abso-
lute  Minimum  dar,  wenn  man  im  XMS sonst keine anderen Spielereien
(Platten-Cache,  RAM-Disk,  hochgeladenes  DOS)  installiert hat, sonst
entsprechend  mehr. Falls man die DPMI-Version in einer DOS-Box von OS/
2  laufen lÑ·t,  so sollte  DPMI auch  in den DOS-Einstellungen der Box
erlaubt  sein (Einstellung An oder Auto)  und der Box eine entsprechen-
de  Menge von XMS-Speicher zugeordnet  sein. Die virtuelle Speicherver-
waltung  von OS/2 sorgt hier Åbrigens  dafÅr, da· man sich keine Gedan-
ken machen mu·, ob der eingestellte Speicher auch real verfÅgbar ist.

Die  Hardware-Anforderungen  der  OS/2-Version  ergeben sich weitestge-   OS/2
hend  durch die des  darunterliegenden Betriebssytemes, d.h. mindestens
ein  80386SX-Prozessor, 8 Mbyte  RAM (bzw. 4  ohne grafische Benutzero-
berflÑche)  sowie ca  100..150 Mbyte  Platz auf  der Festplatte. Da AS2
nur  eine  16-Bit-Applikation  ist,  sollte  er  theoretisch  auch  auf
Ñlteren  OS/2-Versionen (und  damit 80286-Prozessoren)  lauffÑhig sein;
ausprobieren konnte ich dies aber nicht.

Die  C-Version von AS wird im  Quellcode ausgeliefert und erfordert da-   UNIX
mit  ein Unix- oder OS/2-System mit  einem C-Compiler. Der Compiler mu·
dem  ANSI-Standard  genÅgen  (GNU-C  erfÅllt  diese  Bedingung zum Bei-
spiel).  Ob Ihr UNIX-System bereits getestet und die nîtigen Definitio-
nen  vorgenommen  wurden,  kînnen  Sie  der README-Datei entnehmen. Als
zur  Kompilation benîtigten Plattenplatz sollten  Sie ca. 15 Mbyte ver-
anschlagen;  dieser Wert (und  der nach der  öbersetzung noch benîtigte
Platz  fÅr die Åbersetzten Programme) variiert allerdings stark von Sy-
stem  zu System, so da· man  diesen Wert nur als Richtschnur betrachten
sollte.


        2.2. Lieferumfang
        -----------------

Prinzipiell   erhÑlt   man   AS   in   einer   von   zwei  Formen:  Als
BinÑrdistribution    oder   Quellcodedistribution.   Im   Falle   einer
BinÑrdistribution  bekommt man AS  mit den zugehîrigen Dienstprogrammen
und  Hilfsdateien fertig Åbersetzt,  so da· man  nach dem Auspacken des
Archivs    an   die    gewÅnschte   Stelle    direkt   loslegen   kann.
BinÑrdistributionen  werden  fÅr  verbreitete  Plattformen gemacht, bei
denen   die  Mehrzahl  der  Benutzer   keinen  Compiler  hat  oder  die
öbersetzung  trickreich ist  (im Moment  sind dies  DOS und OS/2). Eine
Quellcodedistribution  enthÑlt im  Gegensatz den  kompletten Satz an C-
Quellen,  um AS  zu generieren;  es ist  letzten Endes ein Schnappschu·
des  Quellenbaumes,  an  dem  ich  AS weiterentwickele. Die Generierung
von  AS aus dem Quellcode und dessen Struktur ist nÑher in Anhang I be-
schrieben,  weshalb an dieser Stelle nur auf den Umfang und die Instal-
lation einer BinÑrdistribution beschrieben wird:

Das  Archiv des Lieferumfangs gliedert sich in einige Unterverzeichnis-
se,  so  da·  man  nach  dem  Auspacken  sofort  einen  Verzeichnisbaum
erhÑlt. Die Verzeichnisse enthalten im einzelnen:

  -  BIN: ausfÅhrbare Programme, Text-Resourcen;
  -  INCLUDE:  Include-Dateien fÅr Assemblerprogramme, z.B. Registerde-
    finitionen oder Standardmakros;
  -  MAN: Kurzreferenzen fÅr die Programme im Unix-Man-Format;
  -  DOC: diese Dokumentation in verschiedenen Formaten;
  -  LIB: vorgesehen fÅr Initialisierungsdateien.

Eine  Auflistung der Dateien, die  in jeder BinÑrdistribution enthalten
sind,  findet sich in den Tabellen 2.1  bis 2.3. Falls eine der in die-
sen  (oder den folgenden) Tabellen  aufgefÅhrten Dateien fehlt, hat je-
mand (im Zweifelsfalle ich) beim Kopieren geschlafen...


+---------------------+----------------------------------------------+
| Datei               | Funktion                                     |
+---------------------+----------------------------------------------+
+---------------------+----------------------------------------------+
| Verzeichnis BIN     |                                              |
+---------------------+----------------------------------------------+
| AS.EXE              | Programmdatei Assembler                      |
| PLIST.EXE           | listet Inhalt von Codedateien auf            |
| PBIND.EXE           | kopiert Codedateien zusammen                 |
| P2HEX.EXE           | wandelt Code- in Hexdateien um               |
| P2BIN.EXE           | wandelt Code- in BinÑrdateien um             |
| AS.MSG              | Textresourcen zu AS                          |
| PLIST.MSG           | Textresourcen zu PLIST                       |
| PBIND.MSG           | Textresourcen zu PBIND                       |
| P2HEX.MSG           | Textresourcen zu P2HEX                       |
| P2BIN.MSG           | Textresourcen zu P2BIN                       |
| TOOLS.MSG           | gemeinsame Textresourcen zu den Tools        |
| CMDARG.MSG          | gemeinsame Textresourcen zu allen Programmen |
| IOERRS.MSG          |                                              |
+---------------------+----------------------------------------------+
+---------------------+----------------------------------------------+
| Verzeichnis DOC     |                                              |
+---------------------+----------------------------------------------+
| AS_DE.DOC           | deutsche Dokumentation, ASCII-Format         |
| AS_DE.HTML          | deutsche Dokumentation, HTML-Format          |
| AS_DE.TEX           | deutsche Dokumentation, LaTeX-Format         |
| AS_EN.DOC           | englische Dokumentation, ASCII-Format        |
| AS_EN.HTML          | englische Dokumentation, HTML-Format         |
| AS_EN.TEX           | englische Dokumentation, LaTeX-Format        |
+---------------------+----------------------------------------------+
+---------------------+----------------------------------------------+
| Verzeichnis INCLUDE |                                              |
+---------------------+----------------------------------------------+
| BITFUNCS.INC        | Funktionen zur Bitmanipulation               |
| CTYPE.INC           | Funktionen zur Klassifizierung von           |
|                     | Zeichen                                      |
| 80C50X.INC          | Registeradressen SAB C50x                    |
| 80C552.INC          | Registeradressen 80C552                      |
| H8_3048.INC         | Registeradressen H8/3048                     |
| REG166.INC          | Adressen & Befehlsmakros 80C166/167          |
| REG251.INC          | Adressen & Bits 80C251                       |
| REG29K.INC          | Peripherieadressen AMD 2924x                 |
| REG53X.INC          | Registeradressen H8/53x                      |
| REG683XX.INC        | Registeradressen 68332/68340/68360           |
| REG7000.INC         | Registeradressen TMS70Cxx                    |
| REG78K0.INC         | Registeradressen 78K0                        |
| REG96.INC           | Registeradressen MCS-96                      |
| REGACE.INC          | Registeradressen ACE                         |
+---------------------+----------------------------------------------+

Tabelle 2.1: Standardumfang einer BinÑrdistribution - Teil 1



   +---------------------+---------------------------------------+
   | Datei               | Funktion                              |
   +---------------------+---------------------------------------+
   +---------------------+---------------------------------------+
   | Verzeichnis INCLUDE |                                       |
   +---------------------+---------------------------------------+
   | REGAVR.INC          | Register- & Bitadressen AVR-Familie   |
   | REGCOP8.INC         | Registeradressen COP8                 |
   | REGGP32.INC         | Registeradressen 68HC908GP32          |
   | REGHC12.INC         | Registeradressen 68HC12               |
   | REGM16C.INC         | Registeradressen Mitsubishi M16C      |
   | REGMSP.INC          | Registeradressen TI MSP430            |
   | REGST9.INC          | Register- & Makrodefinitionen ST9     |
   | REGZ380.INC         | Registeradressen Z380                 |
   | STDDEF04.INC        | Registeradressen 6804                 |
   | STDDEF16.INC        | Befehlsmakros und Registeradressen    |
   |                     | PIC16C5x                              |
   | STDDEF17.INC        | Registeradressen PIC17C4x             |
   | STDDEF18.INC        | Registeradressen PIC16C8x             |
   | STDDEF2X.INC        | Registeradressen TMS3202x             |
   | STDDEF37.INC        | Register- & Bitadressen TMS370xxx     |
   | STDDEF3X.INC        | Peripherieadressen TMS320C3x          |
   | STDDEF47.INC        | Befehlsmakros TLCS-47                 |
   | STDDEF51.INC        | Definition von SFRs und Bits fÅr      |
   |                     | 8051/8052/80515                       |
   | STDDEF56K.INC       | Registeradressen DSP56000             |
   | STDDEF5X.INC        | Peripherieadressen TMS320C5x          |
   | STDDEF60.INC        | Befehlsmakros & Registeradressen      |
   |                     | PowerPC                               |
   | STDDEF62.INC        | Registeradressen & Makros ST6         |
   | STDDEF75.INC        | Registeradressen 75K0                 |
   | STDDEF87.INC        | Register- & Speicheradressen TLCS-870 |
   | STDDEF90.INC        | Register- & Speicheradressen TLCS-90  |
   | STDDEF96.INC        | Register- & Speicheradressen TLCS-900 |
   | STDDEFXA.INC        | SFR-& Bitadressen Philips XA          |
   | STDDEFZ8.INC        | Registeradressen Z8-Familie           |
   +---------------------+---------------------------------------+
   +---------------------+---------------------------------------+
   | Verzeichnis LIB     |                                       |
   +---------------------+---------------------------------------+

Tabelle 2.2: Standardumfang einer BinÑrdistribution - Teil 2



             +-----------------+------------------------+
             | Datei           | Funktion               |
             +-----------------+------------------------+
             +-----------------+------------------------+
             | Verzeichnis MAN |                        |
             +-----------------+------------------------+
             | ASL.1           | Kurzanleitung zu AS    |
             | PLIST.1         | Kurzanleitung zu PLIST |
             | PBIND.1         | Kurzanleitung zu PBIND |
             | P2HEX.1         | Kurzanleitung zu P2HEX |
             | P2BIN.1         | Kurzanleitung zu P2BIN |
             +-----------------+------------------------+

Tabelle 2.3: Standardumfang einer BinÑrdistribution - Teil 3


Je  nach Plattform kann eine BinÑrdistribution aber noch weitere Datei-
en  enthalten, um  einen Betrieb  zu ermîglichen,  wie es z.B. bei DOS-
Extendern  der Fall ist.  FÅr die DOS-DPMI-Version  ergeben sich die in   DPMI
Tabelle  2.4 gelisteten  ErgÑnzungen. Es  spricht Åbrigens nichts dage-
gen,  als Hilfsprogramme  die Versionen  aus einer  DOS-Distribution zu
verwenden,  da  diese  einerseits  ohne  den Extender-Overhead deutlich
schneller  ablaufen und andererseits  den vom Extender bereitgestellten
erweiterten Speicher nicht benîtigen.


         +-----------------+-------------------------------+
         | Datei           | Funktion                      |
         +-----------------+-------------------------------+
         +-----------------+-------------------------------+
         | Verzeichnis BIN |                               |
         +-----------------+-------------------------------+
         | DPMI16BI.OVL    | DPMI-Server fÅr den Assembler |
         | RTM.EXE         | Laufzeit-Modul des Extenders  |
         +-----------------+-------------------------------+

Tabelle 2.4: ZusÑtzliche Dateien in einer DPMI-BinÑrdistribution


Eine  OS/2-BinÑrdistribution enthÑlt neben  den Basisdateien eine Reihe   OS/2
von  DLLs,  die  zur  Laufzeitumgebung  des  verwendeten  emx-Compilers
gehîren  (Tabelle 2.5). Falls man diese DLLs (oder neuere Versionen da-
von)  bereits besitzt, kann man diese auch wieder lîschen und seine ei-
genen benutzen.


        +-----------------+---------------------------------+
        | Datei           | Funktion                        |
        +-----------------+---------------------------------+
        +-----------------+---------------------------------+
        | Verzeichnis BIN |                                 |
        +-----------------+---------------------------------+
        | EMX.DLL         | Laufzeitbibliotheken fÅr AS und |
        | EMXIO.DLL       | die Dienstprogramme             |
        | EMXLIBC.DLL     |                                 |
        | EMXWRAP.DLL     |                                 |
        +-----------------+---------------------------------+

Tabelle 2.5: ZusÑtzliche Dateien in einer OS/2-BinÑrdistribution



        2.3. Installation
        -----------------

Eine    besondere    Installation    ist    fÅr   die   Nutzung   einer   DOS
BinÑrdistribution  nicht notwendig, es genÅgt,  das Archiv an passender
Stelle  auszupacken  und  dann  noch  einige Kleinigkeiten zu ergÑnzen.
Als  Beispiel  hier  eine  Installation,  wie  sie vielleicht ein UNIX-
AnhÑnger vornehmen wÅrde:

Legen  Sie ein  Verzeichnis c:\as  an (im  folgenden nehme  ich an, da·
Sie  AS auf  Laufwerk C  installieren wollen),  wechseln Sie  in dieses
und  entpacken Sie  das Archiv  unter Erhalt  der Verzeichnisnamen (bei
Verwendung  von PKUNZIP ist dazu  die Kommandozeilenoption -d erforder-
lich). Sie sollten jetzt folgenden Verzeichnisbaum haben:

c:\as
c:\as\bin
c:\as\include
c:\as\lib
c:\as\man
c:\as\doc

ErgÑnzen  Sie  jetzt  die  PATH-Anweisung  in Ihrer AUTOEXEC.BAT um das
Verzeichnis  c:\as\bin, so da·  AS und seine  Hilfsprogramme vom System
gefunden  werden. In dem lib-Verzeichnis  erzeugen Sie mit einem belie-
bigen Texteditor eine Datei AS.RC mit folgendem Inhalt:

-i c:\as\include

Diese  sogenannte Key-Datei zeigt  AS, in welchem  Verzeichnis er seine
Include-Dateien  suchen soll. Damit  AS diese Key-Datei  bei Start auch
beachtet, mu· noch folgende Anweisung in die AUTOEXEC.BAT:

set ASCMD=@c:\as\lib\as.rc

Was  Sie alles  noch in  der Key-Datei  voreinstellen kînnen,  steht im
folgenden Abschnitt.

Die  Installation der DPMI-Version sollte  im Prinzip genauso verlaufen   DPMI
wie   der  reinen  DOS-Version;  wenn   der  Pfad  das  bin-Verzeichnis
enthÑlt,  werden  die  Dateien  des  DOS-Extenders automatisch gefunden
und  man sollte  von dieser  Mimik (mit  Ausnahme der  lÑngeren Anlauf-
zeit...)  nichts mitbekommen. Theoretisch  ist es mîglich,  da· Sie auf
80286-Rechnern  beim ersten Start mit  einer Meldung der folgenden Form
konfrontiert werden:

  machine not in database (run DPMIINST)

Da  das Tool DPMIINST bei neueren  Versionen des DOS-Extenders von Bor-
land  aber nicht mehr dabei  ist, nehme ich einmal  an, da· diese Sache
sich erledigt hat...falls doch nicht, bitte ich um RÅckmeldung!

Die  Installation der OS/2-Version kann  in weiten ZÅgen genauso ablau-   OS/2
fen  wie fÅr die DOS-Version, nur da·  dem System noch die DLLs bwkannt
gemacht  werden  mÅssen.  Wenn  Sie  den  LIBPATH-Eintrag in Ihrer CON-
FIG.SYS  nicht  erweitern  wollen,  ist  es natÅrlich auch mîglich, die
DLLs  in ein  Verzeichnis zu  verschieben, das  bereits dort aufgefÅhrt
ist.

Wie  bereits  erwÑhnt,  beschrÑnkt  sich  die Installationsbeschreibung
hier  nur auf BinÑrdistributionen.  Da eine Installation  unter Unix im   UNIX
Augenblick  immer  eine  Quellcodedistribution  ist,  geht  der Verweis
hier unisono in Anhang I.


        2.4. Aufruf, Parameter
        ----------------------

AS  ist  ein  kommandozeilengesteuertes  Programm,  d.h. alle Parameter
und Dateiangaben sind in der Kommandozeile anzugeben.

Zu  AS  gehîrt  eine  Reihe  Reihe von Nachrichtendateien (erkennbar an
der  Endung MSG, aus denen  AS zur Laufzeit die  fÅr die jeweilige Lan-
dessprache  dynamisch  nachlÑdt.  AS  sucht  nach diesen Dateien in den
folgenden Verzeichnissen:

  - im aktuellen Verzeichnis;
  - im Verzeichnis der EXE-Datei;
  - in  dem  in  der  Environment-Variablen AS_MSGPATH angegebenen Ver-
    zeichnis,  oder alternativ in den  in der PATH-Variablen gelisteten
    Verzeichnissen;
  - In  dem Verzeichnis,  das AS  zur Kompilationszeit  durch das Makro
    LIBDIR mitgegeben wurde.

Diese  Dateien werden von  AS zwingend zum  Betrieb benîtigt, d.h. fin-
det AS diese Dateien nicht, bricht er an dieser Stelle sofort ab.

Die  Auswahl der  Sprache (momentan  Deutsch oder  Englisch) orientiert
sich  unter DOS und OS/2 an  der COUNTRY-Einstellung in der CONFIG.SYS,
unter Unix an der LANG-Environment-Variablen.

Um  den  Speicherbedarf  von  AS  unter  DOS  Åberhaupt  befriedigen zu   DOS
kînnen,  wurden  die  verschiedenen  Codegeneratormodule  in  der  DOS-
Version  in einen Overlay verlegt, der Teil des EXE-Files ist. Eine ge-
trennte  OVR-Datei  wie  bei  frÅheren  Versionen von AS existiert also
nicht  mehr, AS versucht aber wie  bisher auch weiterhin, die durch das
Overlaying  entstehenden  Verzîgerungen  durch  Nutzung von eventuellem
EMS-  oder XMS-Speicher zu reduzieren.  Sollte diese Verwendung zu Pro-
blemen  fÅhren, so kînnen Sie die Verwendung von EMS bzw. XMS unterbin-
den,  indem  Sie  einer  Environment-Variablen  USEXMS  bzw. USEEMS den
Wert n zuweisen. So kann man z.B. mit dem Befehl

   SET USEXMS=n

die Verwendung von extended memory verhindern.

Da  AS alle Ein-und Ausgaben Åber das Betriebssystem abwickelt (und da-
her  unter DOS auch  auf nicht ganz  so kompatiblen PC's laufen sollte)
und  eine  rudimentÑre  Bildschirmsteuerung  benîtigt,  gibt er wÑhrend
der  Assemblierung ANSI-Steuersequenzen aus. Falls  Sie in den Ausgaben
von  AS also  seltsame Zeichen  sehen sollten,  fehlt offensichtlich in   DOS/
Ihrer  CONFIG.SYS die  Einbindung des  ANSI-Treibers (device=ansi.sys),
die  weitere Funktion von AS wird dadurch aber nicht beeinflu·t. Alter-   DPMI
nativ  kînnen Sie  aber auch  die Ausgabe  von ANSI-Sequenzen durch das
Setzen der Environment-Variablen USEANSI auf n ganz unterdrÅcken.

Der  DOS-Extender der  DPMI-Version lÑ·t  sich in  seiner Speicherbele-   DPMI
gung  durch diverse  Kommandozeilenoptionen beeinflussen.  Diese kînnen
Sie  bei Bedarf  der Datei  DPMIUSER.DOC entnehmen.  ZusÑtzlich ist ASX
in  der  Lage,  bei  Bedarf  den  vorhandenen Speicher durch eine Swap-
Datei  zu  ,,erweitern''.  Dazu  belegt  man  eine Environment-Variable
ASXSWAP folgenderma·en:

    SET ASXSWAP=<Grî·e>[,Dateiname]

Die  Grî·enangabe erfolgt in Megabytes und  mu· gemacht werden. Der Na-
me  der Datei  ist dagegen  optional; fehlt  er, so wird die Swap-Datei
im  aktuellen Verzeichnis  unter dem  Namen ASX.TMP  angelegt. In jedem
Falle wird die Swap-Datei nach Programmende wieder gelîscht.

Die  Kommandozeilenparameter  kînnen  grob  in  drei Klassen eingeteilt
werden:  Schalter,  Key-File-Referenzen  (s.u.)  und Dateispezifikatio-
nen.  Parameter dieser beiden  Klassen kînnen beliebig  gemischt in der
Kommandozeile  auftreten, AS wertet  zuerst alle Parameter  aus und as-
sembliert dann die angegebenen Dateien. Daraus folgen zwei Dinge:

  - Die  angegebenen Schalter  wirken auf  alle angegebenen Quelldatei-
    en.  Sollen  mehrere  Quelldateien  mit  unterschiedlich  gesetzten
    Schaltern  assembliert werden, so mu· dies in getrennten LÑufen er-
    folgen.
  - Es  kînnen in  einem Durchgang  mehrere Dateien assembliert werden.
    Um  der Sache die Krone aufzusetzen, dÅrfen die Dateiangaben Joker-
    zeichen enthalten.

Schalterparameter  erkennt AS  daran, da·  sie durch einen SchrÑgstrich
(/)  oder  Bindestrich  (-)  eingeleitet  werden.  Es gibt dabei sowohl
Schalter,  die nur  aus einem  Buchstaben bestehen,  als auch Schalter,
die  aus  einem  ganzen  Wort  bestehen.  Immer  wenn AS einen Schalter
nicht  als ,,Wort-Schalter'' verstehen kann,  so versucht er, die Buch-
staben  des Wortes  als einzelne  Schalter zu  interpretieren. Wenn man
also z.B.

 -queit

anstelle von

 -quiet

geschrieben  hÑtte, wÅrde AS die  Buchstaben q, u, e,  i und t als ein-
zelne  Schalter auffassen. Mehrbuchstabige  Schalter unterscheiden sich
weiterhin  von  einbuchstabigen  dadurch,  da·  AS  bei ihnen beliebige
Gro·-und  Kleinschreibungen  akzeptiert,  wÑhrend einbuchstabige Schal-
ter  je nach Gro·- oder  Kleinschreibung unterschiedliche Bedeutung ha-
ben.

Momentan sind folgende Schalter definiert:

  - l:  Assemblerlisting  auf  Konsole  ausgeben.  Falls mehrere Passes
    ausgefÅhrt  werden mÅssen, landen im  Gegensatz zur nÑchsten Option
    die Listings aller DurchgÑnge auf der Ausgabe!
  - L:  Assemblerlisting auf Datei schreiben.  Die Listdatei erhÑlt da-
    bei  den gleichen  Namen wie  die Quelldatei,  lediglich die Endung
    wird durch LST ersetzt, es sei denn...
  - OLIST:  mit  einem  zusÑtzlichen  Argument  legt einen anderen Pfad
    bzw.  Namen fÅr die  Listdatei fest. Falls  mehrere Dateien assemb-
    liert werden, kann diese Option auch mehrfach gegeben werden.
  - o:Bestimmt  einen neuen  Namen fÅr  die von  AS zu erzeugende Code-
    Datei.  Wird diese Option mehrfach verwendet, so werden die angege-
    benen  Namen nacheinander den zu assemblierenden Quelldateien zuge-
    ordnet;  Negation (s.u.) dieser Option  in Verbindung mit einem Na-
    men  lîscht  den  Namen  aus  der Liste; Negation ohne Namensangabe
    lîscht die komplette Liste.
  - SHAREOUT:dito, nur fÅr eine eventuell zu erzeugende SHARE-Datei
  - c:  SHARED-Variablen werden in einem  Format abgelegt, das die Ein-
    bindung in eine C-Quelldatei erlaubt. Die Endung der Datei ist H.
  - p:  SHARED-Variablen werden in einem  Format abgelegt, das die Ein-
    bindung  in  den  CONST-Block  eines Pascal- oder Modula-Programmes
    erlaubt. Die Endung der Datei ist INC.
  - a:  SHARED-Variablen werden in einem  Format abgelegt, das die Ein-
    bindung  in eine  Assembler-Quelldatei erlaubt.  Die Endung der Da-
    tei ist INC.

Zu  Sinn  und  Funktion  der  SHARED-Symbole  siehe  Kapitel  2.12 bzw.
3.9.1.

  - g  [Format]: Mit diesem Schalter  erzeugt AS zusÑtzlich eine Datei,
    die  Debug-Informationen  fÅr  dieses  Programm enthÑlt. Als Format
    ist  dabei entweder ein AS-eigenes  Format ( Format=MAP), eine NoI-
    CE-kompatible  Kommandodatei  (  Format=NOICE)  oder das Format der
    AVR-Tools  ( Format=ATMEL)  erlaubt. Zu  den im  MAP-Format gespei-
    cherten  Informationen gehîrt zum einen  die Symboltabelle, zum an-
    deren  eine  Zuordnung  von  Quellzeilen zu Maschinenadressen. Eine
    genauere  Beschreibung des benutzten  MAP-Dateiformates findet sich
    in  Abschnitt 5.2. Die Endung  der Datei ist MAP,  NOI bzw. OBJ, je
    nach  gewÑhltem Format. Wird  keine explizite Formatangabe gemacht,
    wird das MAP-Format gewÑhlt.
  - noicemask  [Wert]: Normalerweise listet  AS in NoICE-Debuginfos nur
    Symbole  aus dem CODE-Segment. Mit dieser Option und einem als Bit-
    maske  zu verstehenden Wert lassen  sich andere Symbole aus anderen
    Segmenten  zuschalten. Die Zuordnung von Bits zu Segmenten kann Ta-
    belle 5.3 entnommen werden.
  - w: Ausgabe von Warnungen unterdrÅcken;
  - E  [Datei]: Die von  AS erzeugten Fehlermeldungen  und Warnungen in
    eine  Datei umleiten. Anstatt  einer Datei kînnen  auch die 5 Stan-
    dardhandles   (STDIN..STDPRN)  als  !0  bis  !4  angegeben  werden.
    Default  ist !2, also STDERR.  Wird die Dateiangabe weggelassen, so
    ist  der Name  der Fehlerdatei  gleich dem  der Quelldatei, nur mit
    der Endung LOG.
  - q:  Dieser Schalter unterdrÅckt alle  Meldungen von AS mit Ausnahme
    von  Fehlermeldungen  und  vom  Programm selber erzeugten Ausgaben.
    Die  Assemblierzeit kann dadurch  geringfÅgig reduziert werden, und
    beim  Aufruf aus  einer Shell  heraus kann  man sich eine Umleitung
    ersparen.  Der  Nachteil  ist,  da·  man  u.U.  einige Minuten ,,im
    Dunklen''  steht... Anstelle von 'q'  darf auch 'quiet' geschrieben
    werden.
  - h:  Hexadezimalzahlen mit Klein- anstelle von Gro·buchstaben ausge-
    ben.  Diese Option ist in erster  Linie eine Frage des persînlichen
    Geschmacks.
  - i  <Pfadliste>:  gibt  eine  Liste  von Verzeichnissen an, in denen
    der  Assembler automatisch nach  Include-Dateien suchen soll, falls
    er  diese nicht im aktuellen Verzeichnis findet. Die einzelnen Ver-
    zeichnisse mÅssen durch Semikolons getrennt werden.
  - u:  eine Liste  der in  den Segmenten  belegten Bereiche berechnen.
    Sie  ist nur sinnvoll, falls ein  Listing erzeugt wird. Diese Opti-
    on  benîtigt erhebliche  zusÑtzliche Speicher-  und Rechenleistung,
    im  Normalbetrieb sollte  sie daher  abgeschaltet sein.  Da AS aber
    unabhÑngig  vom  eingeschalteten  Listing  mit  dieser  Option  auf
    Åberlappende  Speicherbelegung prÅft,  hat sie  auch unabhÑngig vom
    Listing einen gewissen Sinn...
  - C:  erzeugt eine Liste mit  Querverweisen. Aufgelistet wird, welche
    (globalen)  Symbole in  welchen Dateien  in welchen  Zeilen benutzt
    werden.  Auch diese Liste wird nur generiert, falls ein Listing er-
    zeugt  wird und belegt wÑhrend der Assemblierung zusÑtzlichen Spei-
    cherplatz.
  - s:  eine  Liste  aller  Sektionen  (s. Abschnitt 3.8) ausgeben. Die
    Verschachtelung wird dabei durch EinrÅckungen angedeutet.
  - I:  Analog zur Sektionsliste eine Liste aller bearbeiteten Include-
    Dateien ausgeben.
  - t  <Maske>: Mit  diesem Schalter  lassen sich  einzelne Komponenten
    des  standardmÑ·ig ausgegebenen  Assemblerlistings ein-und ausblen-
    den.  Welcher  Teil  dabei  welchem  Bit  zugeordnet  ist,  ist  im
    ÅbernÑchsten  Abschnitt, der genauer auf  das Format des Assembler-
    listings eingeht, nachgelesen werden.
  - D  <Symbolliste>: Symbole definieren. Die  hinter dieser Option an-
    gegebenen,  durch Kommas getrennten Symbole  werden in der globalen
    Symboltabelle  vor Beginn der  Assemblierung abgelegt. DefaultmÑ·ig
    werden  diese Symbole als ganze Zahlen  mit dem Wert TRUE abgelegt,
    mit  einem  nachgestellten  Gleichheitszeichen  kann aber auch eine
    andere  Belegung gewÑhlt werden. Der dem Gleichheitszeichen folgen-
    de  Ausdruck  darf  dabei  auch  Operatoren oder interne Funktionen
    beinhalten,  jedoch KEINE anderen Symbole,  selbst wenn diese schon
    davor  in der Liste definiert sein sollten! Zusammen mit den Befeh-
    len  zur bedingten Assemblierung (siehe dort) kînnen so per Komman-
    dozeile  aus  einer  Quelldatei  unterschiedliche Programmversionen
    erzeugt  werden.  ACHTUNG!  Wenn  case-sensitiv  gearbeitet  werden
    soll,  mu· dies in der Kommandozeile vor Symboldefinitionen angege-
    ben  werden,  sonst  werden  Symbolnamen  schon an dieser Stelle in
    Gro·buchstaben umgewandelt!
  - A:  Die Liste globaler  Symbole in einer  anderen, kompakteren Form
    ablegen.  Verwenden Sie diese  Option, wenn der  Assembler bei lan-
    gen  Symboltabellen  mit  einem  StapelÅberlauf abstÅrzt. Eventuell
    kann   diese  Option  die   Arbeitsgeschwindigkeit  des  Assemblers
    erhîhen, dies hÑngt jedoch von den Quellen ab.
  - x:  Legt die AusfÅhrlichkeitsstufe von Fehlermeldungen fest. Jedes-
    mal,  wenn  diese  Option  angegeben  wird,  wird die Stufe um eins
    erhîht  oder gesenkt. WÑhrend auf Stufe  0 (Vorgabe) nur der Fehler
    selber  ausgegeben wird, wird ab Stufe  1 noch eine erweiterte Mel-
    dung  ausgegeben, anhand  der die  Identifizierung des  Fehlers er-
    leichtert  werden soll. Welche  Fehlermeldungen welche Zusatzinfor-
    mationen  tragen kînnen, steht in Anhang A mit der Liste aller Feh-
    lermeldungen.  Auf Stufe 2  (Maximum) wird zusÑtzlich  noch die be-
    troffene Quellzeile mit ausgegeben.
  - n:  Wird diese  Option angegeben,  so werden  Fehlermeldungen nicht
    nur  mit ihrem Klartext, sondern auch mit ihren im Anhang A genann-
    ten  internen  Nummern  ausgegeben.  Diese  Option  ist  primÑr fÅr
    Shells  und Entwicklungsumgebungen  gedacht, denen  mit diesen Num-
    mern die Identifizierung von Fehlern erleichtert werden soll.
  - U:  Mit dieser Option schaltet man  AS in den case-sensitiven Modus
    um,  d.h. in  Namen von  Symbolen, Sektionen, Makros, Zeichentabel-
    len    und   selbstdefinierte   Funktionen    werden   Klein-   und
    Gro·buchstaben  unterschieden,  was  normalerweise  nicht  der Fall
    ist.
  - P:  weist AS  an, den  von Makroprozessor  und bedingter Assemblie-
    rung  bearbeiteten Quelltext  in einer  Datei abzulegen. Dieser Da-
    tei  fehlen zusÑtzlich Leer- und  reine Kommentarzeilen. Die Endung
    der Datei ist I.
  - M:  mit diesem Schalter  erzeugt AS eine  Datei, in der die Defini-
    tionen  der  Makros  aus  der  Quelldatei abgespeichert werden, die
    die  EXPORT-Option verwenden. Diese neue Datei hat den gleichen Na-
    men   wie  die  Quelldatei,  lediglich   die  Endung  wird  in  MAC
    geÑndert.
  - G:  Dieser Schalter bestimmt, ob AS  Code erzeugen soll oder nicht.
    Ist  er ausgeschaltet, wird die  Datei zwar assembliert, aber keine
    Code-Datei  geschrieben.  Dieser  Schalter  ist  defaultmÑ·ig akti-
    viert (logisch, sonst bekÑme man ja auch gar kein Codefile).
  - r  [n]: Warnungen ausgeben, falls  Situationen eintreten, die einen
    weiteren  Pass  erfordern.  Diese  Information kann genutzt werden,
    um  die Anzahl der DurchlÑufe zu  verringern. Optional kann man die
    Nummer  des Passes angeben, ab  dem diese Warnungen erzeugt werden;
    ohne  Angabe kommen  die Warnungen  ab dem  ersten Pass. Machen Sie
    sich  aber so oder so auf  einen ziemlichen Haufen an Meldungen ge-
    fa·t!!
  - Y:  Mit diesem Schalter  weist man AS  an, alle Fehlermeldungen we-
    gen  zu langer Sprungdistanzen zu  verwerfen, sobald die Notwendig-
    keit  eines neuen  Durchlaufs feststeht.  In welchen (seltenen) Si-
    tuationen  dieser  Schalter  notwendig  ist,  kann man in Abschnitt
    2.10 nachlesen.
  - cpu  <Name:  >:  Hiermit  kann  man man den Zielprozessor vorgeben,
    fÅr  den AS  Code erzeugen  soll, wenn  die Quelldatei  keinen CPU-
    Befehl enthÑlt und es sich nicht um 68008-Code handelt.
  - alias <neu>=<alt>:
    definiert  den  Prozessortyp  <neu>  als  einen Alias fÅr den Typen
    <alt>. Zu den Sinn und Zweck von Aliassen siehe Abschnitt 2.13
  -  gnuerrors:  Meldungen Åber Fehler bzw. Warnungen und deren Positi-
    on  nicht im  Standardformat von  AS, sondern  in einem  dem GNU C-
    Compiler  entlehnten Format anzeigen. Dies erleichtert die Integra-
    tion  von  AS  in  fÅr  dieses Format ausgelegte Umgebungen, unter-
    drÅckt  aber gleichzeitig  die Anzeige  der prÑzisen Fehlerposition
    innerhalb MakrorÅmpfen!

Sofern  Schalter  keine  Argumente  benîtigen  und ihre Zusammenziehung
keinen  mehrbuchstabigen Schalter ergibt,  kînnen mehrere Schalter auch
auf einen Rutsch angegeben werden, wie z.B im folgenden Beispiel:

 as test*.asm firstprog -cl /i c:\as\8051\include

Es  werden alle Dateien TEST*.ASM sowie die Datei FIRSTPROG.ASM assemb-
liert,  wobei fÅr alle Dateien Listings  auf der Konsole ausgegeben und
Sharefiles  im C-Format erzeugt werden.  Nach Includes soll der Assemb-
ler zusÑtzlich im Verzeichnis  C:\AS\8051\INCLUDE  suchen.

Dieses  Beispiel zeigt nebenbei, da·  AS als Defaultendung fÅr Quellda-
teien ASM annimmt.

Etwas  Vorsicht ist bei Schaltern  angebracht, die ein optionales Argu-
ment  haben: Folgt  auf einen  solchen Schalter  ohne Argument  ein Da-
teiname,  so versucht AS, diesen als  Argument zu verwerten, was natur-
gemÑ· schief geht:

 as -g test.asm

Die  Lîsung wÑre in  diesem Fall, die  -g-Option ans Ende der Kommando-
zeile zu setzen oder ein explizites MAP-Argument zu spezifizieren.

Neben  der Angabe in der  Kommandozeile kînnen dauernd benîtigte Optio-
nen  in der Environment-Variablen  ASCMD abgelegt werden.  Wer z.B. im-
mer  Listdateien haben  mîchte und  ein festes  Includeverzeichnis hat,
kann sich mit dem Befehl

 set ASCMD=-L -i c:\as\8051\include

eine  Menge Tipparbeit  ersparen. Da  die Environment-Optionen  vor der
Kommandozeile  abgearbeitet werden, kînnen Optionen in der Kommandozei-
le widersprechende im Environment Åbersteuern.

Bei  sehr langen Pfaden kann es  jedoch auch in der ASCMD-Variablen eng
werden.  FÅr solche  FÑlle kann  auf eine  sog. Key-  Datei ausgewichen
werden,  in  der  die  Optionen  genauso  wie in der Kommandozeile oder
ASCMD-Variablen  abgelegt werden  kînnen, nur  da· diese  Datei mehrere
Zeilen  mit jeweils maximal 255 Zeichen enthalten darf. Wichtig ist da-
bei,  da·  bei  Optionen,  die  ein Argument benîtigen, sowohl Schalter
als  auch Argument  in einer  Zeile stehen  mÅssen. Der  Name der Datei
wird  AS  dadurch  mitgeteilt,  da·  er mit einem vorangestellten Klam-
meraffen in der ASCMD-Variablen abgelegt wird, z.B.

 set ASCMD=@c:\as\as.key

Um  Optionen in der ASCMD-Variablen  (oder der Key-Datei) wieder aufzu-
heben,  kann die  Option mit  einem vorangestellten  Pluszeichen wieder
aufgehoben  werden. Soll in einem Einzelfall z.B. doch kein Listing er-
zeugt werden, so kann es mit

 as +L <Datei>

wieder  aufgehoben werden.  NatÅrlich ist  es nicht  ganz logisch, eine
Option mit einem Pluszeichen zu negieren...UNIX soit qui mal y pense.

Referenzen   auf  eine  Key-Datei  kînnen  nicht  nur  von  der  ASCMD-
Variablen  aus  erfolgen,  sondern  auch  direkt  von der Kommandozeile
aus,  indem man analog  zur ASCMD-Variablen dem  Dateinamen einen Klam-
meraffen voranstellt:

 as @<Datei> ....

Die  in einem solchen  Fall aus dem  Key-File gelesenen Optionen werden
so  eingearbeitet, als hÑtten sie anstelle  dieser Referenz in der Kom-
mandozeile  gestanden - es  ist also nicht  wie bei der ASCMD-Variablen
so,  da· sie vor allen anderen Kommandozeilenoptionen abgearbeitet wer-
den wÅrden.

Das  Referenzieren eines Key-Files von  einem Key-File selber ist nicht
erlaubt und wird von AS mit einer Fehlermeldung quittiert.

FÅr  den Fall, da· Sie  AS von einem anderen  Programm oder einer Shell
aufrufen  wollen und diese Shell nur  Klein- oder Gro·buchstaben in der
Kommandozeile  Åbergeben  will,  existiert  folgendes  Workaround: Wird
vor  den Buchstaben der  Option eine Tilde  gesetzt, so werden die fol-
genden  Buchstaben immer als  Kleinbuchstaben interpretiert. Analog er-
zwingt  ein Lattenzaun die Interpretation  als Gro·buchstaben. Es erge-
ben sich z.B. folgende Transformationen:

    /~I --> /i
    -#u --> -U


AbhÑngig  vom Ablauf der Assemblierung  endet der Assembler mit folgen-
den Returncodes:

  0 fehlerfreier Ablauf, hîchstens Warnungen aufgetreten
  1 Der  Assembler hat  nur die  Aufrufparameter ausgegeben  und endete
    danach sofort.
  2 Es  sind Fehler  bei der  Assemblierung aufgetreten,  es wurde kein
    Codefile erzeugt.
  3 Es  trat ein fataler  Fehler wÑhrend des  Ablaufes auf, der zum so-
    fortigen Abbruch gefÅhrt hat.
  4 Bereits  wÑhrend des Starts des Assemblers ist ein Fehler aufgetre-
    ten.  Dies kann ein Parameterfehler  oder eine fehlerhafte Overlay-
    Datei sein.
255 Bei  der  Initialisierung  ist  irgendein interner Fehler aufgetre-
    ten,  der auf keinen Fall  auftreten sollte...neu booten, noch ein-
    mal  probieren, und bei Reproduzierbarkeit  mit mir Verbindung auf-
    nehmen!


ZusÑtzlich  endet jede Assemblierung einer Datei mit einer kleinen Sta-
tistik,  die Fehlerzahlen,  Laufzeit, Anzahl  der DurchlÑufe und freien
Speicher  ausgibt.  Bei  eingeschaltetem  Assembler-Listing  wird diese
Statistik zusÑtzlich auch in das Listing geschrieben.

OS/2  erweitert wie  Unix das  Datensegment einer  Anwendung erst dann,   OS/2
wenn sie wirklich mehr Speicher anfordert. Eine Angabe wie

    511 KByte verfÅgbarer Restspeicher

bedeutet  also  nicht  einen  nahenden Systemabsturz wegen Speicherman-
gel,  sondern stellt nur  den Abstand zu  der Grenze dar,  bei der OS/2
einfach ein paar mehr Kohlen in den Ofen schaufelt...

Da  es  unter  C  auf  verschiedenen  Betriebssystemen keine kompatible   UNIX
Mîglichkeit  gibt, den noch  verfÅgbaren Speicher bzw.  Stack zu ermit-
teln, fehlen bei der C-Version diese beiden Angaben ganz.


        2.5. Format der Eingabedateien
        ------------------------------

Wie  die meisten Assembler auch erwartet AS genau einen Befehl pro Zei-
le  (Leerzeilen  sind  natÅrlich  auch  zugelassen).  Die Zeilen dÅrfen
nicht  lÑnger als  255 Zeichen  werden, darÅber  hinaus gehende Zeichen
werden abgeschnitten.

Eine einzelne Zeile hat folgendes Format:

[Label[:]]<Befehl>[.Attribut] [Parameter[,Parameter..]] [;Kommentar]

Eine  Zeile darf dabei auch Åber  mehrere Zeilen in der Quelldatei ver-
teilt  sein, Folgezeichen (\) verketten diese  Teile dann zu einer ein-
zigen  Zeile.  Zu  beachten  ist  allerdings, da· aufgrund der internen
Pufferstruktur  die Gesamtzeile  nicht 256  Zeichen Åberschreiten darf.
Zeilenangaben  in Fehlermeldungen  beziehen sich  immer auf  die letzte
Zeile einer solchen zusammengesetzten Zeile.

Der  Doppelpunkt nach  dem Label  ist optional,  falls das Label in der
ersten  Spalte beginnt (woraus folgt, da·  der Befehl niemals in Spalte
1  beginnen darf). Man  mu· ihn aber  setzen, falls das  Label nicht in
der  ersten Spalte beginnt, damit AS  es von einem Befehl unterscheiden
kann.  In letzterem Fall mu· Åbrigens  zwischen Doppelpunkt und dem Be-
fehl  mindestens ein  Leerzeichen stehen,  falls der eingestellte Ziel-
prozessor  zu denjenigen gehîrt,  bei denen das  Attribut auch eine mit
einem  Doppelpunkt  abgetrennte  Formatangabe  sein  darf. Dieser Knopf
ist  aus  EindeutigkeitsgrÅnden  nîtig,  da  sonst keine Unterscheidung
zwischen Befehl mit Format und Label mit Befehl mîglich wÑre.

Einige  Signalprozessorreihen von  Texas Instruments  verwenden den fÅr
das  Label  vorgesehenen  Platz  wahlweise  auch fÅr einen Doppelstrich
(||),  der die  parallele AusfÅhrung  mit der vorangehenden Instruktion
anzeigt.  Wenn diese  beiden Instruktionen  auf Maschinenebene in einem
einzigen  Wort  vereinigt  werden  (C3x),  macht ein zusÑtzliches Label
vor  der zweiten  Anweisung natÅrlich  keinen Sinn  und ist  auch nicht
vorgesehen.  Anders sieht  es beim  C6x mit  seinen Instruktionspaketen
variabler  LÑnge aus: Wer dort  (unschînerweise...) mitten in ein Paket
hineinspringen  will, mu· das Label dafÅr in eine Extrazeile davor set-
zen  (das gleiche gilt  Åbrigens auch fÅr  Bedingungen, die aber zusam-
men mit dem Doppelstrich in einer Zeile stehen dÅrfen).

Das  Attribut wird von einer Reihe  von Prozessoren benutzt, um Spezia-
lisierungen  oder Kodierungsvarianten eines  bestimmten Befehls zu spe-
zifizieren.  Die bekannteste Nutzung  des Attributs ist  die Angabe der
Operandengrî·e, wie z. B. bei der 680x0-Familie (Tabelle 2.6).

 +----------+--------------------------------+---------------------+
 | Attribut | arithmetisch-logischer Befehl  | Sprungbefehl        |
 +----------+--------------------------------+---------------------+
 +----------+--------------------------------+---------------------+
 | B        | Byte (8 Bit)                   | ---------           |
 | W        | Wort (16 Bit)                  | ---------           |
 | L        | Langwort (32 Bit)              | 16-Bit-Displacement |
 | Q        | Vierfachwort (64 Bit)          | ---------           |
 | S        | Single Precision (32 Bit)      | 8-Bit-Displacement  |
 | D        | Double Precision (64 Bit)      | ---------           |
 | X        | Extended Precision (80/96 Bit) | 32-Bit-Displacement |
 | P        | Dezimalgleitkomma (80/96 Bit)  | ---------           |
 +----------+--------------------------------+---------------------+

Tabelle 2.6: Erlaubte Attribute (Beispiel 680x0)


Da  sich diese  Anleitung nicht  gleichzeitig als  Handbuch fÅr die von
AS  unterstÅtzten  Prozessorfamilien  versteht,  ist  dies  leider auch
nicht  der richtige  Platz, um  hier alle  mîglichen Attribute fÅr alle
unterstÅtzten  Familien aufzuzÑhlen.  Es sei  aber angemerkt,  da· i.a.
nicht  alle Befehle alle Attribute  zulassen, andererseits das Fortlas-
sen  eines  Attributs  meist  zur  Verwendung  der  fÅr  diese  Familie
,,natÅrlichen''  Operandengrî·e  fÅhrt.  Zum  genaueren  Studium greife
man  auf  ein  Programmierhandbuch  fÅr  die  jeweilige Familie zurÅck,
z.B. in [1] fÅr die 68000er.

Bei  TLCS-9000, H8/500 und M16(C) dient  das Attribut sowohl der Angabe
der  Operandengrî·e, falls  diese nicht  durch die  Operanden klar sein
sollte,  als auch der  des zu verwendenden  Befehlsformates. Dieses mu·
durch  einen Doppelpunkt  von der  Operandengrî·e getrennt werden, z.B.
so:

    add.w:g   rw10,rw8

Was  dieses Beispiel nicht  zeigt, ist, da·  die Formatangabe auch ohne
Operandengrî·e  geschrieben werden  darf. Steht  demgegenÅber eine Ope-
randengrî·e  ohne Formatangabe,  verwendet AS  automatisch das kÅrzeste
Format.  Die erlaubten Befehlsformate und  Operandengrî·en sind vom Ma-
schinenbefehl  abhÑngig  und  kînnen  z.B.  [109], [24], [44] bzw. [45]
entnommen werden.

Die  Zahl der Befehlsparameter ist abhÑngig vom Befehl und kann prinzi-
piell  zwischen 0 und  20 liegen. Die  Trennung der Parameter voneinan-
der  erfolgt  ausschlie·lich  durch  Kommas (Ausnahme: DSP56xxx, dessen
parallele  Datentransfers durch Leerzeichen  getrennt werden), wobei in
Klammern  oder Hochkommas eingeschlossene Kommas natÅrlich nicht beach-
tet werden.

Anstelle  eines Kommentars  am Ende  kann die  Zeile auch nur aus einem
Kommentar bestehen, wenn er in der ersten Spalte beginnt.

Bei  den Leerzeichen  zur Trennung  einzelnen Komponenten  darf es sich
genauso gut um Tabulatoren handeln.


        2.6. Format des Listings
        ------------------------

Das  von AS bei Angabe der Kommandozeilenoptionen l oder L erzeugte Li-
sting lÑ·t sich grob in folgende Teile gliedern:

  1 Wiedergabe des assemblierten Quellcodes;
  2 Symbolliste;
  3 Makroliste;
  4 Funktionsliste;
  5 Belegungsliste;
  6 Querverweisliste.

Letztere  beide werden nur erzeugt,  wenn sie durch zusÑtzliche Komman-
dozeilenoptionen angefordert wurden.

Im  ersten Teil listet AS den  kompletten Inhalt aller Quelldateien in-
klusive  des erzeugten Codes auf. Eine  Zeile in diesem Listing hat da-
bei folgende Form:

[<n>] <Zeile>/<Adresse> <Code> <Quelle>

Im  Feld n zeigt AS  die Include-Verschachtelungstiefe an. Die Hauptda-
tei  (die Datei, mit der die  Assemblierung begann), hat dabei die Tie-
fe  0, von dort aus  eingebundene Dateien haben Tiefe  1 usw. Die Tiefe
0 wird dabei nicht angezeigt.

Im  Feld Zeile  wird die  Zeilennummer bezogen  auf die jeweilige Datei
ausgegeben.  Die erste Zeile einer Datei hat dabei Nummer 1. Die Adres-
se,  an der  der fÅr  diese Zeile  erzeugte Code  abgelegt wurde, folgt
hinter dem SchrÑgstrich im Feld Adresse.

Der  erzeugte Code selber steht dahinter  im Feld Code in hexadezimaler
Schreibweise.  Je nach  Prozessortyp und  aktuellem Segment  kînnen die
Werte  entweder als Bytes oder  16/32-Bit-Worte formatiert sein. Sollte
mehr  Code erzeugt worden  sein, als in  das Feld hineinpa·t, so werden
im  Anschlu· an die  Zeile weitere Zeilen  erzeugt, in denen nur dieses
Feld belegt ist.

Im  Feld Quelle schlu·endlich wird die  Zeile aus der Quelldatei in ih-
rer Originalform ausgegeben.

Die  Symboltabelle ist so ausgelegt, da·  sie nach Mîglichkeit immer in
80  Spalten  dargestellt  werden  kann.  FÅr Symbole ,,normaler LÑnge''
wird  eine zweispaltige  Ausgabe gewÑhlt.  Sollten einzelne Symbole mit
ihrem  Wert die Grenze von 40  Spalten Åberschreiten, werden sie in ei-
ner  einzelnen Zeile ausgegeben. Die  Ausgabe erfolgt in alphabetischer
Reihenfolge.  Symbole,  die  zwar  definiert,  aber nie benutzt wurden,
werden mit einem vorangestellten Stern (*) gekennzeichnet.

Die  bisher genannten Teile sowie  die Auflistung aller definierten Ma-
kros  / Funktionen lassen  sich selektiv aus  dem Gesamtlisting ein-und
ausblenden,     und    zwar    mit    dem    bereits    erwÑhnten    t-
Kommandozeilenschalter.  Intern existiert  in AS  ein Byte, dessen Bits
reprÑsentieren,  welche Teile  ausgegeben werden  sollen. Die Zuordnung
von Bits zu den Teilen ist in Tabelle 2.7 aufgelistet.


               +-----+-------------------------------+
               | Bit | Teil                          |
               +-----+-------------------------------+
               +-----+-------------------------------+
               | 0   | Quelldatei(en)+erzeugter Code |
               | 1   | Symboltabelle                 |
               | 2   | Makroliste                    |
               | 3   | Funktionsliste                |
               | 4   | Zeilennumerierung             |
               | 5   | Registersymboltabelle         |
               | 7   | Zeichentabellenliste          |
               +-----+-------------------------------+

Tabelle 2.7: Zuordnung der Bits zu den Listingkomponenten

DefaultmÑ·ig  sind alle Bits  auf 1 gesetzt,  bei Verwendung des Schal-
ters

-t <Maske>

werden  die in <Maske> gesetzten Bits gelîscht, so da· die entsprechen-
den  Listing-Teile  unterdrÅckt  werden.  Analog  lassen sich mit einem
Pluszeichen  einzelne  Teile  wieder  einschalten,  falls man es in der
ASCMD-Variablen  Åbertrieben hat...will man  z.B. nur die Symboltabelle
haben, so reicht

-t 2  .

In  der Belegungsliste  werden fÅr  jedes Segment  einzeln die belegten
Bereiche  hexadezimal ausgegeben. Handelt es  sich bei einem Bereich um
eine  einzige Adresse, wird  nur diese ausgegeben,  ansonsten erste und
letzte Adresse.

In  der Querverweisliste wird fÅr jedes definierte Symbol in alphabeti-
scher Reihenfolge eine Ausgabe folgender Form erzeugt:

Symbol <Symbolname> (=<Wert>,<Datei>/<Zeile>):
 Datei <Datei 1>:
 <n1>[(m1)]  ..... <nk>[(mk)]
 .
 .
 Datei <Datei l>:
 <n1>[(m1)]  ..... <nk>[(mk)]

FÅr  jedes Symbol  wird aufgelistet,  in welchen  Dateien es in welchen
Zeilen  angesprochen wurde. Sollte ein  Symbol mehrmals in der gleichen
Zeile  benutzt worden sein, so wird dies durch eine in Klammern gesetz-
te  Anzahl hinter der  Zeilennummer angedeutet. Sollte  ein Symbol nie-
mals  benutzt worden sein,  erscheint es auch  nicht in der Liste; ent-
sprechend  erscheint eine Datei  auch Åberhaupt nicht  in der Liste ei-
nes  Symbols, falls es  in der entsprechenden  Datei nicht referenziert
wurde.

ACHTUNG!  AS kann dieses Listing nur  dann korrekt aufs Papier bringen,
wenn  man ihm vorher die LÑnge  und Breite des Ausgabemediums mit Hilfe
des  PAGE-Befehls  (siehe  dort)  mitgeteilt  hat!  Der voreingestellte
Default sind 60 Zeilen und eine unbegrenzte Zeilenbreite.


        2.7. Symbolkonventionen
        -----------------------

Symbole  dÅrfen zwar (wie in der  Einleitung bereits angedeutet) bis zu
255  Zeichen lang  werden und  werden auch  auf der ganzen LÑnge unter-
schieden, die Symbolnamen mÅssen aber einigen Konventionen genÅgen:

Symbolnamen  dÅrfen  aus  einer  beliebigen Kombination von Buchstaben,
Ziffern,  Unterstrichen und  Punkten bestehen,  wobei das erste Zeichen
keine  Ziffer sein darf. Der Punkt wurde nur zugelassen, um der MCS-51-
Notation  von Registerbits  zu genÅgen,  und sollte  mîglichst nicht in
eigenen  Symbolnamen verwendet werden.  Zur Segmentierung von Symbolna-
men  sollte auf jeden Fall der  Unterstrich und nicht der Punkt verwen-
det werden.

DefaultmÑ·ig  ist  AS  nicht  case-sensitiv,  es  ist also egal, ob man
Gro·-oder  Kleinbuchstaben verwendet.  Mittels des Kommandozeilenschal-
ters  U lÑ·t  sich AS  jedoch in  einen Modus  umschalten, in dem Gro·-
und  Kleinschreibung  unterschieden  wird.  Ob  AS  umgeschaltet wurde,
kann  mit  dem  vordefinierten  Symbol  CASESENSITIVE ermittelt werden:
TRUE bedeutet Unterscheidung, FALSE keine.

Tabelle 2.8 zeigt die wichtigsten, von AS vordefinierten Symbole.

  +---------------+------------------------------------------------+
  | Name          | Bedeutung                                      |
  +---------------+------------------------------------------------+
  +---------------+------------------------------------------------+
  | TRUE          | logisch ,,wahr''                               |
  | FALSE         | logisch ,,falsch''                             |
  | CONSTPI       | Kreiszahl Pi (3.1415.....)                     |
  | VERSION       | Version von AS in BCD-Kodierung,               |
  |               | z.B. 1331 hex fÅr Version 1.33p1               |
  | ARCHITECTURE  | Zielplattform, fÅr die AS Åbersetzt wurde,     |
  |               | in der Form Prozesor-Hersteller-Betriebssystem |
  | DATE          | Datum und                                      |
  | TIME          | Zeitpunkt der Assemblierung (Beginn)           |
  | MOMCPU        | momentan gesetzte Ziel-CPU                     |
  | MOMCPUNAME    | dito, nur als voll ausgeschriebener String     |
  | MOMFILE       | augenblickliche Quelldatei                     |
  | MOMLINE       | Zeilennummer in Quelldatei                     |
  | MOMPASS       | Nummer das laufenden Durchgangs                |
  | MOMSECTION    | Name der aktuellen Sektion oder                |
  |               | Leerstring                                     |
  | MOMSEGMENT    | Name des mit SEGMENT gewÑhlten                 |
  |               | Adre·raumes                                    |
  |  *, $ bzw. PC | mom. ProgrammzÑhler                            |
  +---------------+------------------------------------------------+

Tabelle 2.8: Vordefinierte Symbole

VORSICHT!  WÑhrend es im case-insensitiven  Modus egal ist, mit welcher
Kombination  von  Gro·-  und  Kleinbuchstaben man vordefinierte Symbole
anspricht,  mu· man sich im case-sensitiven Modus exakt an die oben an-
gegebene Schreibweise (nur Gro·buchstaben) halten!

ZusÑtzlich  definieren einige Pseudobefehle noch  Symbole, die eine Ab-
frage  des damit  momentan eingestellten  Wertes ermîglichen. Deren Be-
schreibung findet sich bei den zugehîrigen Befehlen.

Ein  etwas  verstecktes  (und  mit  Vorsicht zu nutzendes) Feature ist,
Symbolnamen  aus String-Variablen zusammenzubauen,  indem man den Namen
des  Strings mit geschweiften  Klammern in den  Symbolnamen einbaut. So
kann  man z.B. den Namen eines  Symbols anhand des Wertes eines anderen
Symbols festlegen:

cnt		set	cnt+1
temp		equ	"\{CNT}"
		jnz	skip{temp}
		.
		.
skip{temp}:	nop

ACHTUNG!  Der Programmierer  ist selber  dafÅr verantwortlich, da· sich
dabei gÅltige Symbolnamen ergeben!

Eine  vollstÑndige Auflistung aller von AS verwendeten Symbolnamen fin-
det sich in Anhang E.

Neben  seinem Wert besitzt  auch jedes Symbol  eine Markierung, zu wel-
chen  Segment es gehîrt.  In erster Linie  wird eine solche Unterschei-
dung  bei  Prozessoren  benîtigt,  die  mehrere Adre·rÑume besitzen. AS
kann  mit dieser Zusatzinformation  bei Zugriffen Åber  ein Symbol war-
nen,  wenn  ein  fÅr  diesen  Adre·raum  ungeeigneter  Befehl verwendet
wird.  Ein  Segmentattribut  wird  einem  Symol  automatisch angehÑngt,
wenn  es als  Label oder  mit einem  Spezialbefehl (z.B. BIT) definiert
wird;  ein mit dem ,,Universalbefehl''  SET oder EQU definiertes Symbol
ist  jedoch ,,typenlos'', d.h. seine  Verwendung wird niemals Warnungen
auslîsen.  Das Segmentattribut  eines Symbols  kann mit der eingebauten
Funktion SYMTYPE abgefragt werden, etwa so:

Label:
        .
        .
Attr    equ     symtype(Label)  ; ergibt 1

Den  einzelnen Segmenttypen sind die  in Tabelle 2.9 aufgelisteten Num-
mern  zugeordnet. Die aus der Ordnung normaler Symbole etwas herausfal-
lenden  Registersymbole sind nÑher in Abschnitt 2.11 erlÑutert. Mit ei-
nem  undefinierten Symbol als Argument  liefert die SYMTYPE-Funktion -1
als Ergebnis.

                 +------------------+--------------+
                 | Segment          | RÅckgabewert |
                 +------------------+--------------+
                 | <keines>         |       0      |
                 | CODE             |       1      |
                 | DATA             |       2      |
                 | IDATA            |       3      |
                 | XDATA            |       4      |
                 | YDATA            |       5      |
                 | BITDATA          |       6      |
                 | IO               |       7      |
                 | REG              |       8      |
                 | ROMDATA          |       9      |
                 | <Registersymbol> |      128     |
                 +------------------+--------------+

Tabelle 2.9: RÅckgabewerte der SYMTYPE-Funktion



        2.8. TemporÑre Symbole
        ----------------------

Besonders  bei  Programmen  mit  vielen  aufeinanderfolgenden Schleifen
oder  IF-artigen  Strukturen  steht  man  immer wieder vor dem Problem,
sich  stÑndig neue  Namen fÅr  Labels ausdenken  zu mÅssen.  Dabei wei·
man  an sich genau, da·  man dieses Label nie  wieder brauchen wird und
am  liebsten  in  irgendeiner  Weise  'verwerfen' mîchte. Eine einfache
Lîsung,  wenn man nicht gleich  den gro·en Hammer des Sektionskonzeptes
(siehe  Kapitel 3.8) schwingen mîchte,  sind temporÑre Symbole, die so-
lange  ihre GÅltigkeit  behalten, bis  ein neues, nicht-temporÑres Sym-
bol  definiert wird. Andere Assembler  bieten einen Ñhnlichen Mechanis-
mus  an, der dort unter dem  Stichwort 'lokale Symbole' lÑuft, zur bes-
seren  Abgrenzung gegen  das Sektionskonzept  mîchte ich  aber beim Be-
griff  'temporÑre Symbole' bleiben. AS  kennt drei unterschiedliche Ty-
pen  von temporÑren Symbolen, um jedem 'Umsteiger' ein Konzept anzubie-
ten,  das den Umstieg so einfach  wie mîglich macht. Leider kocht quasi
jeder  Assembler bei diesem Thema sein  eigenes SÅppchen, so daﬂ es nur
in AusnahmefÑllen eine 1:1-Lîsung fÅr existierenden Code geben wird:


        2.8.1.  TemporÑre Symbole mit Namen
        - - - - - - - - - - - - - - - - - -

Ein  Symbol, dessen Name  mit zwei Dollarzeichen  beginnt (dies ist we-
der  fÅr normale Symbole noch  Konstanten zulÑssig), ist ein temporÑres
Symbol  mit Namen. AS fÅhrt intern einen  ZÑhler mit, der zu Beginn der
Assemblierung  auf  Null  gesetzt  wird  und bei jeder Definition eines
nicht-temporÑren  Symbols inkrementiert wird.  Wird ein temporÑres Sym-
bol  definiert oder referenziert,  so werden die  beiden fÅhrenden Dol-
larzeichen  gestrichen  und  der  momentane  Stand des ZÑhlers wird an-
gehÑngt.  Auf diese Weise erhÑlt  man mit jedem nicht-temporÑren Symbol
sozusagen  die Symbolnamen zurÅck  - man kommt  an die Symbole vor die-
ser  Definition aber  auch nicht  mehr heran!  TemporÑre Symbole bieten
sich  daher besonders fÅr den  Einsatz in kleinen Anweisungsblîcken an,
typischerweise  etwa ein Dutzend Befehle, auf  keinen Fall mehr als ei-
ne Bildschirmseite, sonst kommt man leicht durcheinander...

Hier ein kleines Beispiel:

$$loop: nop
        dbra    d0,$$loop

split:

$$loop: nop
        dbra    d0,$$loop

WÑre  das zwischen  den Schleifen  liegende nicht-temporÑre Label nicht
vorhanden,  gÑbe es  natÅrlich eine  Fehlermeldung wegen  eines doppelt
definierten Symbols.

Namenlose TemporÑre Symbole

FÅr  all jene, denen temporÑre Symbole  mit Namen noch immer zu kompli-
ziert  sind, gibt es  eine noch einfachere  Variante: Setzt man als La-
bel  ein einfaches Plus- oder Minuszeichen,  so werden diese in die Na-
men  __forwnn bzw.  __backmm umgesetzt,  wobei nn  bzw. mm  von Null an
laufende  ZÑhler sind. Referenziert werden  diese Symbole Åber die Son-
derwerte  -  --  ---  bzw.  +  ++  +++,  womit  sich  die  drei letzten
'Minussymbole'  bzw die drei  nÑchsten 'Plussymbole' referenzieren las-
sen.  Welche Variante man benutzt, hÑngt also davon ab, ob man ein Sym-
bol vorwÑrts oder rÅckwÑrts referenzieren will.

Bei  der  Definition  namenloser  temporÑrer  Symbole gibt es neben dem
Plus-  und  Minuszeichen  noch  eine  dritte  Variante,  nÑmlich  einen
SchrÑgstrich  (/). Ein so definiertes  temporÑres Symbol kann gleicher-
ma·en  vorwÑrts wie rÅckwÑrts referenziert werden;  d. h. je nach Refe-
renzierung wird es wie ein Minus oder Plus behandelt.

Namenlose  temporÑre  Symbole  finden  ihre  Anwendung Åblicherweise in
Konstruktionen,  die auf eine Bildschirmseite  passen, wie das bedingte
öberspringen  von ein  paar Maschinenbefehlen  oder kleinen Schleifen -
ansonsten  wÅrde die Sache zu unÅbersichtlich  werden (das ist aber nur
ein  gut gemeinter Rat...).  Ein Beispiel dafÅr  ist das folgende StÅck
Code, zur Abwechslung mal als 65xx-Code:

        cpu     6502

-       ldx     #00
-       dex
        bne     -            ; springe zu 'dex'
        lda     RealSymbol
        beq     +            ; springe zu 'bne --'
        jsr     SomeRtn
        iny
+       bne     --           ; springe zu 'ldx #00'

SomeRtn:
        rts

RealSymbol:
        dfs     1

  	inc	ptr
   	bne 	+      	    ; springe zu 'tax'
   	inc 	ptr+1
+ 	tax

 	bpl 	++     	    ; springe zu 'dex'
   	beq 	+      	    ; springe vorwaerts zu 'rts'
   	lda 	#0
/  	rts            	    ; Schraegstrich = Wildcard
+ 	dex
   	beq 	-           ; springe rueckwaerts zu 'rts'

ptr:	dfs	2



        2.8.2. Zusammengesetzte temporÑre Symbole
        - - - - - - - - - - - - - - - - - - - - -

Dies  ist vielleicht der  Typ von temporÑren  Symbolen, der dem Konzept
von  lokalen Symbolen und  Sektionen am nÑchsten  kommt. Wann immer der
Name  eines  Symboles  mit  einem  Punkt  (.)  anf‰ngt, wird das Symbol
nicht  mit  diesem  Namen  in  der  Symboltabelle abgelegt. Stattdessen
wird  der  Name  des  zuletzt  definierten Symbols ohne vorangestellten
Punkt  davorgehÑngt. Auf  diese Weise  nehmen Sybole,  deren Name nicht
mit  einem  Punkt  anfÑngt,  quasi  die Rolle von 'Bereichsgrenzen' ein
und  Symbole, deren Name  mit einem Punkt  anfÑngt, kînnen in jedem Be-
reich  neu verwendet werden. Sehen wir  uns das folgende kurze Beispiel
an:

proc1:                    ; nicht-tempor"ares Symbol 'proc1'

.loop   moveq   #20,d0    ; definiert in Wirklichkeit 'proc1.loop'
        dbra    d0,.loop
        rts

proc2:                    ; nicht-tempor"ares Symbol 'proc2'

.loop   moveq   #10,d1    ; definiert in Wirklichkeit 'proc2.loop'
        jsr     proc1
        dbra    d1,.loop
        rts

Man  beachte, da· es weiterhin mîglich  ist, auf alle temporÑren Symbo-
le  zuzugreifen, auch wenn man sich  nicht im gleichen 'Bereich' befin-
det,  indem man einfach  den zusammengesetzten Namen  benutzt (wie z.B.
'proc2.loop' im voranstehenden Beispiel).

Zusammengesetzte  Symbole lassen sich  prinzipiell mit Sektionen kombi-
nieren  und kînnen so auch zu  lokalen Symbolen werden. Man beachte al-
lerdings,  da·  das  zuletzt  definierte,  nicht temporÑre Symbol nicht
pro  Sektion gespeichert wird, sondern  lediglich global. Das kann sich
aber  auch irgendwann  einmal Ñndern,  man sollte  sich also  nicht auf
das augenblickliche Verhalten verlassen.


        2.9. FormelausdrÅcke
        --------------------

An  den meisten  Stellen, an  denen der  Assembler Zahlenangaben erwar-
tet,  kînnen nicht nur einfache  Symbole oder Konstanten angegeben wer-
den,  sondern ganze FormelausdrÅcke. Bei den Komponenten der Formelaus-
drÅcke  kann es sich  sowohl um ein  einzelnes Symbol als  auch um eine
Konstante  handeln. Konstanten  dÅrfen entweder  Integer-, Gleitkomma-,
oder Stringkonstanten sein.


        2.9.1.  Integerkonstanten
        - - - - - - - - - - - - -

Integerkonstanten  bezeichnen ganze Zahlen. Sie dÅrfen entweder als ei-
ne  Folge von Ziffern  oder als eine  Reihe von in einfachen Hochkommas
eingeschlossenen  Zeichen geschrieben  werden. Werden  sie als Ziffern-
folgen  geschrieben, so  kann dies  in verschiedenen Zahlensystemen er-
folgen,  deren  Kennzeichnung  von  verwendeten  Zielprozessor  abhÑngt
(Tabelle 2.10).


+-------------+---------------------+----------------------+--------------------+
|             |     Intel-Modus     |    Motorola-Modus    |       C-Modus      |
|             |    (Intel, Zilog,   | (Rockwell, Motorola, |      (PowerPC,     |
|             |   Thomson, Texas,   |  Microchip, Thomson, |       AMD29K,      |
|             |    Toshiba, NEC,    |       Hitachi)       |      National,     |
|             |  Siemens, Philips,  |                      |      Symbios,      |
|             | Fujitsu, Fairchild, |                      |       Atmel)       |
|             |      Intersil)      |                      |                    |
+-------------+---------------------+----------------------+--------------------+
+-------------+---------------------+----------------------+--------------------+
| dezimal     |        direkt       |        direkt        |       direkt       |
| hexadezimal |   nachgestelltes H  |   vorangestelltes $  | vorangestelltes 0x |
| binÑr       |   nachgestelltes B  |   vorangestelltes %  | vorangestelltes 0b |
| oktal       |   nachgestelltes O  |   vorangestelltes @  |  vorangestellte 0  |
|             |   nachgestelltes Q  |                      |                    |
+-------------+---------------------+----------------------+--------------------+

Tabelle 2.10: mîgliche Zahlensysteme

Falls  das Zahlensystem nicht explizit durch vor-oder nachgestelle Zei-
chen  vorgegeben wird, nimmt AS die  Basis an, die mit dem RADIX-Befehl
vorgegeben  wurde  (der  Default  dieser  Einstellung ist wiederum 10).
Mit  diesem  Befehl  lassen  sich  auch ,,ungewîhnliche" Zahlensysteme,
d.h. andere als 2, 8, 10 oder 16 einstellen.

GÅltige  Ziffern sind die Zahlen  0 bis 9 sowie  die Buchstaben A bis Z
(Wert  10 bis 35) bis zur Basis  des Zahlensystems minus eins. Die Ver-
wendung  von Buchstaben in Integerkonstanten bringt allerdings auch ei-
nige  Mehrdeutigkeiten mit sich, da Symbolnamen ja auch Ketten aus Zah-
len  und Buchstaben sind:  Ein Symbolname darf  nicht mit einem Zeichen
von  0 bis  9 beginnen,  was bedeutet,  da· eine  Integerkonstante, die
nicht  durch ein  anderes Sonderzeichen  eindeutig als solche erkennbar
ist,  niemals mit einem Buchstaben beginnen  darf; notfalls mu· man ei-
ne  eigentlich  ÅberflÅssige  Null  voranstellen.  Der bekannteste Fall
ist  das Schreiben  von Hexadezimalkonstanten  im Intel-Modus:  Ist die
vorderste  Stelle  zwischen  A  und  F,  so hilft das hintangestellte H
Åberhaupt  nichts, es mu·  noch eine Null  davor (statt F0H also 0F0H).
Die  Motorola-oder C-Syntax, die  beide das Zahlensystem  am Anfang ei-
ner   Integerkonstante  kennzeichnen,  kennen   dieses  Problem  nicht.
(hihihi!).

Reichlich  heimtÅckisch ist auch, da· bei immer hîheren, mit RADIX ein-
gestellten  Zahlensystemen, die bei Intel- und C-Syntax benutzten Buch-
staben  zur Zahlensystemkennung  immer weiter  ,,aufgefressen'' werden;
so  kann man z.B.  nach RADIX 16  keine binÑren Konstanten mehr schrei-
ben,  und ab RADIX 18 in Intel-Syntax auch keine hexadezimalen Konstan-
ten mehr. Also VORSICHT!

Mit  Hilfe des RELAXED-Befehls (siehe  Abschnitt 3.9.6) kann die starre
Zuordnung  einer  Schreibweise  zu  einem Zielprozessor aufgehoben wer-
den,  so da·  man eine  beliebige Schreibweise  verwenden kann (auf Ko-
sten  der KompatibilitÑt zu Standard-Assemblern). DefaultmÑ·ig ist die-
se  Option  aber  ausgeschaltet.  Ebenfalls  mit dieser Option erîffnet
sich  eine weitere, vierte Schreibweise  fÅr Integerkonstanten, wie man
sie  bei  manchen  Fremdassemblern  antrifft:  Bei  dieser Schreibweise
wird  der eigentliche Wert in  Hochkommas geschrieben und das Zahlensy-
stem  ('x' oder 'h' fÅr  hexadezimal, 'o' fÅr oktal  und 'b' fÅr binÑr)
direkt  davor. Die Integer-Konstante 305419896  kann damit also folgen-
derma·en geschrieben werden:

 x'12345678'
 h'12345678'
 o'2215053170'
 b'00010010001101000101011001111000'

Diese  Schreibweise ist fÅr keine  Prozessorarchitektur der Default und
nur  im RELAXED-Modus erreichbar. Sie dient  in erster Linie der einfa-
cheren  Portierung von  Fremdquellen und  wird nicht  fÅr neu erstellte
Programme empfohlen.

Wie  bereits  angesprochen,  kînnen  Integer-Konstanten auch als ASCII-
Werte geschrieben werden, so entsprechen

'A'    == $41
'AB'   == $4142
'ABCD' == $41424344

Wichtig  ist, da· hier die  Zeichen in einfachen Hochkommas geschrieben
werden,  um sie von den  weiter unten beschriebenen Stringkonstanten zu
unterscheiden.


        2.9.2. Gleitkommakonstanten
        - - - - - - - - - - - - - -

Gleitkommazahlen  werden in  der Åblichen  halblogarithmischen Schreib-
weise geschrieben, die in der allgemeinsten Form

 [-]<Vorkommastellen>[.Nachkommastellen][E[-]Exponent]

lautet.  ACHTUNG! Der Assembler versucht  eine Konstante zuerst als In-
tegerkonstante  zu  verstehen  und  macht  erst  dann einen Versuch mit
Gleitkomma,  falls  dies  gescheitert  ist.  Will man aus irgendwelchen
GrÅnden  die Auswertung als Gleitkommazahl  erzwingen, so kann man dies
durch Dummy-Nachkommastellen erreichen, z.B. 2.0 anstelle 2.


        2.9.3. Stringkonstanten
        - - - - - - - - - - - -

Stringkonstanten  mÅssen in  doppelte Hochkommas  (um sie  von den oben
beschrieben  ASCII-Integers  zu  unterscheiden)  eingeschlossen werden.
Um  nun aber auch  GÑnsefÅ·chen und Sonderzeichen  ohne Verrenkungen in
String-Konstanten    einbauen   zu   kînnen,    wurde   ein   ,,Escape-
Mechanismus''  eingebaut, der  Programmierer(inne)n aus  C bekannt vor-
kommen dÅrfte:

Schreibt  man einen Backslash  mit einer maximal  dreiziffrigen Zahl im
String,  so versteht  der Assembler  dies als  Zeichen mit dem entspre-
chenden  dezimalen ASCII-Wert. Alternativ kann  der Zahlenwert auch he-
xadezimal  oder oktal mit  einem vorangestellten x  oder einer vorange-
stellten  0 geschrieben werden. FÅr die hexadezimale Schreibweise redu-
ziert  sich  die  Maximalanzahl  von  Stellen  auf  2. So kann man z.B.
mit\3  ein ETX-Zeichen definieren. Vorsicht  allerdings mit der Defini-
tion  von  NUL-Zeichen!  Da  die  C-Version  von AS momentan intern zur   UNIX
Speicherung  von  String-Symbolen  C-Strings  benutzt  (die  durch NUL-
Zeichen  terminiert  werden),  sind  NUL-Zeichen  in  Strings  momentan
nicht portabel!

Einige  besonders  hÑufig  gebrauchte  Steuerzeichen  kann man auch mit
folgenden AbkÅrzungen erreichen:


     \b : Backspace    \a : Klingel      \e : Escape
     \t : Tabulator    \n : Zeilenvorschub \r : WagenrÅcklauf
     \\ : Backslash    \' oder \h : Hochkomma
     \" oder \i : GÑnsefÅ·chen


Die  Kennbuchstaben dÅrfen sowohl gro·  als auch klein geschrieben wer-
den.

öber  dieses Escape-Zeichen kînnen sogar  FormelausdrÅcke in den String
eingebaut  werden, wenn  sie in  geschweifte Klammern eingefa·t werden:
z.B. ergibt

    message "Wurzel aus 81 : \{sqrt(81)}"

die Ausgabe

    Wurzel aus 81 : 9

Der  Assembler wÑhlt anhand des  Formelergebnistyps die richtige Ausga-
beform,  zu vermeiden  sind lediglich  weitere Stringkonstanten im Aus-
druck,  da  der  Assembler  bei  der  Gro·-zu-Kleinbuchstabenumwandlung
sonst  durcheinanderkommt. Integer-AusdrÅcke  werden defaultmÑ·ig hexa-
dezimal  ausgegeben,  dies  lÑ·t  sich  jedoch  mit dem OUTRADIX-Befehl
Ñndern.

Bis  auf den Einbau von  FormelausdrÅcken ist dieser Escape-Mechanismus
auch in als ASCII definierten Integerkonstanten zulÑssig, z.B. so:

   move.b   #'\n',d0

Jedoch  hat  alles  seine  Grenzen,  weil der darÅberliegende Splitter,
der  die Zeile  in Opcode  und Parameter  zerlegt, nicht wei·, womit er
da eigentlich arbeitet, z.B. hier:

   move.l   #'\'abc',d0

Nach  dem dritten  Hochkomma findet  er das  Komma nicht  mehr, weil er
vermutet,  da· eine weitere Zeichenkonstante  beginnt, und eine Fehler-
meldung  Åber eine  falsche Parameterzahl  ist die  Folge. Abhilfe wÑre
z.B., \h anstelle \' zu schreiben.


        2.9.4.  Evaluierung
        - - - - - - - - - -

Die  Berechnung von im  Formelausdruck entstehenden Zwischenergebnissen
erfolgt  immer  mit  der  hîchsten  verfÅgbaren Wortbreite, d.h. 32 Bit
fÅr  Ganzzahlen,  80  Bit  fÅr  Gleitkommazahlen  und  255  Zeichen fÅr
Strings.  Eine eventuelle PrÅfung  auf WertebereichsÅberschreitung fin-
det erst am Endergebnis statt.

Die  portable C-Version  kann nur  mit 64-Bit-Gleitkommazahlen umgehen,   UNIX
ist  daher auf einen  Maximalwert von ca.  10 ^308 beschrÑnkt. Als Aus-
gleich  werden auf einigen  Plattformen Integers mit  64 Bit Breite be-
handelt.


        2.9.5. Operatoren
        - - - - - - - - -

Der  Assembler  stellt  zur  VerknÅpfung  die in Tabelle 2.11 genannten
Operanden zur VerfÅgung.

+-------+---------------------+-------+------+-------+--------+------+
|  Op.  | Funktion            | #Ops. |  Int | Float | String | Rang |
+-------+---------------------+-------+------+-------+--------+------+
+-------+---------------------+-------+------+-------+--------+------+
|   <>  | Ungleichheit        |   2   |  ja  |   ja  |   ja   |  14  |
|   >=  | grî·er o. gleich    |   2   |  ja  |   ja  |   ja   |  14  |
|   <=  | kleiner o. gleich   |   2   |  ja  |   ja  |   ja   |  14  |
|   <   | echt kleiner        |   2   |  ja  |   ja  |   ja   |  14  |
|   >   | echt grî·er         |   2   |  ja  |   ja  |   ja   |  14  |
|   =   | Gleichheit          |   2   |  ja  |   ja  |   ja   |  14  |
|   ==  | Alias fÅr =         |       |      |       |        |      |
|       |                     |       |      |       |        |      |
|   !!  | log. XOR            |   2   |  ja  |  nein |  nein  |  13  |
|   ||  | log. OR             |   2   |  ja  |  nein |  nein  |  12  |
|   &&  | log. AND            |   2   |  ja  |  nein |  nein  |  11  |
|   ~~  | log. NOT            |   1   |  ja  |  nein |  nein  |   2  |
|       |                     |       |      |       |        |      |
|   -   | Differenz           |   2   |  ja  |   ja  |  nein  |  10  |
|   +   | Summe               |   2   |  ja  |   ja  |   ja   |  10  |
|   #   | Modulodivision      |   2   |  ja  |  nein |  nein  |   9  |
|   /   | Quotient            |   2   | ja*) |   ja  |  nein  |   9  |
|    *  | Produkt             |   2   |  ja  |   ja  |  nein  |   9  |
|    ^  | Potenz              |   2   |  ja  |   ja  |  nein  |   8  |
|       |                     |       |      |       |        |      |
|   !   | binÑres XOR         |   2   |  ja  |  nein |  nein  |   7  |
|   |   | binÑres OR          |   2   |  ja  |  nein |  nein  |   6  |
|   &   | binÑres AND         |   2   |  ja  |  nein |  nein  |   5  |
|   ><  | Bitspiegelung       |   2   |  ja  |  nein |  nein  |   4  |
|   >>  | log. Rechtsschieben |   2   |  ja  |  nein |  nein  |   3  |
|   <<  | log. Linksschieben  |   2   |  ja  |  nein |  nein  |   3  |
|    ~  | binÑres NOT         |   1   |  ja  |  nein |  nein  |   1  |
+-------+---------------------+-------+------+-------+--------+------+
|                       *) Rest wird verworfen                       |
+-------+---------------------+-------+------+-------+--------+------+

Tabelle 2.11: in AS definierte Operatoren

Unter  ,,Rang'' ist dabei die PrioritÑt zu verstehen, die dieser Opera-
tor  bei  der  Teilung  eines  Ausdruckes  in  UnterausdrÅcke  hat, der
ranghîchste  Operator  wird  also  zuletzt ausgewertet. Die Reihenfolge
der Evaluierung lÑ·t sich durch Klammerung neu festlegen.

Die  Vergleichsoperatoren liefern  TRUE, falls  die Bedingung zutrifft,
und  FALSE falls  nicht. Vergleiche  betrachten Integerzahlen dabei als
32  Bit breit und vorzeichenbehaftet.  FÅr die logischen Operatoren ist
ein Ausdruck TRUE, falls er ungleich 0 ist, ansonsten FALSE.

Die  Bitspiegelung  ist  wohl  etwas  erklÑrungsbedÅrftig: Der Operator
spiegelt   die   untersten   Bits   im   ersten   Operanden,  lÑ·t  die
darÅberliegenden  Bits aber  unverÑndert. Die  Zahl der  zu spiegelnden
Bits ist der rechte Operand und darf zwischen 1 und 32 liegen.

Eine   keine  Fu·angel  beim  binÑren  Komplement:  Da  die  Berechnung
grundsÑtzlich  auf 32-  oder 64-Bit-Ebene  erfolgt, ergibt seine Anwen-
dung  auf z.B. 8-Bit-Masken Åblicherweise Werte, die durch voranstehen-
de  Einsen nicht  mehr im  entferntesten in  8-Bit-Zahlen hineinpassen.
Eine  binÑre UND-VerknÅpfung mit einer passenden Maske ist daher unver-
meidlich!


        2.9.6. Funktionen
        - - - - - - - - -

ZusÑtzlich  zu den Operatoren  definiert der Assembler  noch eine Reihe
in  erster Linie transzendenter  Funktionen mit Gleitkommaargument, die
Tabellen 2.12 und 2.13 auflisten.

+----------+---------------------+-------------------------+------------+
| Name     | Funktion            | Argument                | Ergebnis   |
+----------+---------------------+-------------------------+------------+
+----------+---------------------+-------------------------+------------+
| SQRT     | Quadratwurzel       | arg >= 0                | Gleitkomma |
|          |                     |                         |            |
| SIN      | Sinus               | arg in R                | Gleitkomma |
| COS      | Kosinus             | arg in R                | Gleitkomma |
| TAN      | Tangens             | arg <> (2*n+1)*(Pi)/(2) | Gleitkomma |
| COT      | Kotangens           | arg <> n*Pi             | Gleitkomma |
|          |                     |                         |            |
| ASIN     | inverser Sinus      | | arg | <= 1            | Gleitkomma |
| ACOS     | inverser Kosinus    | | arg | <= 1            | Gleitkomma |
| ATAN     | inverser Tangens    | arg in R                | Gleitkomma |
| ACOT     | inverser Kotangens  | arg in R                | Gleitkomma |
|          |                     |                         |            |
| EXP      | Exponentialfunktion | arg in R                | Gleitkomma |
| ALOG     | 10 hoch Argument    | arg in R                | Gleitkomma |
| ALD      | 2 hoch Argument     | arg in R                | Gleitkomma |
| SINH     | hyp. Sinus          | arg in R                | Gleitkomma |
| COSH     | hyp. Kosinus        | arg in R                | Gleitkomma |
| TANH     | hyp. Tangens        | arg in R                | Gleitkomma |
| COTH     | hyp. Kotangens      | arg <> 0                | Gleitkomma |
|          |                     |                         |            |
| LN       | nat. Logarithmus    | arg > 0                 | Gleitkomma |
| LOG      | dek. Logarithmus    | arg > 0                 | Gleitkomma |
| LD       | 2er Logarithmus     | arg > 0                 | Gleitkomma |
| ASINH    | inv. hyp. Sinus     | arg in R                | Gleitkomma |
| ACOSH    | inv. hyp. Kosinus   | arg >= 1                | Gleitkomma |
| ATANH    | inv. hyp. Tangens   | | arg | < 1             | Gleitkomma |
| ACOTH    | inv. hyp. Kotangens | | arg | > 1             | Gleitkomma |
|          |                     |                         |            |
| INT      | ganzzahliger Anteil | arg in R                | Integer    |
|          |                     |                         |            |
| BITCNT   | binÑre Quersumme    | Integer                 | Integer    |
| FIRSTBIT | niedrigstes 1-Bit   | Integer                 | Integer    |
| LASTBIT  | hîchstes 1-Bit      | Integer                 | Integer    |
| BITPOS   | einziges 1-Bit      | Integer                 | Integer    |
+----------+---------------------+-------------------------+------------+

Tabelle  2.12: vordefinierte  Funktionen in  AS -  Teil 1 (Integer- und
              Gleitkommafunktionen)


+-------------+-----------------------+--------------+--------------+
| Name        | Funktion              | Argument     | Ergebnis     |
+-------------+-----------------------+--------------+--------------+
+-------------+-----------------------+--------------+--------------+
| SGN         | Vorzeichen (0/1/-1)   | Integer oder | Integer      |
|             |                       | Gleitkomma   |              |
| ABS         | Betrag                | Integer oder | Integer oder |
|             |                       | Gleitkomma   | Gleitkomma   |
| TOUPPER     | pass. Gro·buchstabe   | Integer      | Integer      |
| TOLOWER     | pass. Kleinbuchstabe  | Integer      | Integer      |
| UPSTRING    | wandelt alle Zeichen  | String       | String       |
|             | in Gro·buchstaben     |              |              |
| LOWSTRING   | wandelt alle Zeichen  | String       | String       |
|             | in Kleinbuchstaben    |              |              |
| STRLEN      | liefert LÑnge eines   | String       | Integer      |
|             | Strings               |              |              |
| SUBSTR      | extrahiert Teil eines | String,      | String       |
|             | Strings               | Integer,     |              |
|             |                       | Integer      |              |
| CHARFROMSTR | extrahiert ein        | String,      | Integer      |
|             | Zeichen aus einem     | Integer      |              |
|             | String                |              |              |
| STRSTR      | sucht Teilstring in   | String,      | Integer      |
|             | einem String          | String       |              |
| VAL         | evaluiert Stringin-   | String       | abh. von     |
|             | halt als Ausdruck     |              | Argument     |
| EXPRTYPE    | liefert Typ des       | Integer,     | 0            |
|             | Arguments             | Gleitkomma,  | 1            |
|             |                       | String       | 2            |
+-------------+-----------------------+--------------+--------------+

Tabelle  2.13: vordefinierte  Funktionen in  AS -  Teil 2 (Integer- und
              String-Funktionen)

Die  Funktionen FIRSTBIT, LASTBIT  und BITPOS liefern  als Ergebnis -1,
falls  Åberhaupt kein bzw. nicht genau  ein Bit gesetzt ist. ZusÑtzlich
gibt BITPOS in einem solchen Fall eine Fehlermeldung aus.

Die  String-Funktion SUBSTR  erwartet als  ersten Parameter  den Quell-
string,  als zweiten  die Startposition  und als  dritten die Anzahl zu
extrahierender  Zeichen (eine 0 bedeutet, alle  Zeichen bis zum Ende zu
extrahieren).  Analog erwartet  CHARFROMSTR den  Quellstring als erstes
Argument  und die Zeichenposition als zweites Argument. Falls die ange-
gebene  Position  grî·er  oder  gleich  der LÑnge des Quellstrings ist,
liefert  SUBSTR einen  Leerstring, wÑhrend  CHARFROMSTR eine -1 ergibt.
Eine  Position  kleiner  Null  wird  von  SUBSTR  als  Null  behandlet,
wÑhrend CHARFROMSTR in diesem Fall ebenfalls eine -1 liefert.

Hier  ein Beispiel,  wie man  die beiden  Funktionen einsetzt, um einen
String  im Speicher abzulegen, wobei  das String-Ende durch ein gesetz-
tes MSB gekennzeichnet ist:


dbstr   macro   arg
        if      strlen(arg) > 1
         db     substr(arg, 0, strlen(arg) - 1)
        endif
        if      strlen(arg) > 0
         db     charfromstr(arg, strlen(arg) - 1) | 80h
        endif
        endm


STRSTR  liefert das erste Auftreten des  zweiten Strings im ersten bzw.
-1,  falls das  Suchmuster nicht  gefunden wurde.  Analog zu SUBSTR und
CHARFROMSTR hat das erste Zeichen den Positionswert 0.

Wenn  eine  Funktion  auch  Gleitkommaargumente  erwartet, so soll dies
nicht bedeuten, da· man nicht z.B.

wur2   equ      sqrt(2)

schreiben  dÅrfte --- in solchen FÑllen findet automatisch eine Typkon-
vertierung  statt. Umgekehrt mu·  allerdings die INT-Funktion angewandt
werden,  um  eine  Gleitkommazahl  ganz  zu bekommen. Bei der Benutzung
dieser  Funktion ist zu beachten, da· sie als Ergebnis immer einen vor-
zeichenbehafteten  Integer  liefert,  sie  hat  also einen Wertebereich
von ca. +/-2.0E9.

Schaltet  man AS in  den case-sensitiven Modus,  so kînnen im Gegensatz
zu  vordefinierten Symbolen die  vordefinierten Funktionen weiterhin in
beliebiger  Schreibweise  angesprochen  werden.  Bei  selbstdefinierten
Funktionen  (siehe Abschnitt 3.4.9  wird allerdings unterschieden. Dies
hat  zur Folge, da· z.B. bei der  Definition einer Funktion Sin man mit
Sin  diese Funktion auch erreicht,  mit allen anderen Schreibweisen je-
doch die eingebaute Funktion.

FÅr  die korrekte Umwandlung von  Klein-zu Gro·buchstaben ist eine DOS-   DOS/
Version >= 3.30 erforderlich.



        2.10. VorwÑrtsreferenzen und andere Desaster
        --------------------------------------------

Dieser  Abschnitt  ist  das  Produkt  eines  gewissen  Grolls  auf  die   DPMI
(durchaus  legale) Art und  Weise, wie einige  Leute programmieren, die
in  Zusammenhang mit AS bisweilen das eine oder andere Problem verursa-
chen  kann. Die  Rede ist  hier von sogenannten ,,VorwÑrtsreferenzen''.
Was  unterscheidet eine  VorwÑrtsreferenz von  einer normalen Referenz?
Dazu  sehe man sich  folgendes Programmbeispiel an  (man sehe mir bitte
meine  --  auch  im  Rest  dieser  Anleitung  anzutreffende  --  68000-
Lastigkeit nach):

        move.l  #10,d0
loop:   move.l  (a1),d1
        beq     skip
        neg.l   d1
skip:   move.l  d1,(a1+)
        dbra    d0,loop

Denkt  man sich  den Scheifenrumpf  mit dem  Sprung weg,  so bleibt ein
Ñu·erst  angenehm zu assemblierendes Programm  Åbrig: die einzige Refe-
renz  ist der RÅcksprung  zum Anfang des  Rumpfes, und da ein Assembler
ein  Programm von vorne  nach hinten durcharbeitet,  hat er den Symbol-
wert  bereits ermittelt, bevor  er ihn zum  erstem Mal benîtigt. Sofern
man  ein Programm hat, das  nur solche RÅckwÑrtsreferenzen besitzt, ist
man  in der  angenehmen Lage,  nur einmal  durch den Quellcode gehen zu
mÅssen,  um den korrekten und  optimalen Maschinencode zu finden. Eini-
ge  Hochsprachen wie  Pascal mit  ihrer strikten  Regel, da·  alles vor
der  ersten  Benutzung  definiert  sein  mu·, nutzen genau diese Eigen-
schaft aus, um den Åbersetzungsvorgang zu beschleunigen.

Leider  ist die  Sache im  Falle von  Assembler nicht  so einfach, denn
man  will ja bisweilen auch vorwÑrts im  Code springen oder mu· aus be-
stimmten  GrÅnden Variablendefinitionen hinter  den Code verlegen. Dies
ist  im Beispiel der Fall  fÅr den bedingten Sprung,  mit dem ein ande-
rer  Befehl Åbersprungen wird.  Wenn der Assembler  im ersten Durchlauf
auf  den Sprungbefehl trifft,  so sieht er  sich mit der Situation kon-
frontiert,  entweder die  Teilfelder der  Instruktion, die  die Sprung-
adresse  beinhalten, leerzulassen, oder  seitens des Formelparsers (der
das  Adre·argument ja auswerten mu·) anstelle des korrekten, aber unbe-
kannten  Wertes einen  Wert anzubieten,  der ,,niemandem  wehtut''. Bei
einem  einfachen Assembler, der nur  eine Zielarchitektur kennt und bei
dem  sich die betroffenen  Befehle an einer  Hand abzÑhlen lassen, wird
man  sicher die  erste Variante  wÑhlen, bei  AS mit seinen vielen Dut-
zend  Zielen wÑre die  Zahl der Sonderabfragen  aber extrem hoch gewor-
den,  so da· nur der zweite Weg in  Frage kam: Falls im ersten Pass ein
unbekanntes  Symbol auftaucht, so liefert der Formelparser den momenta-
nen  Stand  des  ProgrammzÑhlers  als  Ergebnis zurÅck! Nur dieser Wert
ist   geeignet,  relativen  SprÅngen  mit  Sprungdistanzen  unbekannter
LÑnge  eine Adresse anzubieten, die nicht zu Fehlern fÅhrt. Dies beant-
wortet  auch die bisweilen gestellte Frage,  warum in einem Listing des
ersten  Passes (dies bleibt z.B. stehen,  wenn AS aufgrund anderer Feh-
ler  den zweiten  Pass erst  gar nicht  beginnt), z.T. falsche Adressen
im  erzeugten  BinÑrcode  gezeigt  werden  -  dies sind noch nicht auf-
gelîste VorwÑrtsreferenzen.

Das  obige Beispiel  offenbart allerdings  noch eine weitere Schwierig-
keit  von VorwÑrtsreferenzen:  Je nach  Abstand von  Quelle und Ziel im
Code  kann der  Sprungbefehl entweder  lang oder  kurz sein. Diese Ent-
scheidung  Åber die Code-LÑnge - und  damit auch die Adressen folgender
Labels  - kann jedoch  mangels genauer Kenntnis  der Zieladresse im er-
sten  Pass  nicht  erfolgen.  Sofern  der  Programmierer nicht explizit
kenntlich  gemacht hat, ob der Sprung  lang oder kurz sein soll, behel-
fen  sich reine  2-Pass-Assembler wie  Ñltere MASM-Versionen von Micro-
soft  damit, im ersten Pass (nach  diesem mÅssen alle Adressen festlie-
gen)  Platz fÅr die lÑngste Version  zu reservieren und im zweiten Pass
den  ÅberschÅssigen Platz  mit NOPs  aufzufÅllen. AS-Versionen bis 1.37
taten  dieses  ebenfalls,  danach  bin  ich auf das Multipass-Verfahren
Åbergegangen,  das die  strenge Einteilung  in zwei  Passes aufhebt und
beliebig  viele DurchgÑnge erlaubt. Dazu wird  im ersten Pass der opti-
male  Code mit den  angenommenen Symbolwerten erzeugt.  Stellt AS fest,
da·  im zweiten Pass durch  CodelÑngenverÑnderungen sich Werte von Sym-
bolen  geÑndert haben,  so wird  einfach noch  ein dritter  Pass einge-
legt,  und da  durch die  neuen Symbolwerte  des zweiten Passes auch im
dritten  Pass sich der Code wieder  verkÅrzen oder verlÑngern kann, ist
ein  weiterer Pass nicht  unmîglich. Ich habe  schon 8086-Programme er-
lebt,  bei denen  erst nach  12 DurchgÑngen  alles stimmte.  Leider er-
laubt  dieser  Mechanismus  nicht  die  Vorgabe  einer  Maximalzahl von
DurchlÑufen,  ich  kann  als  Regel  nur  sagen,  da·  die  Anzahl  von
DurchlÑufen  sinkt, je mehr man davon  Gebrauch macht, Sprung- oder Ad-
re·lÑngen explizit vorzugeben.

Speziell  bei gro·en Programmen kann es zu einer interessanten Situati-
on  kommen: Die  Lage eines  vorwÑrts gerichteten  Sprunges hat sich im
zweiten  Pass so  weit gegenÅber  dem ersten  verschoben, da· der jetzt
noch  benutzte Label-Wert aus  dem ersten Pass  au·erhalb der erlaubten
Sprungdistanz  liegt.  AS  berÅcksichtigt  solche Situationen, indem er
jegliche  Fehlermeldungen  Åber  zu  weite Sprungdistanzen unterdrÅckt,
sobald  er erkannt hat,  da· er wegen  sich Ñndernder Symbolwerte ohne-
hin  einen  weiteren  Durchlauf  machen  mu·. Dies funktioniert zwar in
99%  aller FÑlle, es  gibt jedoch auch  Konstrukte, in denen der erste,
derartig  kritische  Befehl  bereits  auftaucht,  bevor  AS eine Chance
hat,  zu erkennen,  da· ein  neuer Pass  erforderlich ist. Das folgende
Beispiel   konstruiert   eine   solche   Situation   mit   Hilfe  einer
VorwÑrtsreferenz  (und  war  der  Anla·  fÅr die öberschrift dieses Ab-
schnitts...):

        cpu   6811

        org     $8000
        beq     skip
        rept    60
         ldd    Var
        endm
skip:   nop

Var     equ     $10

Aufgrund  der Adre·lage nimmt AS im  ersten Pass lange Adressen fÅr die
LDD-Befehle  an, was eine Code-LÑnge von  180 Bytes ergibt und im zwei-
ten  Pass (zum Zeitpunkt des BEQ-Befehls  ist noch der ,,falsche'' Wert
von  skip aktuell,  d.h. AS  wei· zu  diesem Zeitpunkt  noch nicht, da·
der  Code in Wirklichkeit nur 120 Bytes  lang ist) gibt es eine Fehler-
meldung  wegen einer Åberschrittenen  Sprungdistanz. Dieser Fehler lÑ·t
sich auf drei Arten vermeiden:

  1 Weisen  Sie AS explizit darauf hin, da· er fÅr die LDD-Befehle kur-
    ze Adressen verwenden darf (ldd <Var)
  2 Entfernen  Sie diese vermaledeite,  verfluchte VorwÑrtsreferenz und
    setzen  Sie  die  EQU-Anweisung  nach  vorne, wo sie hingehîrt (OK,
    ich beruhige mich ja schon wieder...)
  3 FÅr  ganz Unentwegte:  Benutzten Sie  die -Y-Option,  so da· AS die
    Fehlermeldung  beim  Erkennen  der  Adre·verschiebung  nachtrÑglich
    verwirft. Nicht schîn, aber...

Noch  ein Hinweis zum  EQU-Befehl: Da AS  nicht wissen kann, in welchem
Zusammenhang  ein  mit  EQU  definiertes  Symbol spÑter verwendet wird,
wird  ein  EQU  mit  VorwÑrtsreferenzen  im ersten Pass Åberhaupt nicht
durchgefÅhrt.  Wird das mit EQU definierte  Symbol also im zweiten Pass
vorwÑrts referenziert:

        move.l  #sym2,d0
sym2    equ     sym1+5
sym1    equ     0

so  handelt man sich im zweiten Pass eine Fehlermeldung wegen eines un-
definerten  Symbols  ein...aber  warum  machen  Leute eigentlich solche
Dinge ???

Zugegeben,  das war ein ziemlich lÑnglicher Ausflug, aber es mu·te ein-
fach  einmal sein. Was  sollte man als  Erkenntnis aus diesem Abschnitt
mitnehmen?

  1 AS  versucht  immer,  den  kÅrzestmîglichen  Code zu erzeugen. Dazu
    benîtigt  er  eine  endliche  Zahl  von  DurchlÑufen.  Wenn man ihn
    nicht gerade knebelt, kennt AS keine RÅcksichten...
  2 Wenn  sinnvoll und mîglich, Sprung- und Adre·lÑngen explizit vorge-
    ben.  Man kann damit u.U. die  Anzahl der DurchlÑufe deutlich redu-
    zieren.
  3 VorwÑrtsreferenzen  auf das allernîtigste beschrÑnken. Man erleich-
    tert sich und AS das Leben damit erheblich!



        2.11. Registersymbole
        ---------------------

GÅltigkeit: PowerPC, M-Core, 4004/4040, 80C16x, AVR

Manchmal  ist es erwÅnscht, nicht  nur einer Speicheradresse oder einer
Konstanten,  sondern auch einem Register einen symbolischen Namen zuzu-
weisen,  um  seine  Funktion  in  einem bestimmten Programmabschnitt zu
verdeutlichen.  Dies  ist  bei  Prozessoren,  die die Register schlicht
als  einen weiteren Adre·raum behandeln, recht problemlos, da als Regi-
ster  damit auch  ZahlenausdrÅcke erlaubt  sind und  man solche Symbole
mit  schlichten EQUs  definieren kann  (z.B. bei  MCS-96 oder TMS7000).
Bei  den allermeisten Prozessoren  jedoch sind Registernamen festgeleg-
te  Literale, und  AS behandelt  sie aus GeschwindigkeitsgrÅnden geson-
dert,  so da· ein  besonderer Mechanismus vonnîten  ist, um symbolische
Register  zu  definieren.  Ein  Registersymbol wird Åblicherweise durch
die  REG-Anweisung definiert und hat ansonsten die gleiche Form wie ei-
ne   EQU-Definition.  Sie  unterliegt  jedoch   einer  Reihe  von  Ein-
schrÑnkungen:  Zum einen ist ein Registersymbol  eine reine 'as is' ge-
speicherte  Zeichenkette, die auch nur  in dieser Form verwendet werden
kann.  Es ist  also z.B.  keine Arithmetik  mîglich, um aus einem Regi-
ster den Nachfolger zu berechnen, etwa so:

myreg   reg     r17         ; Definition Registersymbol
        addi    myreg+1,3   ; geht nicht!

Zum  anderen  mu·  ein  Registersymbol  vor seiner ersten Nutzung defi-
niert  werden;  eine  VorwÑrtsreferenz  wÅrde  dazu  fÅhren, da· AS bei
nicht  gefundenem Registersymbol  eine VorwÑrtsreferenz  auf eine Spei-
cherstelle  vermutet,  und  bei  den  meisten Prozessoren sind die Nut-
zungsmîglichkeiten  fÅr Speicherstellen  als Operanden  deutlich einge-
schrÑnkter  als fÅr Register, so da·  es mit ziemlicher Sicherheit Feh-
ler hagelt...

Registersymbole  sind analog  zu normalen  Symbolen lokal zu Sektionen,
und  es ist auch durch AnhÑngen eines in eckige Klammern gesetzten Sek-
tionsnamens  mîglich, auf ein Registersymbol  aus einer bestimmten Sek-
tion    zuzugreifen.   Aufgrund    der   fehlenden    Mîglichkeit   zur
VorwÑrtsreferenz   gibt  es   aber  keine   Entsprechung  zur  FORWARD-
Direktive,  und  da  Registersymbole  im  allgemeinen nur in einem sehr
eng  umschrÑnkten Kontext eine Bedeutung haben,  ist ein Export per PU-
BLIC oder GLOBAL auch nicht vorgesehen.

Sind  in einem Kontext  ein normales als  auch ein Registersymbol glei-
chen  Namens  bekannt,  so  wird  immer  das Registersymbol vorgezogen.
Dies  ist aber  nicht der  Fall, wenn  der Name  nicht alleine, sondern
eingebunden  in  einen  Ausdruck  steht  (dazu reichen Klammern!), dann
wird das normale Symbol benutzt.


        2.12. Sharefile
        ---------------

Diese   Funktion  ist   ein  Abfallprodukt   aus  den  reinen  68000er-
VorgÑngern  von AS, da sie vielleicht  doch der (die?!) eine oder ande-
re  gebrauchen kînnte, habe ich  sie dringelassen. Grundproblem ist es,
an  bestimmte  beim  Assemblieren  entstehende  Symbole  heranzukommen,
weil  man  evtl.  mit  diesen  Adre·informationen  auf den Speicher des
Zielsystems  zugreifen mîchte. Der Assembler  erlaubt es, mit Hilfe des
SHARED-Pseudobefehles  (siehe  dort)  Symbolwerte  extern zur VerfÅgung
zu  stellen. Zu diesem Zweck erstellt der Assembler im zweiten Pass ei-
ne  Textdatei mit den  gewÅnschten Symbolen und  ihren Werten, die mit-
tels  Include in ein  Hochsprachen-oder weiteres Assemblerprogramm ein-
gebunden  werden kînnen. Das  Format der Textdatei  (C, Pascal oder As-
sembler)  wird  durch  die  Kommandozeilenschalter  p, c oder a festge-
legt.

ACHTUNG!  Ist keiner dieser Schalter angegeben,  so wird auch keine Da-
tei  erzeugt,  egal  ob  sich  SHARED-Befehle  im Quelltext finden oder
nicht!

AS  prÅft beim  Anlegen der  Share-Datei nicht,  ob bereits  eine Datei
gleichen   Namens   existiert,   eine   solche   wird   ggfs.   einfach
Åberschrieben.  Eine Abfrage halte  ich nicht fÅr  sinnvoll, da AS dann
bei  jedem Lauf  fragen wÅrde,  ob er  die alte Version der Share-Datei
Åberschreiben darf, und das wÑre doch sehr lÑstig...


        2.13. Prozessor-Aliasse
        -----------------------

Mit  Varianten gÑngiger Mikrocontroller-Familien ist  es wie mit Kanin-
chen:  Sie vermehren sich schneller, als man mit der Versorgung hinter-
herkommen  kann. Im Zuge  der Entwicklung von  Prozessorkernen als Bau-
steine  fÅr ASICs und von  Controller-Familien mit vom Kunden wÑhlbarer
Peripherie  wird die Zahl von  Controller-Varianten, die sich von einem
bekannten  Typ nur  in einigen  Peripherie-Details unterscheiden, immer
grî·er.  Die Unterscheidung  der einzelnen  Typen ist  aber trotz meist
identischer  Prozessorkernes wichtig,  um z.B.  in den Includefiles den
korrekten  Satz von  Peripherieregistern einzublenden.  Bisher habe ich
mich  zwar immer bemÅht, die wichtigsten  Vertreter einer Familie in AS
einzubauen  (und werde  das auch  weiter tun),  aber manchmal lÑuft mir
die  Entwicklung einfach auf und  davon...es mu·te also ein Mechanismus
her,  mit dem man die  Liste der unterscheidbaren Prozessortypen selbst
erweitern kann.

Das  Ergebnis davon sind Prozessor-Aliasse: Mit der Kommandozeilenopti-
on  alias kann man einen neuen Prozessortyp definieren, der im Befehls-
satz  einem anderen, in AS fest  eingebauten Typ entspricht. Bei Benut-
zung   dieses  Typs   im  CPU-Befehl   wird  sich   AS  also  wie  beim
,,Original''  verhalten,  mit  einem  Unterschied: Die Variablen MOMCPU
bzw.  MOMCPUNAME werden  auf den  Namen des  Alias gesetzt, wodurch der
neue Name zur Unterscheidung z.B. in Includefiles dienen kann.

Die  Definition dieser Aliasse wurde  aus zwei GrÅnden mit Kommandozei-
lenoptionen  anstatt Pseudobefehlen vorgenommen: zum  einen wÑre es oh-
nehin  nicht mîglich gewesen,  die Definition der  Aliasse zusammen mit
den  Registerdefinitionen in eine  Include-Datei zu legen,  denn in ei-
nem  Programm, das so  eine Datei benutzen  wollte, mÅ·te sie ja sowohl
vor  als auch nach dem CPU-Befehl  in der Hauptdatei eingebunden werden
-  eine  Vorstellung,  die  irgendwo  zwischen  unelegant und unmîglich
liegt.  Zum  zweiten  ermîglicht  diese Implementierung, die Definition
der  neuen Typen  in eine  Datei zu  legen, die Åber die ASCMD-Variable
beim  Start  automatisch  ausgefÅhrt  wird,  ohne das sich das Programm
darum kÅmmern mÅ·te.


        3. Pseudobefehle
        ================

Nicht  fÅr alle Prozessoren sind  alle Pseudobefehle definiert. Vor der
Beschreibung  eines Befehls  ist deshalb  jeweils vermerkt,  fÅr welche
Prozessortypen dieser Befehl erlaubt ist.


        3.1. Definitionen
        -----------------


        3.1.1.  SET, EQU und CONSTANT
        - - - - - - - - - - - - - - -

GÅltigkeit: alle Prozessoren, CONSTANT nur KCPSM(3)

SET  und EQU  erlauben die  Definition typenloser  Konstanten, d.h. sie
werden  keinem Segment zugeordnet  und ihre Verwendung  erzeugt in kei-
nem  Fall eine  Warnung wegen  Segmentverquickung. WÑhrend EQU Konstan-
ten  definiert, die nicht wieder (mit  EQU) geÑndert werden kînnen, er-
laubt  SET die Definition  von Variablen, die  sich wÑhrend des Assemb-
lerlaufes  verÑndern lassen. Dies ist  nÅtzlich z.B. bei der Allokation
von Resourcen Ö la Interruptvektoren, wie im folgenden Beispiel:

VecCnt  SET     0         ; irgendwo am Anfang
        ...
DefVec  MACRO   Name      ; einen neuen Vektor belegen
Name    EQU     VecCnt
VecCnt  SET     VecCnt+4
        ENDM
        ...
        DefVec  Vec1      ; ergibt Vec1=0
        DefVec  Vec2      ; ergibt Vec2=4

Intern  werden Konstanten und Variablen identisch gespeichert, der ein-
zige  Unterschied ist, da· sie  als unverÑnderbar markiert werden, wenn
sie  mit EQU definiert  werden. Der Versuch,  eine Konstante mit SET zu
verÑndern, gibt eine Fehlermeldung.

Mit EQU/SET lassen sich Konstanten aller Typen definieren, z.B.

IntZwei   EQU   2
FloatZwei EQU   2.0

Einige  Prozessoren  besitzen  leider  bereits selber einen SET-Befehl.
Bei diesen mu· EVAL anstelle von SET verwendet werden.

Anstelle  von EQU darf auch  einfach ein Gleichheitszeichen geschrieben
werden,  analog kann man anstelle von  SET bzw. EVAL einfach := schrei-
ben.

Aus  KompatibilitÑtsgrÅnden  zum  Originalassembler  gibt  es  fÅr  das
KCPSM-Target  auch den CONSTANT-Befehl,  der im Gegensatz  zu EQU Namen
und Wert als Argument erwartet, also z.B. so:

      CONSTANT  const1, 2

CONSTANT ist allerdings auf Integer-Konstanten beschrÑnkt.

DefaultmÑ·ig  sind mit SET oder EQU definierte Symbole typenlos, optio-
nal  kann jedoch als zweites Argument ein Segmentname (CODE, DATA, IDA-
TA,  XDATA, YDATA, BITDATA, IO oder  REG) oder MOMSEGMENT fÅr das aktu-
ell  gesetzte Segment angegeben werden,  um das Symbol einem bestimmten
Adre·raum  zuordnen. AS berÅcksichtigt dabei nicht, ob der benutzte Ad-
re·raum bei dem aktuell gesetzten Zielprozessor auch vorhanden ist!


        3.1.2. SFR und SFRB
        - - - - - - - - - -

GÅltigkeit: diverse, SFRB nur MCS-51

Diese  Befehle funktionieren  wie EQU,  nur sind  die damit definierten
Symbole  dem  direkt  adressierbaren  Datensegment zugeordnet, d.h. sie
dienen  bevorzugt zur Definition  von RAM-Zellen und  (wie der Name ah-
nen  lÑ·t) im Datenbereich  eingeblendeten Hardwareregistern. Der dabei
zugelassene  Wertebereich ist identisch  mit dem bei  ORG fÅr das DATA-
Segment  zugelassenen (s. Abschnitt 3.2.1).  SFR und SFRB unterscheiden
sich  darin, da·  SFRB das  Register als  bitadressierbar kennzeichnet,
weshalb  AS zusÑtzlich 8  Symbole erzeugt, die  dem Bitsegment zugeord-
net werden und die Namen xx.0 bis xx.7 tragen, z.B.

PSW     SFR     0d0h   ; ergibt PSW = D0H (Datensegment)

PSW     SFRB    0d0h   ; zusaetzlich PSW.0 = D0H (Bit)
                       ; bis PSW.7 = D7H (Bit)

Da  beim 80C251  grundsÑtzlich alle  SFRs ohne  zusÑtzliche Bit-Symbole
bitadressierbar  sind, ist der SFRB-Befehl fÅr  ihn auch nicht mehr de-
finiert; die Bits PSW.0 bis PSW.7 sind automatisch vorhanden.

AS  ÅberprÅft bei der Definition  eines bitadressierbaren Registers mit
SFRB,  ob  die  Speicherstelle  Åberhaupt  bitadressierbar ist (Bereich
20h..3fh  bzw. 80h,  88h, 90h,  98h...0f8h). Ist  sie es nicht, so wird
eine  Warnung ausgegeben;  die dann  erzeugten Bit-Symbole sind undefi-
niert.


        3.1.3.  XSFR und YSFR
        - - - - - - - - - - -

GÅltigkeit: DSP56xxx

Auch  der DSP56000 hat einige Peripherieregister memory-mapped im Spei-
cher  liegen, die Sache wird jedoch  dadurch komplizierter, da· es zwei
Datenbereiche  gibt, den X-und Y-Bereich. Diese Architektur erlaubt ei-
nerseits  zwar einen hîheren  ParallelitÑtsgrad, zwingt jedoch anderer-
seits  dazu, den normalen SFR-Befehl in die beiden oben genannten Vari-
anten  aufzuspalten. Sie verhalten sich identisch  zu SFR, nur da· XSFR
ein  Symbol im X-Adre·raum definiert und  YSFR entsprechend eines im Y-
Adre·raum. Der erlaubte Wertebereich ist 0..$ffff.


        3.1.4.  LABEL
        - - - - - - -

GÅltigkeit: alle Prozessoren

Die  Funktion des LABEL-Befehls ist identisch zu EQU, nur wird das Sym-
bol  nicht typenlos, sondern  erhÑlt das Attribut  ,,Code''. LABEL wird
genau  fÅr einen  Zweck benîtigt:  Labels in  Makros sind normalerweise
lokal,  also  nicht  au·erhalb  des  Makros  zugreifbar. Mit einem EQU-
Befehl kann man sich zwar aus der AffÑre ziehen, die Formulierung

<Name>   label    $

erzeugt aber ein Symbol mit korrekten Attributen.


        3.1.5.  BIT
        - - - - - -

GÅltigkeit: MCS-(2)51, XA, 80C166, 75K0, ST9

BIT  dient dazu, ein einzelnes Bit  einer Speicherstelle mit einem sym-
bolischen  Namen gleichzusetzen. Da die  Art und Weise, wie verschiede-
ne  Prozessoren Bitverarbeitung und  -adressierung betreiben, stark va-
riiert, verhÑlt sich auch dieser Befehl je nach Zielplattform anders:

FÅr  die MCS/51-Familie,  die einen  eigenen Adre·raum fÅr Bitoperanden
besitzt,  ist die  Funktion von  BIT ganz  analog zu  SFR, d.h. es wird
einfach  ein Integer-Symbol  mit dem  angegebenen Wert  und dem Segment
BDATA  erzeugt. FÅr  alle anderen  Prozessoren wird die Bitadressierung
dagegen  zweidimensional mit Adresse und Bitstelle vorgenommen. In die-
sem  Fall verpackt  AS beide  Teile in  einer vom  jeweiligen Prozessor
abhÑngigen  Weise in ein Integer-Symbol und  drîselt dieses bei der Be-
nutzung  wieder in die beiden  Teile auseinander. Letzterer Fall trifft
auch schon fÅr den 80C251 zu: WÑhrend zum Beispiel der Befehl

Mein_Carry	bit	PSW.7

auf  einem  8051  noch  dem  Symbol  Mein_Carry  den Wert 0d7h zuweisen
wÅrde,  wÅrde auf  einem 80C251  dagegen ein  Wert von  070000d0h gene-
riert  werden, d.h. die  Adresse steht in  Bit 0..7 sowie die Bitstelle
in  Bit 24..26.  Dieses Verfahren  entspricht dem,  das auch beim DBIT-
Befehl  des TMS370 angewendet  wird und funktioniert  sinngemÑ· so auch
beim 80C166, nur da· dort Bitstellen von 0 bis 15 reichen dÅrfen:

MSB     BIT     r5.15

Beim  Philips XA findet sich  in Bit 0..9 die  Bitadresse, wie sie auch
in  die  Maschinenbefehle  eingesetzt  wird,  fÅr  Bits  aus  den  RAM-
Speicher wird in Bit 16..23 die 64K-Bank eingesetzt.

Noch  etwas weiter  geht der  BIT-Befehl bei  der 75K0-Familie: Da dort
Bitadressierungen  nicht nur  absolute Basisadressen  verwenden dÅrfen,
sind sogar AusdrÅcke wie

bit1    BIT     @h+5.2

erlaubt.

Beim  ST9 ist es  hingegen mîglich, Bits  auch invertiert anzusprechen,
was beim BIT-Befehl auch berÅcksichtigt wird:

invbit  BIT     r6.!3

NÑheres  zum BIT-Befehl beim ST9  findet sich bei den prozessorspezifi-
schen Hinweisen.


        3.1.6. DBIT
        - - - - - -

GÅltigkeit: TMS 370xxx

Die  TMS370-Reihe hat  zwar kein  explizites Bit-Segment, jedoch kînnen
einzelne  Bits als  Symbol durch  diesen Befehl  simuliert werden. DBIT
benîtigt  zwei Operanden, nÑmlich einmal  die Adresse der Speicherstel-
le,  in der das Bit liegt, sowie  die genaue Position des Bits im Byte.
So definiert man z.B. mit

INT3            EQU     P019
INT3_ENABLE     DBIT    0,INT3

das  Bit, welches Interrupts von  Anschlu· INT3 freigibt. So definierte
Bits  kînnen  dann  von  den  Befehlen  SBIT0, SBIT1, CMPBIT, JBIT0 und
JBIT genutzt werden.


        3.1.7. PORT
        - - - - - -

GÅltigkeit: 8080/8085/8086, XA, Z80, 320C2x/5x, TLCS-47, AVR

PORT  arbeitet analog zu SFR, nur  wird das Symbol dem I/O-Adre·bereich
zugeordnet.  Erlaubte Werte  sind 0..7  beim 3201x,  0..15 beim 320C2x,
0..65535 beim 8086 und 320C5x, 0..63 beim AVR und 0..255 beim Rest.

Beispiel: eine PIO 8255 liege auf Adresse 20H:

PIO_Port_A PORT 20h
PIO_Port_B PORT PIO_Port_A+1
PIO_Port_C PORT PIO_Port_A+2
PIO_Ctrl   PORT PIO_Port_A+3



        3.1.8.  REG und NAMEREG
        - - - - - - - - - - - -

GÅltigkeit:   AVR,  M*Core,  ST9,  80C16x,  KCPSM  (  NAMEREG  nur  fÅr
KCPSM(3)), LatticeMico8

Obwohl  immer mit  gleicher Syntax,  hat diese  Anweisung von Prozessor
zu  Prozessor eine leicht abweichende  Bedeutung: Falls der Zielprozes-
sor  fÅr Register  einen eigenen  Adre·raum verwendet,  so hat  REG die
Wirkung  eines simplen EQUs fÅr eben  diesen Adre·raum (z.B. beim ST9).
FÅr  alle  anderen  Prozessoren  definiert  REG  Registersymbole, deren
Funktion in Abschnitt 2.11 beschrieben sind.

NAMEREG  existiert  aus  KompatibilitÑtsgrÅnden  zum  Originalassembler
fÅr  den KCPSM.  Es hat  die gleiche  Funktion, lediglich werden sowohl
Register-  als  auch  symbolischer  Name  als Argumente angegeben, z.B.
so:

     NAMEREG  s08, treg



        3.1.9.  LIV und RIV
        - - - - - - - - - -

GÅltigkeit: 8X30x

LIV  und RIV dienen dazu,  sogenannte IV-Bus-Objekte zu definieren. Bei
diesen  handelt es sich um  Bitgruppen in peripheren Speicherzellen mit
einer  LÑnge von  1..8 Bit,  die fortan  symbolisch angesprochen werden
kînnen,  so da· man  bei den entsprechenden  Befehlen nicht mehr Adres-
se,  LÑnge und Position  separat angeben mu·.  Da die 8X30x-Prozessoren
zwei   periphere  Adre·rÑume  besitzen   (einen  ,,linken''  und  einen
,,rechten'',  sind auch zwei separate  Befehle definiert. Die Parameter
dieser  Befehle  sind  allerdings  identisch:  es mÅssen drei Parameter
sein,  die Adresse,  Startposition und  LÑnge angeben. Weitere Hinweise
zur Benutzung von Busobjekten finden sich in Abschnitt 4.17.


        3.1.10. CHARSET
        - - - - - - - -

GÅltigkeit: alle Prozessoren

Einplatinensysteme,  zumal  wenn  sie  LCDs  ansteuern, benutzen hÑufig
einen  anderen Zeichensatz als  ASCII, und da·  die Umlautkodierung mit
der  im PC Åbereinstimmt,  dÅrfte wohl reiner  Zufall sein. Um nun aber
keine  fehlertrÑchtigen Handumkodierungen vornehmen  zu mÅssen, enthÑlt
der  Assembler eine Umsetzungstabelle fÅr  Zeichen, die jedem Quellcode
ein  Zielzeichen zuordnet. Zur Modifikation  dieser Tabelle (die initi-
al  1:1 Åbersetzt),  dient der  Befehl CHARSET.  CHARSET kann  mit ver-
schiedenen  Parameterzahlen und -typen angewendet werden. Ist die Para-
meterzahl  eins, so mu·  es sich um  einen String-Ausdruck handeln, der
von  AS als  Dateiname interpretiert  wird. Aus  dieser Datei  liest AS
dann   die   ersten   256   Bytes   aus   und   kopiert   sie   in  die
öbersetzungstabelle.  Hiermit lassen  sich also  komplexere, extern er-
zeugte  Tabellen in einem  Schlag aktivieren. In  allen anderen Varian-
ten  mu·  der  erste  Parameter  ein  Integer  im Bereich von 0 bis 255
sein,  der den Startpunkt der  in der öbersetzungstabelle zu modifizie-
renden  EintrÑge angibt. Es  folgen dann ein  oder zwei weitere Parame-
ter, die die Art der öbersetzung angeben:

Ein  einzelner, weiterer Integer verÑndert  genau einen Eintrag. So be-
deutet z.B.

    CHARSET 'Ñ',128

da·  das Zielsystem das  Ñ mit der  Zahl 128 kodiert.  Sind jedoch zwei
weitere  Integers angegeben, so  ist der erste  von ihnen der letzte zu
modifizierende  Eintrag, der zweite der  neue Wert des ersten Eintrags;
alle  weiteren EintrÑge bis zum Bereichsende werden sequentiell neu be-
legt.  Falls  z.B.  das  Zielsystem  keine Kleinbuchstaben unterstÅtzt,
kînnen mit

        CHARSET 'a','z','A'

alle  Kleinbuchstaben auf die  passenden Gro·buchstaben automatisch um-
gemappt werden.

In  der letzten Variante folgt nach  dem Startindex ein String, der die
ab  dem  Startindex  abzulegenden  Zeichen  angibt. Das letzte Beispiel
kînnte man also auch so formulieren:

        CHARSET 'a',"ABCDEFGHIJKLMNOPQRSTUVWXYZ"


CHARSET  kann auch  ganz ohne  Parameter aufgerufen  werden, allerdings
mit  ziemlich grÅndlichen  Folgen: Dies  bewirkt eine Reinitialisierung
der  öbersetzungstabelle in  ihren Urzustand,  d.h. man  bekommt wieder
eine 1:1-öbersetzung.

ACHTUNG!  CHARSET beeinflu·t nicht nur im Speicher abgelegte Stringkon-
stanten,  sondern  auch  als  ,,ASCII''  formulierte Integerkonstanten.
Dies  bedeutet, da·  eine evtl.  bereits modifizierte Umsetzungstabelle
in den obigen Beispielen zu anderen Ergebnissen fÅhren kann!


        3.1.11.  CODEPAGE
        - - - - - - - - -

GÅltigkeit: alle Prozessoren

Mit  der  CHARSET-Anweisung  hat  man  zwar beliebige Freiheiten in der
Zeichenzuordnung  zwischen  Entwicklungs-  und  Zielplattform, wenn auf
der  Zielplattform  jedoch  verschiedene  ZeichensÑtze existieren, kann
das  Umschalten  zwischen  diesen  jedoch  zu einer umstÑndlichen Orgie
von  CHARSET-Kommandos werden. Mit der  CODEPAGE-Anweisung kann man je-
doch  mehrere Zeichentabellen  vorhalten und  zwischen diesen mit einem
Befehl  umschalten. Als Parameter  erwartet CODEPAGE ein  oder zwei Na-
men:  zum einen den Namen der  fortan zu benutzenden Tabelle, zum ande-
ren  optional den Namen der Tabelle,  die die initiale Belegung der Ta-
belle  vorgibt  (dieser  Parameter  hat  somit  auch nur eine Bedeutung
beim  ersten Umschalten  auf eine  Tabelle, bei  der AS sie automatisch
anlegt).  Fehlt der zweite Parameter, so  ist die initiale Belegung der
neuen  Tabelle gleich der vorher  aktiven Tabelle. Alle folgenden CHAR-
SET-Anweisungen verÑndern nur die momentan aktive Tabelle.

Zu  Beginn eines Durchlaufes wird von AS automatisch eine einzelne Zei-
chentabelle  mit dem Namen STANDARD  erzeugt und 1:1 vorbelegt. Verwen-
det  man keine CODEPAGE-Anweisungen, so  beziehen sich alle mit CHARSET
gemachten Einstellungen auf diese Tabelle.


        3.1.12.  ENUM
        - - - - - - -

GÅltigkeit: alle Prozessoren

ENUM   dient   analog   zu   dem   entsprechenden  Befehl  in  C  dazu,
AufzÑhlungstypen   zu   definieren,   d.h.   eine  Reihe  von  Integer-
Konstanten,  denen fortlaufende  Werte (von  0 an beginnend) zugewiesen
werden.  Als Parameter werden dabei die Namen der zu definierenden Sym-
bole angegeben, wie in dem folgenden Beispiel:

    ENUM SymA,SymB,SymC

Dieser  Befehl weist den  Symbolen SymA, SymB  und SymC die  Werte 0, 1
und 2 zu.

ENUM-Befehle  sind von Hause aus einzeilig,  d.h. bei einem neuen ENUM-
Befehl   beginnt   die   Numerierung   wieder   bei  Null.  Mehrzeilige
AufzÑhlungen  kann man aber mit einem  kleinen Trick erreichen, der die
Tatsache  ausnutzt, da· man  mit einer expliziten  Zuweisung den inter-
nen ZÑhler neu setzen kann, wie in dem folgenden Fall:

    ENUM Januar=1,Februar,MÑrz,April,Mai,Juni

Hier  werden den  Monatsnamen die  Zahlenwerte 1..6  zugewiesen. Mîchte
man die AufzÑhlung nun fortsetzen, geht das folgenderma·en:

    ENUM Juli=Juni+1,August,September,Oktober
    ENUM November=Oktober+1,Dezember

Die  Definition  von  Symbolen  mit  ENUM  gleicht einer Definition mit
EQU,  d.h. es ist nicht mîglich, einem Symbol einen neuen Wert zuzuwei-
sen.


        3.1.13.  PUSHV und POPV
        - - - - - - - - - - - -

GÅltigkeit: alle Prozessoren

Mit  PUSHV und POPV  ist es mîglich,  den Wert von (nicht makrolokalen)
Symbolen  temporÑr zu speichern und zu einem spÑteren Zeitpunkt wieder-
herzustellen.  Die Speicherung erfolgt  auf Stacks, d.h. Last-In-First-
Out-Speichern.  Ein Stack hat einen  Namen, der den allgemeinen Symbol-
konventionen  genÅgen mu·,  und existiert  so lange,  wie er mindestens
ein  Element enthÑlt: Ein bisher nicht existierender Stack wird bei PU-
SHV  automatisch angelegt, ein durch POPV leer werdender Stack wird au-
tomatisch  wieder aufgelîst. Der Name des Stacks, auf den Symbole abge-
legt  und von dem sie wieder abgeholt  werden sollen, ist der erste Pa-
rameter  von PUSHV  bzw. POPV,  danach folgt  eine beliebige  Menge von
Symbolen  als weitere Parameter. Alle  in der Liste aufgefÅhrten Symbo-
le  mÅssen bereits  existieren, es  ist also  nicht mîglich,  mit einem
POPV-Befehl implizit neue Symbole zu definieren.

Stacks  stellen eine globale Ressource dar,  d.h. ihre Namen sind nicht
lokal zu Sektionen.

Wichtig  ist, da· die Variablenliste immer  von links nach rechts abge-
arbeitet  wird. Wer  also mehrere  Variablen mit  POPV von  einem Stack
herunterholen  will,  mu·  diese  in  genau umgekehrter Reihenfolge zum
entsprechenden PUSHV angeben!

Der Name des Stacks kann auch weggelassen werden, etwa so:

        pushv   ,var1,var2,var3
        .
        .
        popv    ,var3,var2,var1

AS verwendet dann einen internen, vordefinierten Default-Stack.

Nach  Ende eines Durchlaufes  ÅberprÅft AS, ob  noch Stacks existieren,
die  nicht leer  sind, und  gibt deren  Namen sowie  ,,FÅllstand'' aus.
Mit  diesen Warnungen kann  man herausfinden, ob  an irgendeiner Stelle
die  PUSHV's  und  POPV's  nicht  paarig  sind. Es ist jedoch in keinem
Fall  mîglich, Symbolwerte in einem  Stack Åber mehrere DurchlÑufe hin-
wegzuretten: Zu Beginn eines Durchlaufes werden alle Stacks geleert!


        3.2. Codebeeinflussung
        ----------------------


        3.2.1.  ORG
        - - - - - -

GÅltigkeit: alle Prozessoren

ORG  erlaubt  es,  den  assemblerinternen  Adre·zÑhler  mit einem neuen
Wert  zu besetzen. Der Wertebereich  ist vom momentan gewÑhlten Segment
und  vom Prozessortyp abhÑngig (Tabellen 3.1 bis 3.4). Die untere Gren-
ze  ist  dabei  immer  0;  die  obere  Grenze der angegebene Wert minus
eins.

Falls  in  einer  Familie  verschiedene Varianten unterschiedlich gro·e
Adre·rÑume haben, ist jeweils der maximale Raum aufgefÅhrt.

ORG  wird in erster Linie benîtigt,  um dem Code eine neue Startadresse
zu  geben und damit verschiedene,  nicht zusammenhÑngende CodestÅcke in
einer  Quelldatei unterzubringen.  Sofern nicht  in einem Feld explizit
anders  angegeben, ist  die vorgegebene  Startadresse in  einem Segment
(d.h. die ohne ORG angenommene) immer 0.

+------------+------+------+-------+-------+-------+---------+-----+-----+---------+
| Ziel       | CODE | DATA | IDATA | XDATA | YDATA | BITDATA |  IO | REG | ROMDATA |
+------------+------+------+-------+-------+-------+---------+-----+-----+---------+
+------------+------+------+-------+-------+-------+---------+-----+-----+---------+
| 68xxx      |  4G  |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+------------+------+------+-------+-------+-------+---------+-----+-----+---------+
| DSP56000/  | 64K/ |  --- |  ---  |  64K/ |  64K/ |   ---   | --- | --- |   ---   |
| DSP56300   |  16M |      |       |  16M  |  16M  |         |     |     |         |
+------------+------+------+-------+-------+-------+---------+-----+-----+---------+
| PowerPC    |  4G  |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+------------+------+------+-------+-------+-------+---------+-----+-----+---------+
| M*Core     |  4G  |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+------------+------+------+-------+-------+-------+---------+-----+-----+---------+
| 6800,6301, |  64K |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| 6811       |      |      |       |       |       |         |     |     |         |
+------------+------+------+-------+-------+-------+---------+-----+-----+---------+
| 6805/      |  8K/ |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| HC08       |  64K |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+------------+------+------+-------+-------+-------+---------+-----+-----+---------+
| 6809,      |  64K |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| 6309       |      |      |       |       |       |         |     |     |         |
+------------+------+------+-------+-------+-------+---------+-----+-----+---------+
| 68HC12(X), |  64K |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| XGATE      |      |      |       |       |       |         |     |     |         |
+------------+------+------+-------+-------+-------+---------+-----+-----+---------+
| 68HC16     |  1M  |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+------------+------+------+-------+-------+-------+---------+-----+-----+---------+
| 68RS08     |  16K |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+------------+------+------+-------+-------+-------+---------+-----+-----+---------+
| H8/300     |  64K |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| H8/300H    |  16M |      |       |       |       |         |     |     |         |
+------------+------+------+-------+-------+-------+---------+-----+-----+---------+
| H8/500     |  64K |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| (Min)      |      |      |       |       |       |         |     |     |         |
| H8/500     |  16M |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| (Max)      |      |      |       |       |       |         |     |     |         |
+------------+------+------+-------+-------+-------+---------+-----+-----+---------+
| SH7000/    |  4G  |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| 7600/7700  |      |      |       |       |       |         |     |     |         |
+------------+------+------+-------+-------+-------+---------+-----+-----+---------+
| 6502,      |  64K |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| MELPS740   |      |      |       |       |       |         |     |     |         |
+------------+------+------+-------+-------+-------+---------+-----+-----+---------+
| 65816,     |  16M |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| MELPS-     |      |      |       |       |       |         |     |     |         |
| 7700       |      |      |       |       |       |         |     |     |         |
+------------+------+------+-------+-------+-------+---------+-----+-----+---------+
| MELPS-     |  8K  |  416 |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| 4500       |      |      |       |       |       |         |     |     |         |
+------------+------+------+-------+-------+-------+---------+-----+-----+---------+
| M16        |  4G  |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+------------+------+------+-------+-------+-------+---------+-----+-----+---------+
| M16C       |  1M  |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+------------+------+------+-------+-------+-------+---------+-----+-----+---------+

Tabelle 3.1: Adre·bereiche fÅr ORG --- Teil 1


+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| Ziel    |  CODE  | DATA |  IDATA  | XDATA | YDATA | BITDATA |   IO   | REG | ROMDATA |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| 4004    |   4K   |  256 |   ---   |  ---  |  ---  |   ---   |   ---  | --- |   ---   |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| 8008    |   16K  |   8  |   ---   |  ---  |  ---  |   ---   |   ---  | --- |   ---   |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| MCS-48, |   4K   |  --- |   256   |  256  |  ---  |   ---   |   ---  | --- |   ---   |
| MCS-41  |        |      |         |       |       |         |        |     |         |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| MCS-51  |   64K  |  256 |  256^*  |  64K  |  ---  |   256   |   ---  | --- |   ---   |
|         |        |      | In. 80H |       |       |         |        |     |         |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| 80C390  |   16M  |  256 |  256^*  |  16M  |  ---  |   256   |   ---  | --- |   ---   |
|         |        |      | In. 80H |       |       |         |        |     |         |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| MCS-251 |   16M  |  --- |   ---   |  ---  |  ---  |   ---   |   512  | --- |   ---   |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| MCS-96  |   64K  |  --- |   ---   |  ---  |  ---  |   ---   |   ---  | --- |   ---   |
| 196(N)/ |   16M  |      |         |       |       |         |        |     |         |
| 296     |        |      |         |       |       |         |        |     |         |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| 8080,   |   64K  |  --- |   ---   |  ---  |  ---  |   ---   |   256  | --- |   ---   |
| 8085    |        |      |         |       |       |         |        |     |         |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| 80x86,  |   64K  |  64K |   ---   |  64K  |  ---  |   ---   |   64K  | --- |   ---   |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| 68xx0   |   4G   |  --- |   ---   |  ---  |  ---  |   ---   |   ---  | --- |   ---   |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| 8X30x   |   8K   |  --- |   ---   |  ---  |  ---  |   ---   |   ---  | --- |   ---   |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| 2650    |   8K   |  --- |   ---   |  ---  |  ---  |   ---   |   ---  | --- |   ---   |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| XA      |   16M  |  16M |   ---   |  ---  |  ---  |   ---   |   2K   | --- |   ---   |
|         |        |      |         |       |       |         | In. 1K |     |         |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| AVR     |   8K   |  64K |   ---   |  ---  |  ---  |   ---   |   64   | --- |   ---   |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| 29XXX   |   4G   |  --- |   ---   |  ---  |  ---  |   ---   |   ---  | --- |   ---   |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| 80C166, |  256K  |  --- |   ---   |  ---  |  ---  |   ---   |   ---  | --- |   ---   |
| 80C167  |   16M  |      |         |       |       |         |        |     |         |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| Z80,    |   64K  |  --- |   ---   |  ---  |  ---  |   ---   |   256  | --- |   ---   |
| Z180,   | 512K^+ |      |         |       |       |         |   256  |     |         |
| Z380    |   4G   |      |         |       |       |         |   4G   |     |         |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| Z8      |   64K  |  256 |   ---   |  ---  |  ---  |   ---   |   ---  | --- |   ---   |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| eZ8     |   64K  |  256 |   ---   |  64K  |  ---  |   ---   |   ---  | --- |   ---   |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| KCPSM   |   256  |  256 |   ---   |  ---  |  ---  |   ---   |   ---  | --- |   ---   |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| ^* Da der 8051 kein RAM jenseits 80h hat, mu· der Initialwert fÅr den 8051           |
| als Zielprozessor auf jeden Fall mit ORG angepa·t werden!!                           |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+
| ^+ Da der Z180 weiterhin logisch nur 64K ansprechen kann, ist der                    |
| ganze Adre·raum nur mittels PHASE-Anweisungen erreichbar!                            |
+---------+--------+------+---------+-------+-------+---------+--------+-----+---------+

Tabelle 3.2: Adre·bereiche fÅr ORG --- Teil 2


+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| Ziel     | CODE | DATA | IDATA | XDATA | YDATA | BITDATA |  IO | REG | ROMDATA |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| KCPSM3   |  256 |  64  |  ---  |  ---  |  ---  |   ---   | 256 | --- |   ---   |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| Mico8    | 4096 |  256 |  ---  |  ---  |  ---  |   ---   | 256 | --- |   ---   |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| TLCS-    |  16M |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| 900(L)   |      |      |       |       |       |         |     |     |         |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| TLCS-90  |  64K |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| TLCS-    |  64K |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| 870      |      |      |       |       |       |         |     |     |         |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| TLCS-47  |  64K |  1K  |  ---  |  ---  |  ---  |   ---   |  16 | --- |   ---   |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| TLCS-    |  16M |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| 9000     |      |      |       |       |       |         |     |     |         |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| PIC      |  2K  |  32  |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| 16C5x    |      |      |       |       |       |         |     |     |         |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| PIC      |  2K  |  32  |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| 16C5x    |      |      |       |       |       |         |     |     |         |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| PIC      |      |      |       |       |       |         |     |     |         |
| 16C64,   |  8K  |  512 |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| 16C86    |      |      |       |       |       |         |     |     |         |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| PIC      |  64K |  256 |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| 17C42    |      |      |       |       |       |         |     |     |         |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| ST6      |  4K  |  256 |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| ST7      |  64K |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| ST9      |  64K |  64K |  ---  |  ---  |  ---  |   ---   | --- | 256 |   ---   |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| 6804     |  4K  |  256 |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| 32010    |  4K  |  144 |  ---  |  ---  |  ---  |   ---   |  8  | --- |   ---   |
| 32015    |  4K  |  256 |       |       |       |         |  8  |     |         |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| 320C2x   |  64K |  64K |  ---  |  ---  |  ---  |   ---   |  16 | --- |   ---   |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| 320C3x   |  16M |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| 320C5x/  |  64K |  64K |  ---  |  ---  |  ---  |   ---   | 64K | --- |   ---   |
| 320C20x/ |      |      |       |       |       |         |     |     |         |
| 320C54x  |      |      |       |       |       |         |     |     |         |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+
| TMS      |  64K |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| 9900     |      |      |       |       |       |         |     |     |         |
+----------+------+------+-------+-------+-------+---------+-----+-----+---------+

Tabelle 3.3: Adre·bereiche fÅr ORG --- Teil 3


+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+
| Ziel     |    CODE   | DATA | IDATA | XDATA | YDATA | BITDATA |  IO | REG | ROMDATA |
+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+
+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+
| TMS      |    64K    |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| 70Cxx    |           |      |       |       |       |         |     |     |         |
+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+
| 370xxx   |    64K    |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
|          |           |      |       |       |       |         |     |     |         |
+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+
| MSP430   |    64K    |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
|          |           |      |       |       |       |         |     |     |         |
+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+
| SC/MP    |    64K    |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+
| 807x     |    64K    |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+
| COP4     |    512    |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+
| COP8     |     8K    |  256 |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+
| ACE      |     4K    |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
|          | In. 800H/ |      |       |       |       |         |     |     |         |
|          |   0C00H   |      |       |       |       |         |     |     |         |
+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+
| ÊPD      |    64K    |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
| 78(C)10  |           |      |       |       |       |         |     |     |         |
+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+
| 75K0     |    16K    |  4K  |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+
| 78K0     |    64K    |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+
| 78K0     |     1M    |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+
| 7720     |    512    |  128 |  ---  |  ---  |  ---  |   ---   | --- | --- |   512   |
|          |           |      |       |       |       |         |     |     |         |
+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+
| 7725     |     2K    |  256 |  ---  |  ---  |  ---  |   ---   | --- | --- |   1024  |
|          |           |      |       |       |       |         |     |     |         |
+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+
| 77230    |     8K    |  --- |  ---  |  512  |  512  |   ---   | --- | --- |    1K   |
+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+
| 53C8XX   |     4G    |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+
| F^2MC8L  |    64K    |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+
| F^2MC16L |    16M    |  --- |  ---  |  ---  |  ---  |   ---   | --- | --- |   ---   |
+----------+-----------+------+-------+-------+-------+---------+-----+-----+---------+

Tabelle 3.4: Adre·bereiche fÅr ORG --- Teil 4



        3.2.2.  CPU
        - - - - - -

GÅltigkeit: alle Prozessoren

Mit  diesem Befehl wird  festgelegt, fÅr welchen  Prozessor im weiteren
Code  erzeugt werden  soll. Die  Befehle der  anderen Prozessorfamilien
sind dann nicht greifbar und erzeugen eine Fehlermeldung!

Die  Prozessoren kînnen grob  in Familien unterschieden  werden, in den
Familien  dienen unterschiedliche Typen noch einmal zur Feinunterschei-
dung:


    a)  68008 -> 68000 -> 68010 -> 68012 ->
        MCF5200 -> 68332 -> 68340 -> 68360 ->
        68020 -> 68030 -> 68040


In  dieser Familie  liegen die  Unterschiede in hinzukommenden Befehlen
und  Adressierungsarten  (ab  68020).  Eine  kleine Ausnahme stellt der
Schritt  zum 68030 dar, dem  2 Befehle fehlen: CALLM  und RTM. Die drei
Vertreter  der  683xx-Famile  haben  den  gleichen  Prozessorkern (eine
leicht  abgemagerte 68020-CPU), jedoch vîllig unterschiedliche Periphe-
rie.  MCF5200  reprÑsentiert  die  ColdFire-Familie  von  Motorola, zum
680x0  binÑr abwÑrtskompatible  RISC-Prozesoren. Beim  68040 kommen die
zusÑtzlichen  Steuerregister  (via  MOVEC  erreichbar)  fÅr On-Chip-MMU
und Caches sowie einige Systembefehle fÅr selbige hinzu.

    b) 56000 --> 56002 --> 56300

WÑhrend  der 56002  nur Befehle  zum Inkrementieren  und Dekrementieren
der  Akkus ergÑnzt, ist der 56300-Kern  schon fast ein neuer Prozessor:
Er  vergrî·ert alle Adre·rÑume  von 64K-Wîrtern auf  16M und verdoppelt
fast die Anzahl der Befehle.

    c) PPC403 -> PPC403GC -> MPC505 -> MPC601 -> RS6000

Der  PCC403 ist eine abgespeckte  Version der PowerPC-Linie ohne Gleit-
kommaeinheit,  demzufolge sind sÑmtliche  Gleitkommabefehle bei ihm ge-
sperrt;  dafÅr sind  einige mikrocontrollerspezifische  Befehle enthal-
ten,  die er  als einziges  Mitglied in  dieser Familie  kennt. Die GC-
Variante  des PPC403 hat zusÑtzlich eine  MMU und deshalb einige Befeh-
le  zu deren Steuerung mehr.  Der MPC505 (eine Mikrokontroller-Variante
mit  FPU) unterscheidet sich solange vom 601er nur in den Peripheriere-
gistern,  wie ich es nicht  besser wei· - [58]  hÑlt sich da noch etwas
bedeckt...  Die RS6000-Reihe  kennt noch  einige Befehle  mehr (die auf
vielen  601er-Systemen emuliert werden,  um vollstÑndige KompatibilitÑt
herzustellen),  au·erdem verwendet IBM z.T.  andere Mnemonics fÅr diese
reinen   Workstation-Prozessoren,   als   Remineszenz   an  die  370er-
Gro·rechner...

    d) MCORE


    e) XGATE


    f) 6800 -> 6301 -> 6811

WÑhrend  der 6301  nur neue  Befehle definiert,  liefert der 6811 neben
weiteren Befehlen ein zweites Indexregister Y zur Adressierung.

    g) 6809/6309 und 6805/68HC08/68HCS08

Diese  Prozessoren sind zwar teilweise quellcodekompatibel zu den ande-
ren  68xx-ern, haben aber  ein anderes BinÑrcodeformat  und einen deut-
lich  eingeschrÑnkteren  (6805)  bzw.  erweiterten  (6809) Befehlssatz.
Der  6309 ist eine CMOS-Version des 6809, die zwar offiziell nur kompa-
tibel  zum 6809 ist,  inoffiziell aber mehr  Register und deutlich mehr
Befehle besitzt (siehe [37]).

    h) 68HC12 --> 68HC12X

Der  12X-Kern bietet eine Reihe  neuer Befehle, bzw. bestehende Befehle
wurden um neue Adressierungsarten ergÑnzt.

    i) 68HC16


    j) HD6413308 --> HD6413309

Diese  beiden Namen reprÑsentieren die 300er und 300H-Varianten der H8-
Familie;  die  H-Version  besitzt  dabei  einen  grî·eren Adre·raum (16
Mbyte  statt 64Kbyte),  doppelt so  breite Register  (32 Bit) und kennt
einige  zusÑtzliche  Befehle  und  Adressierungsarten. Trotzdem ist sie
binÑr aufwÑrtskompatibel.

    k) HD6475328 --> HD6475348 --> HD6475368 --> HD6475388

Diese  Prozessoren  besitzen  alle  den  gleichen  CPU-Kern; Die unter-
schiedlichen  Typen dienen lediglich der Einbindung des korrekten Regi-
stersatzes in der Datei REG53X.INC.

    l) SH7000 --> SH7600 --> SH7700

Der  Prozessorkern des 7600ers  bietet eine Handvoll  Befehle mehr, die
LÅcken  im Befehlssatz des 7000ers  schlie·en (verzîgerte, bedingte so-
wie  relative  und  indirekte  SprÅnge,  Multiplikationen  mit  32-Bit-
Operanden  sowie  Multiplizier/Addier-Befehle).  Die 7700er-Reihe (auch
als  SH3 gelÑufig)  bietet weiterhin  eine zweite Registerbank, bessere
Schiebebefehle sowie Befehle zur Cache-Steuerung.

    m) 6502 -> 65(S)C02 / MELPS740

Die  CMOS-Version definiert  einige zusÑtzliche  Befehle, au·erdem sind
bei  einigen Befehlen  Adressierungsarten hinzugekommen,  die beim 6502
nicht  mîglich waren. Die  Mitsubishi-Mikrokontroller dagegen erweitern
den  6502-Befehlssatz in erster Linie um Bitoperationen und Multiplika-
tions-/Divisionsbefehle.  Bis  auf  den  unbedingten Sprung und Befehle
zur  Inkrementierung/Dekremetierung des  Akkumulatos sind  die Erweite-
rungen  disjunkt.  Dem  65SC02  fehlen  die Bitmanipulationsbefehle des
65C02.  Mit  dem  Prozessortyp  6502UNDOC sind die ,,undokumentierten''
6502-Befehle  erreichbar, d.h. die  Operationen, die sich  bei der Ver-
wendung  nicht als Befehle definierter Bitkombinationen im Opcode erge-
ben.  Die von AS  unterstÅtzten Varianten sind  im Kapitel mit den pro-
zessorspezifischen Hinweisen beschrieben.

    n) MELPS7700, 65816

Neben  einer  ,,16-Bit-Version''  des  6502-Befehlssatzes  bieten diese
Prozessoren    einige    Befehlserweiterungen.    Diese    sind    aber
grî·erenteils  disjunkt,  da  sie  sich  an ihren jeweiligen 8-bittigen
Vorbildern  (65C02 bzw. MELPS-740)  orientieren. Z.T.~werden auch ande-
re Mnemonics fÅr gleiche Befehle verwendet.

    o) MELPS4500


    p) M16


    q) M16


    r) 4004 -> 4040

Der   4040  besitzt  gegenÅber  seinem   VorgÑnger  ein  gutes  Dutzend
zusÑtzlicher Maschineninstruktionen.

    s) 4008 -> 8008NEW

Intel  hat  1975  die  Mnemonics  des  umdefiniert, die zweite Variante
spiegelt  diesen  neuen  Befehlssatz  wieder.  Eine  gleichzeitige  Un-
terstÅtzung   beider   Varianten   war   nicht  mîglich,  da  teilweise
öberschneidungen vorliegen.

    t) 8021, 8022, 8039, 80C39, 8048, 80C48, 8041, 8042

Bei  den ROM-losen Versionen 8039 und  80C39 sind die Befehle verboten,
die  den BUS (Port 0) ansprechen.  Der 8021 und 8022 sind Sonderversio-
nen  mit  stark  abgemagertem  Befehlssatz,  wofÅr  der  8022 zwei A/D-
Wandler   und  die  dazugehîrigen   Steuerbefehle  enthÑlt.  Die  CMOS-
Versionen  lassen sich mit dem  IDL-Befehl in einen Ruhezustand niedri-
ger  Stromaufnahme ÅberfÅhren. Der 8041 und 8042 haben einige Zusatzbe-
fehle  zur Steuerung der Busschnittstelle, dafÅr fehlen aber einige an-
dere  Befehle.  DarÅber  hinaus  ist  bei  diesen  Prozessoren der Pro-
grammadre·raum  nicht  extern  erweiterbar,  weshalb AS das Codesegment
bei diesen Prozessoren auf 1 bzw. 2 Kbyte begrenzt.


    u)  87C750 -> 8051, 8052, 80C320, 80C501, 80C502,
        80C504, 80515, and 80517
        -> 80C390
        -> 80C251


Der  87C750 kann  nur max.  2 Kbyte  Programmspeicher adressieren, wes-
halb  die LCALL-  und LJMP-Befehle  bei ihm  fehlen. Zwischen  den acht
mittleren  Prozessoren nimmt  AS selber  Åberhaupt keine Unterscheidung
vor,  sondern verwaltet den Unterschied lediglich in der Variablen MOM-
CPU  (s.u.),  die  man  mit  IF-Befehlen  abfragen  kann. Eine Ausnahme
stellt  lediglich der 80C504, der in  seiner momentanen Form noch einen
Maskenfehler  zeigt, wenn eine AJMP-  oder ACALL-Anweisung auf der vor-
letzten  Adresse  einer  2K-Seite  steht.  AS  benutzt in einem solchen
Fall  automatisch  lange  Sprungbefehle  bzw.  gibt  eine Fehlermeldung
aus.  Der 80C251 hingegen stellt einen drastischen Fortschritt in Rich-
tung  16/32  Bit,  grî·erer  Adre·rÑume  und orthogonalerem Befehlssatz
dar.  Den 80C390 kînnte man vielleicht als die 'kleine Lîsung' bezeich-
nen:  Dallas Semiconductor hat den  Befehlssatz und die Architektur nur
so  weit verÑndert, wie  es fÅr die  16 MByte gro·en Adre·rÑume notwen-
dig war.

    v) 8096 -> 80196 -> 80196N -> 80296

Neben  einem anderen  Satz von  SFRs (die  Åbrigens von Unterversion zu
Unterversion   stark  differieren)  kennt  der  80196  eine  Reihe  von
zusÑtzlichen  Befehlen  und  kennt  einen ,,Windowing''-Mechanismus, um
das  grî·ere interne RAM anzusprechen.  Die 80196N-Familie wiederum er-
weitert  den Adre·raum auf  16 Mbyte und  fÅhrt eine Reihe von Befehlen
ein,  mit denen man auf Adressen  jenseits 64 Kbyte zugreifen kann. Der
80296  erweitert  den  CPU-Kern  um  Befehle zur Signalverarbeitung und
ein  zweites Windowing-Register,  verzichtet jedoch  auf den Peripheral
Transaction  Server (PTS)  und verliert  damit wieder zwei Maschinenbe-
fehle.

    w) 8080 -> 8085 -> 8085UNDOC

Der  8085 kennt zusÑtzlich die Befehle RIM  und SIM zum Steuern der In-
terruptmaske   und  der  zwei  I/O-Pins.  Der  Typ  8085UNDOC  schaltet
zusÑtzliche,  nicht von Intel dokumentierte  Befehle ein. Diese Befehle
sind in Abschnitt 4.15 dokumentiert.

    x) 8086 -> 80186 -> V30 -> V35

Hier  kommen wieder nur neue  Befehle dazu. Die entsprechenden 8-Bitter
sind  wegen ihrer BefehlskompatibilitÑt nicht aufgefÅhrt, fÅr ein 8088-
System ist also z.B. 8086 anzugeben.

    y) 80960


    z) 8X300 -> 8X305

Der  8X305  besitzt  eine  Reihe  zusÑtzlicher Arbeitsregister, die dem
8X300   fehlen  und  kann  mit   diesen  auch  zusÑtzliche  Operationen
ausfÅhren,  wie das direkte Schreiben  von 8-Bit-Werten auf Peripherie-
adressen.

    aa) XAG1, XAG2, XAG3

Diese  Prozessoren unterscheiden sich nur  in der Grî·e des eingebauten
ROMs, die in STDDEFXA.INC definiert ist.

    ab)  AT90S1200 -> AT90S2313 -> AT90S4414  -> AT90S8515 -> ATMEGA8 -
    > ATMEGA16

Der  erste  Vertreter  der  AVR-Reihe  stellt  die Minimalkonfiguration
dar,  ohne  RAM-Speicher  und  demzufolge auch ohne Load/Store-Befehle.
Die  nÑchsten drei  Prozessoren unterscheiden  sich nur im Speicheraus-
bau  und  in  der  eingebauten  Peripherie, was in REGAVR.INC differen-
ziert  wird. éhnlich verhÑlt  es sich mit  den Mega-AVRs, die gegenÅber
den VorgÑngern aber auch neue Maschinenbefehle mitbringen.

    ac) AM29245 -> AM29243 -> AM29240 -> AM29000

Je  weiter man sich in der Liste  nach rechts bewegt, desto weniger Be-
fehle  mÅssen in Software emuliert werden.  WÑhrend z.B. der 29245 noch
nicht  einmal einen Hardware-Multiplizierer  besitzt, fehlen den beiden
Vertretern  in der Mitte nur die Gleitkommabefehle. Der 29000 dient da-
bei als ,,generischer'' Typ, der alle Befehle in Hardware versteht.

    ad) 80C166 --> 80C167,80C165,80C163

80C167  und  80C165/163  haben  anstelle  256  Kbyte  max. 16 Mbyte Ad-
re·raum,  au·erdem kennen sie einige  zusÑtzliche Befehle fÅr erweiter-
te  Adressierungsmodi sowie atomare Befehlssequenzen. Untereinander un-
terscheiden  sich diese  Prozessoren der  ,,zweiten Generation'' nur in
der eingebauten Peripherie.

    ae) Z80 -> Z80UNDOC -> Z180 -> Z380

WÑhrend  fÅr  den  Z180  nur  die  zusÑtzlichen  Befehle definiert sind
(d.h.  die Z180-MMU  findet noch  keine BerÅcksichtigung),  besitzt der
Z380  32-Bit-Register, einen linearen  4Gbyte-Adre·raum sowie neben ei-
ner  Reihe von  Befehlserweiterungen, die  den Befehlssatz deutlich or-
thogonaler  machen, neue  Adressierungsmodi (Ansprechen  der Indexregi-
sterhÑlften,  Stack-relativ).  Zu  einem  kleinen Teil existieren diese
Erweiterungen  aber auch  schon beim  Z80 als  undokumentierte Befehle,
die  mit der Variante  Z80UNDOC zugeschaltet werden  kînnen. Eine Liste
mit  den zusÑtzlichen Befehlen  findet sich im  Kapitel mit den prozes-
sorspezifischen Hinweisen.

    af) Z8601, Z8604, Z8608, Z8630, Z8631 -> eZ8

Die  Varianten  mit  Z8-Kern  unterscheiden  sich nur in Speicherausbau
und  Peripherie, d.h.  die Wahl  hat auf  den unterstÅtzten Befehlssatz
keinen  Effekt. Deutlich anders ist jedoch der eZ8, mit einem stark er-
weiterten  Befehlssatz,  der  auch  nur  auf  Quellebene  weitestgehens
aufwÑrts-kompatibel ist.

    ag) KCPSM, KCPSM3

Bei  beiden  Prozessorkernen  handelt  es  sich um keine eigenstÑndigen
Bausteine,  sondern Logik-Kerne  fÅr Gate-Arrays  der Firma Xilinx. Die
3er-Variante  bietet einen grî·eren  Adre·raum sowie einige zusÑtzliche
Instruktionen.    Es   ist   zu   beachten,   da·   sie   nicht   binÑr
aufwÑrtskompatibel ist!

    ah) MICO8


    ai) 96C141, 93C141

Diese  beiden Prozessoren reprÑsentieren die  beiden Varianten der Pro-
zessorfamilie:  TLCS-900 und TLCS-900L.  Die Unterschiede dieser beiden
Varianten werden in Abschnitt 4.22 genauer beleuchtet.

    aj) 90C141


    ak) 87C00, 87C20, 87C40, 87C70

Die  Prozessoren  der  TLCS-870-Reihe  haben  zwar den identischen CPU-
Kern,  je nach  Variante aber  eine unterschiedliche Peripherieausstat-
tung.  Zum Teil  liegen Register  gleichen Namens auf unterschiedlichen
Adressen.  Die  Datei  STDDEF87.INC  benutzt  analog zur MCS-51-Familie
die  hier mîgliche Unterscheidung, um automatisch den korrekten Symbol-
satz bereitzustellen.

    al) 47C00 -> 470C00 -> 470AC00

Diese  drei Varianten  der TLCS-47-Familie  haben unterschiedlich gro·e
RAM-und  ROM-Adre·bereiche, wodurch jeweils einige Befehle zur Bankums-
chaltung hinzukommen oder wegfallen.

    am) 97C241


    an) 16C54 -> 16C55 -> 16C56 -> 16C57

Diese  Prozessoren unterscheiden  sich durch  den verfÅgbaren Adre·raum
im  Programmspeicher, d.h. durch  die Adresse, ab  der der AS öberlÑufe
anmeckert.

    ao) 16C64, 16C84

Analog  zur MCS-51-Familie findet hier  keine Unterscheidung im Codege-
nerator  statt, die unterschiedlichen Nummern dienen lediglich der Ein-
blendung der korrekten SFRs in STDDEF18.INC.

    ap) 17C42


    aq) ST6210/ST6215 -> ST6220/ST6225

Die  einzige  Unterscheidung,  die  AS  zwischen den beiden Paaren vor-
nimmt,  ist der bei  den ersten beiden  kleinere Adre·raum (2K anstelle
4K).  Die Feinunterscheidung dient  zur automatischen Unterscheidung in
der  Quelldatei,  welche  Hardware  jeweils  vorhanden  ist (analog zum
8051/52/515).

    ar) ST7


    as) ST9020, ST9030, ST9040, ST9050

Diese  4  Namen  vetreten  die  vier ,,Unterfamilien'' der ST9-Familie,
die   sich  durch   eine  unterschiedliche   Ausstattung  mit  On-Chip-
Peripherie  auszeichen.  Im  Prozessorkern  sind  sie identisch, so da·
diese  Unterscheidung  wieder  nur  im  Includefile mit den Peripherie-
adressen zum Zuge kommt.

    at) 6804


    au) 32010 -> 32015

Der  TMS32010 besitzt  nur 144  Byte internes  RAM, weshalb AS Adressen
im  Datensegment auf eben  diesen Bereich begrenzt.  FÅr den 32015 gilt
diese  BeschrÑnkung nicht, es  kann der volle  Bereich von 0--255 ange-
sprochen werden.

    av) 320C25 -> 320C26 -> 320C28

Diese  Prozessoren  unterscheiden  sich  nur  leicht  in  der  On-Chip-
Peripherie sowie den Konfigurationsbefehlen.

    aw) 320C30, 320C31

Der  320C31 ist eine etwas ,,abgespeckte'' Version mit dem gleichen Be-
fehlssatz,  jedoch weniger  Peripherie. In  STDDEF3X.INC wird diese Un-
terscheidung ausgenutzt.

    ax) 320C203 -> 320C50, 320C51, 320C53

Ersterer    ist    der    generelle    ReprÑsentant   fÅr   die   C20x-
Signalprozessorfamilie,  die eine Untermenge  des C5x-Befehlssatzes im-
plementieren.   Die  Unterscheidung  zwischen  den  verschiedenen  C5x-
Prozessoren wird von AS momentan nicht ausgenutzt.

    ay) 320C541

Dies ist momentan der PeprÑsentant fÅr die TMS320C54x-Familie...

    az) TMS9900



    ba) TMS70C00, TMS70C20, TMS70C40,
        TMS70CT20, TMS70CT40,
        TMS70C02, TMS70C42, TMS70C82,
        TMS70C08, TMS70C48


Alle  Mitglieder  dieser  Familie  haben  den gleichen CPU-Kern, unter-
scheiden  sich im Befehlssatz also  nicht. Die Unterschiede finden sich
nur  in der Datei REG7000.INC,  in der Speicherbereiche und Peripherie-
adressen  definiert werden. Die  in einer Zeile  stehenden Typen besit-
zen  jeweils gleiche  Peripherie und  gleiche interne RAM-Menge, unter-
scheiden sich also nur in der Menge eingebauten ROMs.

    bb) 370C010, 370C020, 370C030, 370C040 und 370C050

Analog  zur MCS-51-Familie  werden die  unterschiedlichen Typen nur zur
Unterscheidung  der  Peripherie  in  STDDEF37.INC genutzt, der Befehls-
satz ist identisch.

    bc) MSP430


    bd) SC/MP


    be) 8070

Dieser  PRozessor  reprÑsentiert  die  gesamte 807x-Familie (die minde-
stens  aus den 8070, 8072 und  8073 besteht), der jedoch ein einheitli-
cher CPU-Kern gemeinsam ist.

    bf) COP87L84

Dies  ist das  momentan einzige  unterstÅtzte Mitglied der COP8-Familie
von  National Semiconductor. Mir  ist bekannt, da·  die Familie wesent-
lich  grî·er ist und auch Vertreter mit unterschiedlich gro·em Befehls-
satz  existieren, die nach  Bedarf hinzukommen werden.  Es ist eben ein
Anfang,  und  die  Dokumentation  von  National  ist  ziemlich  umfang-
reich...

    bg)  COP410 -> COP420 Die COP42x-Derivate bieten einige weitere Be-
    fehle,  des weiteren  wurden Befehlen  in ihrem Wertebereich erwei-
    tert.



    bh) SC14400, SC14401, SC14402, SC14404, SC14405,
        SC14420, SC14421, SC14422, SC14424


Diese  Gruppe von DECT-Controller unterscheidet  sich in ihrem Befehls-
umfang,  da  jeweils  unterschiedliche  B-Feld Datenformate unterstÅtzt
werden und deren Architektur im Laufe der Zeit optimiert wurde.

    bi) 7810 -> 78C10

Die  NMOS-Version  besitzt  keinen  STOP-Modus; der entspechende Befehl
sowie  das ZCM-Register  fehlen demzufolge.  VORSICHT! NMOS-  und CMOS-
Version differieren zum Teil in den Reset-Werten einiger Register!


    bj) 75402,
        75004, 75006, 75008,
        75268,
        75304, 75306, 75308, 75312, 75316,
        75328,
        75104, 75106, 75108, 75112, 75116,
        75206, 75208, 75212, 75216,
        75512, 75516


Dieses  ,,FÅllhorn'' an Prozessoren  unterscheidet sich innerhalb einer
Gruppe  nur durch die RAM- und ROM-Grî·e; die Gruppen untereinander un-
terscheiden  sich einmal durch ihre  on-chip-Peripherie und zum anderen
durch die MÑchtigkeit des Befehlssatzes.

    bk) 78070

Dies  ist  das  einzige,  mir  momentan  vertraute  Mitglied  der 78K0-
Familie von NEC. Es gelten Ñhnliche Aussagen wie zur COP8-Familie!

    bl) 78214

Dies ist momentan der ReprÑsentant der 78K2-Familie von NEC.

    bm) 7720 -> 7725

Der  ÊPD7725  bietet  im  Vergleich  zu  seinem  VorgÑnger  grî·ere Ad-
re·rÑume  und  einige  zusÑtzliche  Befehle.  VORSICHT! Die Prozessoren
sind nicht zueinander binÑrkompatibel!

    bn) 77230



    bo) SYM53C810, SYM53C860, SYM53C815, SYM53C825,
        SYM53C875, SYM53C895


Die  einfacheren Mitglieder dieser  Familie von SCSI-Prozessoren besit-
zen  einige Befehlsvarianten nicht, au·erdem  unterscheiden sie sich in
ihrem Satz interner Register.

    bp) MB89190

Dieser Prozessortyp reprÑsentiert die F^2MC8L-Serie von Fujitsu...

    bq) MB9500

...so  wie  dieser  es  momentan  fÅr  die 16-Bit-Varianten von Fujitsu
tut!

Beim  CPU-Befehl mu· der Prozessortyp  als einfache Konstante angegeben
werden, eine Berechnung Ö la

        CPU     68010+10

ist also nicht zulÑssig. GÅltige Aufrufe sind z.B.

        CPU     8051

oder

        CPU     6800

Egal,  welcher Prozessortyp  gerade eingestellt  ist, in der Integerva-
riablen  MOMCPU  wird  der  momentane  Status als Hexadezimalzahl abge-
legt.  FÅr  den  68010  ist  z.B.  MOMCPU=$68010,  fÅr  den 80C48 MOMC-
PU=80C48H.  Da man Buchstaben au·er  A..F nicht als Hexziffer interpre-
tieren  kann, mu·  man sich  diese bei  der Hex-Darstellung des Prozes-
sors wegdenken. FÅr den Z80 ist z.B. MOMCPU=80H.

Dieses  Feature kann man  vorteilhaft einsetzen, um  je nach Prozessor-
typ  unterschiedlichen Code zu erzeugen. Der 68000 z.B. kennt noch kei-
nen  Befehl  fÅr  den  UnterprogrammrÅcksprung mit Stapelkorrektur. Mit
der  Variablen MOMCPU kann  man ein Makro  definieren, das je nach Pro-
zessortyp den richtigen Befehl benutzt oder ihn emuliert:

myrtd   MACRO   disp
        IF      MOMCPU$<$68010   ; auf 68008 und
         MOVE.L (sp),disp(sp)    ; 68000 emulieren
         LEA    disp(sp),sp
         RTS
        ELSEIF
         RTD    #disp            ; ab 68010 direkt
        ENDIF                    ; benutzen
        ENDM

        CPU     68010
        MYRTD   12               ; ergibt RTD #12

        CPU     68000
        MYRTD   12               ; ergibt MOVE.. /
                                 ; LEA.. / RTS

Da  nicht alle Prozessornamen  nur aus Ziffern  und Buchstaben zwischen
A  und  F  bestehen,  wird  zusÑtzlich  der  volle  Name in der String-
Variablen MOMCPUNAME abgelegt.

Implizit  schaltet der Assembler  mit dem CPU-Befehl  das aktuelle Seg-
ment  wieder auf Code zurÅck, da dies  das einzige Segment ist, das al-
le Prozessoren definieren.

Default  fÅr den Prozessortyp ist 68008, sofern dieser Åber die gleich-
namige Kommandozeilenoption nicht verÑndert wurde.


        3.2.3. SUPMODE, FPU, PMMU
        - - - - - - - - - - - - -


GÅltigkeit: 680x0, FPU auch 80x86, i960, SUPMODE auch TLCS-900,
            SH7000, i960, 29K, XA, PowerPC, M*CORE und TMS9900


Mit  diesen drei Schaltern  kann bestimmt werden,  auf welche Teile des
Befehlssatzes  verzichtet werden soll, weil die dafÅr nîtigen Vorbedin-
gungen  im folgenden  CodestÅck nicht  gegeben sind.  Als Parameter fÅr
diese  Befehle darf entweder  ON oder OFF  gegeben werden, der momentan
gesetzte  Zustand kann aus einer  Variablen ausgelesen werden, die ent-
weder TRUE oder FALSE ist.

Die Befehle bedeuten im einzelnen folgendes:

  - SUPMODE:  erlaubt  bzw.  sperrt  Befehle,  fÅr deren AusfÅhrung der
    Prozessor  im Supervisorstatus  sein mu·.  Die Statusvariable hei·t
    INSUPMODE.
  - FPU:  erlaubt bzw. sperrt die  Befehle des numerischen Koprozessors
    8087 bzw. 68881/68882. Die Statusvariable hei·t FPUAVAIL.
  - PMMU:  erlaubt bzw. sperrt  die Befehle der Speicherverwaltungsein-
    heit  68851 bzw. der im 68030  eingebauten MMU. ACHTUNG! Die 68030-
    MMU  erlaubt  nur  eine  rel.  kleine Untermenge der 68851-Befehle.
    Der  Assembler kann hier keine  PrÅfung vornehmen! Die Statusvaria-
    ble hei·t PMMUAVAIL.

Benutzung  von auf diese Weise  gesperrten Befehlen erzeugt bei SUPMODE
eine Warnung, bei PMMU und FPU eine echte Fehlermeldung.


        3.2.4. FULLPMMU
        - - - - - - - -

GÅltigkeit: 680x0

Motorola  hat zwar ab  dem 68030 die  PMMU in den Prozessor integriert,
diese  aber nur mit  einer Funktionsuntermenge der  externen PMMU 68851
ausgestattet.  AS sperrt  bei aktiviertem  PMMU-Befehlssatz (s.o.) des-
halb  alle fehlenden Befehle,  wenn als Zielprozessor  68030 oder hîher
eingestellt  wurde.  Nun  kann  es  aber  sein, da· in einem System mit
68030-Prozessor  die interne  MMU abgeschaltet  wurde und der Prozessor
mit  einer externen 68851  betrieben wird. Mit  FULLPMMU ON kann man AS
dann  mitteilen, da·  der vollstÑndige  MMU-Befehlssatz zugelassen ist.
Umgekehrt  kann  man,  wenn  man  portablen  Code  erzeugen  will, alle
zusÑtzlichen  Befehle  trotz  68020-Zielplattform  mit FULLPMMU OFF ab-
schalten.  Die Umschaltung  darf beliebig  oft erfolgen,  die momentane
Einstellung  kann  aus  einem  gleichnamigen  Symbol ausgelesen werden.
ACHTUNG!  Der  CPU-Befehl  besetzt  fÅr  680x0-Argumente implizit diese
Einstellung  vor! FULLPMMU mu· also auf  jeden Fall nach dem CPU-Befehl
kommen!


        3.2.5.  PADDING
        - - - - - - - -

GÅltigkeit: 680x0, M*Core, XA, H8, SH7000, TMS9900, MSP430, ST7

Prozessoren  der 680x0-Familie stehen  ungeraden Adressen ziemlich kri-
tisch  gegenÅber: Befehle dÅrfen nicht  auf einer ungeraden Adresse be-
ginnen,  und Datenzugriffe  sind mit  ungeraden Adressen  bis zum 68010
nur  byteorientiert erlaubt. Die H8-Familie setzt bei Zugriffen auf un-
gerade  Adressen  das  unterste  Adre·bit  einfach  ganz  auf Null, die
500er  ,,bedanken''  sich  wiederum  mit  einer  Exception... AS bemÅht
sich  daher, mit DC  oder DS angelegte  Datenstrukturen immer mit einer
geraden  Bytezahl  abzulegen.  Das  bedeutet  bei den Befehlen DS.B und
DC.B  aber unter UmstÑnden, da· ein FÅllbyte eingefÅgt werden mu·. Die-
ses  Verhalten kann  man mit  dem PADDING-Befehl  ein- und ausschalten.
Als  Argument ist  analog zu  den vorherigen  Befehlen ON  oder OFF er-
laubt,  und die augenblickliche Einstellung  kann aus dem gleichnamigen
Symbol  ausgelesen werden. DefaultmÑ·ig ist  PADDING nur fÅr die 680x0-
Familie  eingeschaltet, fÅr  alle anderen  werden erst nach Umschaltung
Padding-Bytes eingefÅgt!


        3.2.6.  PACKING
        - - - - - - - -

GÅltigkeit: AVR

PACKING  ist in gewisser Weise Ñhnlich  zu PADDING, es arbeitet nur ge-
wisserma·en   anders  herum:  wÑhrend   PADDING  die  abgelegten  Daten
ergÑnzt,  um  komplette  Worte  und  damit  ein  Alignment zu erhalten,
quetscht  PACKING mehrere  Werte in  ein einzelnes  Wort. Dies macht im
Code-Segment  des AVR  Sinn, weil  dort mit  einem Spezialbefehl ( LPM)
auf  einzelne Bytes in  den 16-Bit-Worten zugegriffen  werden kann. Ist
diese  Option eingeschaltet (Argument  ON), so werden  immer zwei Byte-
Werte  bei DATA  in ein  Wort gepackt,  analog zu den einzelnen Zeichen
von  String-Argumenten.  Der  Wertebereich  der Integer-Argumente redu-
ziert  sich dann  natÅrlich auf  -128...+255. Ist  diese Option dagegen
ausgeschaltet,  (Argument OFF), so  bekommt jedes Integer-Argument sein
eigenes Wort und darf auch Werte von -32768...+65535 annehmen.

Diese  Unterscheidung betrifft nur  Integer-Argumente von DATA, Strings
werden  immer  gepackt.  Zu  beachten  ist weiterhin, da· dieses Packen
nur  innerhalb  der  Argumente  eines  DATA-Befehls funktionieren kann,
wer  also mehrere DATA-Befehle hinterienander hat, fÑngt sich bei unge-
raden Argumentzahlen trotzdem halbvolle Wîrter ein!


        3.2.7.  MAXMODE
        - - - - - - - -

GÅltigkeit: TLCS-900, H8

Die  Prozessoren der  TLCS-900-Reihe kînnen  in 2  Betriebsarten arbei-
ten,  dem  Minimum-und  Maximum-Modus.  Je  nach momentaner Betriebsart
gelten  fÅr den  Betrieb und  den Assembler  etwas andere Eckwerte. Mit
diesem  Befehl und  den Parametern  ON oder  OFF teilt  man AS mit, da·
der  folgende Code im Maximum- oder Minimum-Modus ablÑuft. Die momenta-
ne  Einstellung  kann  aus  der  Variablen INMAXMODE ausgelesen werden.
Voreinstellung ist OFF, d.h. Minimum-Modus.

Analog  dazu teilt man im H8-Modus AS mit diesem Befehl mit, ob mit ei-
nem  64K-  oder  16Mbyte-Adre·raum  gearbeitet  wird. FÅr den einfachen
300er  ist diese  Einstellung immer  OFF und  kann nicht verÑndert wer-
den.


        3.2.8.  EXTMODE und LWORDMODE
        - - - - - - - - - - - - - - -

GÅltigkeit: Z380

Der  Z380 kann  in insgesamt  4 Betriebsarten  arbeiten, die sich durch
die  Einstellung von 2 Flags ergeben: Das XM-Flag bestimmt, ob der Pro-
zessor  mit einem 64 Kbyte oder  4 Gbyte gro·en Adre·raum arbeiten soll
und  kann nur gesetzt werden (nach  einem Reset steht es Z80-kompatibel
auf  0). DemgegenÅber legt das LW-Flag  fest, ob Wort-Befehle mit einer
WortlÑnge  von 16 oder 32 Bit arbeiten sollen. Die Stellung dieser bei-
den  Flags beeinflu·t WertebereichseinschrÑnkungen  von Konstanten oder
Adressen,  weshalb man AS Åber diese beiden Befehle deren Stellung mit-
teilen  mu·. Als  Default nimmt  AS an,  da· beide  Flags auf 0 stehen,
die  momentane Einstellung  (ON oder  OFF) kann  aus den vordefinierten
Variablen INEXTMODE bzw. INLWORDMODE ausgelesen werden.


        3.2.9.  SRCMODE
        - - - - - - - -

GÅltigkeit: MCS-251

Intel  hat den Befehlssatz  der 8051er beim  80C251 deutlich erweitert,
hatte  aber leider nur noch einen  einzigen freien Opcode fÅr diese Be-
fehle  frei. Damit  der Prozessor  nicht auf  alle Ewigkeit durch einen
PrÑfix  behindert bleibt, hat Intel  zwei Betriebsarten vorgesehen: Den
BinÑr-  und den Quellmodus. Im BinÑrmodus  ist der Prozessor voll 8051-
kompatibel,  alle erweiterten Befehle benîtigen  den noch freien Opcode
als  PrÑfix. Im Quellmodus  tauschen diese neuen  Befehle ihre Position
in  der Code-Tabelle mit  den entsprechenden 8051-Instruktionen, welche
dann  wiederum mit einem PrÑfix versehen  werden mÅssen. Damit AS wei·,
wann  er PrÑfixe setzen mu· und wann  nicht, mu· man ihm mit diesem Be-
fehl  mitteilen, ob  der Prozessor  im Quellmodus  (ON) oder BinÑrmodus
(OFF)  betrieben wird. Die  momentane Einstellung kann  man aus der Va-
riablen INSRCMODE auslesen. Der Default ist OFF.


        3.2.10. BIGENDIAN
        - - - - - - - - -

GÅltigkeit: MCS-51/251, PowerPC

Bei  den Prozessoren der 8051-Serie  ist Intel seinen eigenen Prinzipi-
en  untreu geworden: Der Prozessor  verwendet entgegen jeglicher Tradi-
tion  eine  Big-Endian-Orientierung  von  Mehrbytewerten!  WÑhrend dies
bei  den MCS-51-Prozessoren noch  nicht gro·artig auffiel,  da der Pro-
zessor  ohnehin nur  8-bittig auf  Speicherzellen zugreifen konnte, man
sich  die  Byte-Anordnung  bei  eigenen  Datenstrukturen also aussuchen
konnte,  ist dies beim MCS-251 nicht mehr so, er kann auch ganze (Lang-
)Worte  aus dem  Speicher lesen  und erwartet  dabei das MSB zuerst. Da
dies  nicht der bisherigen Arbeitsweise  von AS bei der Konstantenabla-
ge  entspricht, kann man  nun mit diesem  Befehl umschalten, ob die Be-
fehle  DB, DW, DD,  DQ und DT  mit Big- oder Little-Endian-Orientierung
arbeiten  sollen.  Mit  BIGENDIAN  OFF  (Voreinstellung)  wird  wie bei
Ñlteren  AS-Versionen zuerst das niederwertigste Byte abgelegt, mit BI-
GENDIAN  ON  wird  die  MCS-251-kompatible  Variante benutzt. NatÅrlich
kann  man diese Einstellung beliebig oft  im Code Ñndern; die momentane
Einstellung kann aus dem gleichnamigen Symbol ausgelesen werden.


        3.2.11.  WRAPMODE
        - - - - - - - - -

GÅltigkeit: Atmel AVR

Ist  dieser Schalter auf ON gesetzt, so veranla·t man AS dazu, anzuneh-
men,  der  ProgrammzÑhler  des  Prozessors  habe nicht die volle, durch
die  Architektur gegebene  LÑnge von  16 Bits,  sondern nur eine LÑnge,
die  es gerade eben  erlaubt, das interne  ROM zu adressieren. Im Falle
des  AT90S8515 sind  dies z.B.  12 Bit,  entsprechend 4  KWorten oder 8
KBytes.  Damit werden  relative SprÅnge  vom Anfang  des ROMs  zum Ende
und  umgekehrt  mîglich,  die  bei  strenger  Arithmetik  einen out-of-
branch   ergeben   wÅrden,   hier   jedoch   funktionieren,   weil  die
öbertragsbits  bei  der  Zieladressenberechnung  'unter den Tisch' fal-
len.  Vergewissern Sie sich genau, ob die von Ihnen eingesetzte Prozes-
sorvariante  so arbeitet, bevor Sie  diese Option einschalten! Im Falle
des  oben erwÑhnten  AT90S8515 ist  diese Option  sogar zwingend nîtig,
um Åberhaupt quer durch den ganzen Adre·raum springen zu kînnen...

DefaultmÑ·ig  steht dieser Schalter  auf OFF, der  momentane Stand lÑ·t
sich aus einem gleichnamigen Symbol auslesen.


        3.2.12. SEGMENT
        - - - - - - - -

GÅltigkeit: alle Prozessoren

Bestimmte  Mikrokontroller  und  Signalprozessoren  kennen  mehrere Ad-
re·bereiche,  die nicht miteinander mischbar sind und jeweils auch ver-
schiedene  Befehle zur Ansprache benîtigen.  Um auch diese verwalten zu
kînnen,  stellt  der  Assembler  mehrere  ProgrammzÑhler zur VerfÅgung,
zwischen  denen  mit  dem  SEGMENT-Befehl  hin-und hergeschaltet werden
kann.  Dies erlaubt es,  sowohl in mit  INCLUDE eingebundenen Unterpro-
grammen  als auch im Hauptprogramm benîtigte Daten an der Stelle zu de-
finieren,  an denen  sie benutzt  werden. Im  einzelnen werden folgende
Segmente mit folgenden Namen verwaltet:

  - CODE: Programcode;
  - DATA: direkt adressierbare Daten (dazu rechnen auch SFRs);
  - XDATA:  im  extern  angeschlossenen  RAM  liegende  Daten  oder  X-
    Adre·raum beim DSP56xxx oder ROM-Daten beim ÊPD772x;
  - YDATA: Y-Adre·raum beim DSP56xxx;
  - IDATA: indirekt adressierbare (interne) Daten;
  - BITDATA:  der Teil des 8051-internen  RAMs, der bitweise adressier-
    bar ist;
  - IO: I/O-Adre·bereich;
  - REG: Registerbank des ST9;
  - ROMDATA: Konstanten-ROM der NEC-Signalprozessoren.

Zu  Adre·bereich und Initialwerten der  Segmente siehe Abschnitt 3.2.1.
(ORG).  Je nach Prozessorfamilie sind  auch nicht alle Segmenttypen er-
laubt.

Das  Bitsegment  wird  so  verwaltet,  als  ob es ein Bytesegment wÑre,
d.h. die Adressen inkrementieren um 1 pro Bit.

Labels,  die in einem  Segment eines bestimmten  Typs definiert werden,
erhalten  diesen Typ  als Attribut.  Damit hat  der Assembler  eine be-
grenzte  PrÅfmîglichkeit, ob mit  den falschen Befehlen  auf Symbole in
einem  Segment zugegriffen wird.  In solchen FÑllen  wird der Assembler
eine Warnung ausgeben.

Beispiel:

        CPU     8051    ; MCS-51-Code

        SEGMENT code    ; Testcodeblock

        SETB    flag    ; keine Warnung
        SETB    var     ; Warnung : falsches Segment

        SEGMENT data

var     DB      ?

        SEGMENT bitdata

flag    DB      ?



        3.2.13. PHASE und DEPHASE
        - - - - - - - - - - - - -

GÅltigkeit: alle Prozessoren

In  manchen Anwendungen (speziell Z80-Systeme)  mu· Code vor der Benut-
zung  in einen anderen  Adre·bereich verschoben werden.  Da der Assemb-
ler  davon aber nichts wei·,  wÅrde er alle Labels  in dem zu verschie-
benden  Teil auf  die Ladeadressen  ausrichten. Der Programmierer mÅ·te
SprÅnge  innerhalb  dieses  Bereiches  entweder lageunabhÑngig kodieren
oder  die Verschiebung bei  jedem Symbol ,,zu  Fu·'' addieren. Ersteres
ist  bei  manchen  Prozessoren  gar  nicht mîglich, letzteres sehr feh-
leranfÑllig.

Mit  dem Befehlen PHASE und DEPHASE  ist es mîglich, dem Assembler mit-
zuteilen,  auf welcher Adresse  der Code im  Zielsystem effektiv ablau-
fen wird:

        PHASE   <Adresse>

informiert  den Assembler davon, da· der folgende Code auf der spezifi-
zierten  Adresse ablaufen  soll. Der  Assembler berechnet daraufhin die
Differenz  zum echten  ProgrammzÑhler und  addiert diese  Differenz bei
folgenden Operationen dazu:

  - Adre·angabe im Listing
  - Ablage von Labelwerten
  - ProgrammzÑhlerreferenzen    in    relativen    SprÅngen   und   Ad-
    re·ausdrÅcken
  - Abfrage des ProgrammzÑhlers mit den Symbolen * bzw. $

Diese ,,Verschiebung'' wird mit dem Befehl

        DEPHASE

wieder aufgehoben.

Obwohl  dieses  Befehlspaar  vornehmlich  in  Codesegmenten Sinn macht,
verwaltet der Assembler fÅr alle definierten Segmente Phasenwerte.


        3.2.14.  SAVE und RESTORE
        - - - - - - - - - - - - -

GÅltigkeit: alle Prozessoren

Mit  dem Befehl SAVE legt der  Assembler den Inhalt folgender Variablen
auf einen internen Stapel:

  - momentan gewÑhlter Prozessortyp (mit CPU gesetzt);
  - momentan aktiver Speicherbereich (mit SEGMENT gesetzt);
  - Flag,  ob  Listing  ein-  oder  ausgeschaltet  ist (mit LISTING ge-
    setzt);
  - Flag,  ob Expansionen folgender Makos  im Listing ausgegeben werden
    sollen (mit MACEXP gesetzt).
  - momentan   aktive  ZeichenÅbersetzungstabelle   (mit  CODEPAGE  ge-
    setzt).

Mit  dem GegenstÅck  RESTORE wird  entsprechend der  zuletzt gesicherte
Zustand  von diesem Stapel wieder  heruntergeladen. Diese beiden Befeh-
le  sind in erster Linie fÅr  Includefiles definiert worden, um in die-
sen  Dateien die  obigen Variablen  beliebig verÑndern  zu kînnen, ohne
ihren  originalen Inhalt zu  verlieren. So kann  es z.B. sinnvoll sein,
in  Includefiles  mit  eigenen,  ausgetesteten Unterprogrammen die Lis-
tingerzeugung auszuschalten:

        SAVE            ; alten Zustand retten
        LISTING OFF     ; Papier sparen
        ..              ; der eigentliche Code
        RESTORE         ; wiederherstellen

GegenÅber  einem einfachen LISTING OFF..ON-PÑrchen  wird hier auch dann
der  korrekte Zustand wieder hergestellt, wenn die Listingerzeugung be-
reits vorher ausgeschaltet war.

Der  Assembler  ÅberprÅft,  ob  die  Zahl von SAVE-und RESTORE-Befehlen
Åbereinstimmt und liefert in folgenden FÑllen Fehlermeldungen:

  - RESTORE und der interne Stapel ist leer;
  - nach Ende eines Passes ist der Stapel nicht leer.



        3.2.15.  ASSUME
        - - - - - - - -

GÅltigkeit: diverse

Mit  diesem Befehl kann man AS  den aktuellen Stand bestimmter Register
mitteilen,  deren Inhalt sich nicht mit einem einfachen ON oder OFF be-
schreiben  lÑ·t. Typischerweise  sind dies  Register, die die Adressie-
rungseinheiten  beeinflussen und deren Werte  AS wissen mu·, um korrek-
te  Adressierungen zu erzeugen. Wichtig ist, da· man AS mit ASSUME die-
se  Werte nur mitteilt,  es wird kein  Maschinencode erzeugt, der diese
Werte in die entsprechenden Register lÑdt!


        6809
        ....

Im  Gegensatz  zu  seinen  ,,VorgÑngern''  wie  6800 und 6502 kann beim
6809  die Lage der  direct page, d.h.  des Adressbereiches, der mit ein
Byte  langen Adressen erreichbar ist,  frei bestimmt werden. Dazu dient
das  sog. ,,Direct  Page Register''  (DPR), das  die Seitennummer fest-
legt.  Ihm mu· man  mittels ASSUME einen  passenden Wert zuweisen, wenn
man  einen anderen Wert  als die Vorgabe  von 0 in  DPR schreibt, sonst
werden Adressen falscher LÑnge erzeugt...


        68HC11K4
        ........

Auch   beim  HC11  konnten  die  Entwickler  letzten  Endes  nicht  dem
'SÅndenfall'  widerstehen und haben in den K4 ein Banking-Schema einge-
baut,  um mit 16 Adre·leitungen mehr als 64 Kbyte anzusprechen. Die Re-
gister  MMSIZ, MMWBR,  MM1CR und  MM2CR legen  fest, ob  wie die beiden
zusÑtzlichen  512K-Bereiche in den  physikalischen Adre·raum eingeblen-
det  werden sollen. Initial nimmt  AS den Reset-Zustand dieser Register
an, d.h. alle mit $00 belegt und das Windowing ist abgeschaltet.


        68HC12X
        .......

Wie  die Variante ohne anhÑngendes 'X'  kennt auch der HC12X eine kurze
direkte  Adressierungsart,  die  hier  jedoch auch andere Adre·bereiche
als  die ersten 256 Byte erreichen  kann. öber das DIRECT-Register kann
die  256-Byte-Seite vorgegeben werden, die  mit dieser kurzen Adressie-
rungsart  angesprochen  wird.  Mittels  ASSUME  wird  AS  der momentane
Stand  dieses Registers mitgeteilt, so da· bei absoluten Adressen auto-
matisch   die  effizienteste  Adressierungsart   gewÑhlt  werden  kann.
Default ist 0, was auch dem Reset-Zustand entspricht.


        68HC16
        ......

Um  mit seinen nur  16 Bit breiten  Adre·operanden einen 1 Mbyte gro·en
Adre·raum  ansprechen zu  kînnen, bedient  sich der  68HC16 einer Reihe
von  Bank-Registern, die  die fehlenden  oberen vier Adre·bits nachlie-
fern.  Davon  ist  das  EK-Register  fÅr  absolute Datenzugriffe (nicht
SprÅnge!)  zustÑndig.  AS  ÅberprÅft  bei jeder absoluten Adressierung,
ob  die oberen vier  Bits der Adresse  mit dem Åber ASSUME spezifizier-
ten  Wert Åbereinstimmen. Differieren  die Werte, gibt  AS eine Warnung
aus. Der Vorgabewert fÅr EK ist 0.


        H8/500
        ......

Im  Maximum-Modus wird  der erweiterte  Adre·raum dieser Prozessorreihe
durch  eine Reihe von  Bank-Registern adressiert. Diese  tragen die Na-
men  DP (Register  0..3, absolute  Adressen), EP  (Register 4/5) und TP
(Stack).  Den momentanen Wert von DP  benîtigt AS, um zu ÅberprÅfen, ob
absolute  Adressen in der momentan adressierbaren Bank liegen; die bei-
den  anderen Register  werden nur  fÅr indirekte Adressierungen benutzt
und  entziehen sich daher der Kontrolle;  ob man ihre Werte angibt oder
nicht,  ist daher Geschmackssache.  Wichtig ist dagegen  wieder das BR-
Register,  das angibt,  auf welchen  256-Byte-Bereich mit kurzen Adres-
sen  zugegriffen  werden  kann.  Allen  Registern ist gemeinsam, da· AS
keine  Initialwerte fÅr sie annimmt,  da sie nach einem Prozessor-Reset
undefiniert  sind; wer  absolut adressieren  will, mu·  daher auf jeden
Fall DR und DP belegen!


        MELPS740
        ........

Die  Mikrokontroller dieser Reihe kennen fÅr den JSR-Befehl eine beson-
dere  Adressierungsart ,,special  page'', mit  deren Hilfe  man SprÅnge
in  die oberste  Seite des  internen ROMs  kÅrzer kodieren  kann. Diese
ist  natÅrlich vom  jeweiligen Chip  abhÑngig, und  es gibt mehr Chips,
als  es mit dem CPU-Befehl sinnvoll  wÑre, zu kodieren...also mu· ASSU-
ME herhalten, um die Lage dieser Seite vorzugeben, z.B.

        ASSUME SP:$1f ,

falls das interne ROM 8K gro· ist.


        MELPS7700/65816
        ...............

Diese  Prozessoren beinhalten  eine Reihe  von Registern,  deren Inhalt
AS  kennen mu·, um den  korrekten Code zu erzeugen.  Es handelt sich um
folgende Register:
       +------+---------------------+--------------+---------+
       | Name | Bedeutung           | Wertebereich | Default |
       +------+---------------------+--------------+---------+
       +------+---------------------+--------------+---------+
       | DT   | Datenbank           | 0-$ff        | 0       |
       | PG   | Code-Bank           | 0-$ff        | 0       |
       | DPR  | direkt adr. Seite   | 0-$ffff      | 0       |
       | X    | Indexregisterbreite | 0 oder 1     | 0       |
       | M    | Akkumulatorbreite   | 0 oder 1     | 0       |
       +------+---------------------+--------------+---------+

Um  mich nicht in  endlose Wiederholungen zu  ergehen, verweise ich fÅr
die  Benutzung dieser Werte auf Kapitel 4.9. Die Handhabung erfolgt an-
sonsten  genauso wie beim 8086, d.h.  es kînnen auch hier mehrere Werte
auf  einmal gesetzt werden und es wird kein Code erzeugt, der die Regi-
ster  mit den Werten besetzt. Dies  bleibt wieder einzig und allein dem
Programmierer Åberlassen!


        MCS-196/296
        ...........

Alle  Prozessoren der  MCS-96-Familie besitzen  ab dem  80196 ein Regi-
ster  WSR, mit dessen Hilfe Speicherbereiche aus dem erweiterten inter-
nen  RAM oder dem SFR-Bereich  in Bereiche des Registerfiles eingeblen-
det  werden  und  so  mit  kurzen  Adressen angesprochen werden kînnen.
Teilt  man AS mit  Hilfe des ASSUME-Befehls  mit, welchen Wert das WSR-
Register  hat, so  stellt er  bei absoluten  Adressen automatisch fest,
ob  sie durch das Windowing mit 1-Byte-Adressen erreicht werden kînnen;
umgekehrt  werden auch fÅr durch  das Windowing Åberdeckte Register au-
tomatisch  lange Adressen erzeugt. Der  80296 besitzt ein zusÑtzliches,
zweites   Register  WSR1,  um  zwei  unterschiedliche  Speicherbereiche
gleichzeitig  in  das  Registerfile  einblenden  zu  kînnen.  Sollte es
mîglich  sein, eine  Speicherzelle Åber  beide Bereiche zu adressieren,
so wÑhlt AS immer den Weg Åber WSR!


        8086
        ....

Der  8086 kann Daten  aus allen Segmenten  in einem Befehl adressieren,
benîtigt  jedoch sog. ,,Segment-PrÑfixe'',  wenn ein anderes Segmentre-
gister  als DS verwendet werden soll.  ZusÑtzlich kann es sein, da· das
DS-Register  auf  ein  anderes  Segment  verstellt  ist,  um  z.B. Åber
lÑngere  Strecken nur Daten  im Codesegment zu  adressieren. Da AS aber
keine  Sinnanalyse des Codes vornimmt, mu·  ihm Åber diesen Befehl mit-
geteilt  werden, auf welche Segmente  die Segmentregister momentan zei-
gen, z.B.

   ASSUME  CS:CODE, DS:DATA    .

Allen  vier Segmenten des 8086 (SS,DS,CS,ES) kînnen auf diese Weise An-
nahmen  zugewiesen werden.  Dieser Befehl  erzeugt jedoch  keinen Code,
um  die Werte auch  wirklich in die  Segmentregister zu laden, dies mu·
vom Programm getan werden.

Die  Benutzung diese Befehls hat zum einen die Folge, da· AS bei spora-
dischen  Zugriffen  ins  Codesegment  automatisch  PrÑfixe voranstellen
kann,  andererseits da· man AS mitteilen kann, da· das DS-Register ver-
stellt  wurde und man sich  im folgenden explizite CS:-Anweisungen spa-
ren kann.

GÅltige  Argumente hinter dem Doppelpunkt  sind CODE, DATA und NOTHING.
Letzterer  Wert  dient  dazu,  AS  mitzuteilen, da· das Segmentregister
keinen  fÅr AS verwendbaren Wert enthÑlt. Vorinitialisiert sind folgen-
de ASSUMEs :

  CS:CODE, DS:DATA, ES:NOTHING, SS:NOTHING



        XA
        ..

Die  XA-Familie besitzt einen  Datenadre·raum von 16  Mbyte, ein Proze·
kann  jedoch  nur  immer  innerhalb  einer  64K-Seite  adressieren, die
durch  das DS-Register vorgegeben wird. AS  mu· man den momentanen Wert
dieses  Registers  vorgeben,  damit  er  Zugriffe auf absolute Adressen
ÅberprÅfen kann.


        29K
        ...

Die  Prozessoren der 29K-Familie besitzen  ein Register RBP, mit dessen
Hilfe   BÑnke  von  16  Registern   vor  der  Benutzung  im  User-Modus
geschÅtzt  werden kînnen. Dazu kann man  ein entsprechendes Bit in die-
sem  Register setzen.  Mit ASSUME  kann man  AS nun  mitteilen, welchen
Wert  RBP gerade  hat. Auf  diese Weise  kann AS warnen, falls versucht
wird, im User-Modus auf geschÅtzte Register zuzugreifen.


        80C166/167
        ..........

Obwohl  keines der Register  im 80C166/167 breiter  als 16 Bit ist, be-
sitzt  dieser  Prozessor  18/24  Adre·leitungen,  kann  also bis zu 256
Kbyte/16  Mbyte adressieren. Um  diesen Widerspruch unter  einen Hut zu
bekommen,  verwendet  er  nicht  die  von  Intel  her  bekannte (...und
berÅchtigte)  Segmentierung  oder  hat  unflexible Bankregister...nein,
er  macht Paging! Dazu wird der  ,,logische'' Adre·raum von 64 Kbyte in
4  Seiten zu 16 Kbyte eingeteilt, und fÅr jede Seite existiert ein Sei-
tenregister  (bezeichnet  als  DPP0...DPP3),  das  bestimmt, welche der
physikalischen  16/1024  Seiten  dort  eingeblendet  wird.  AS versucht
nun,  den Adre·raum grundsÑtzlich mit 256  Kbyte/16 Mbyte aus der Sicht
des  Programmierers zu  verwalten, d.h.  bei absoluten Zugriffen ermit-
telt  AS die  physikalische Seite  und schaut  in der mit ASSUME einge-
stellten  Seitenverteilung nach, wie  die Bits 14  und 15 der logischen
Adresse  gesetzt werden mÅssen. Pa·t  kein Seitenregister, so wird eine
Warnung  ausgegeben. DefaultmÑ·ig  nimmt AS  an, da·  die vier Register
linear die ersten 64 Kbyte abbilden, etwa in der folgenden Form:

        ASSUME  DPP0:0,DPP1:1,DPP2:2,DPP3:3

Der  80C167 kennt noch einige Befehle,  die die Seitenregister in ihrer
Funktion  Åbersteuern  kînnen.  Wie  diese Befehle die Adre·generierung
beeinflussen,  ist im  Kapitel mit  den prozessorspezifischen Hinweisen
beschrieben.


        TLCS-47
        .......

Der  von der Architektur her  vorgegebene Datenadre·raum dieser Prozes-
soren  (egal ob  man direkt  oder Åber  das HL-Register adressiert) be-
trÑgt  lediglich  256  Nibbles.  Da die ,,besseren'' Familienmitglieder
aber  bis zu  1024 Nibbles  RAM on  chip haben,  war Toshiba gezwungen,
einen  Bankingmechanismus Åber das DMB-Register einzufÅhren. AS verwal-
tet  das Datensegment als  einen durchgehenden Adre·raum  und prÅft bei
jeder  direkten Adressierung,  ob die  Adresse in  der momentan aktiven
Bank liegt. Die von AS momentan angenommene Bank kann mittels

        ASSUME  DMB:<0..3>

festgelegt werden. Der Default ist 0.


        ST6
        ...

Die  Mikrokontroller der  ST62-Reihe sind  in der  Lage, einen Teil (64
Byte)  des Codebereiches in den Datenbereich einzublenden, z.B. um Kon-
stanten  aus dem ROM  zu laden. Dies  bedeutet aber auch,  da· zu einem
Zeitpunkt  immer nur ein Teil des  ROMs adressiert werden kann. Welcher
Teil  dies ist,  wird durch  ein bestimmtes  Register bestimmt. Dem In-
halt  dieses  Registers  kann  AS  zwar nicht direkt kontrollieren, man
kann  ihm  aber  mit  diesem  Befehl  mitteilen,  wenn man dem Register
einen  neuen Wert  zugewiesen hat.  AS kann  dann prÅfen und ggfs. war-
nen,  falls auf Adressen im Codesegment  zugegriffen wird, die nicht im
,,angekÅndigten''  Fenster liegt. Hat  die Variable VARI  z.B. den Wert
456h, so setzt

        ASSUME  ROMBASE:VARI>>6

die  AS-interne  Variable  auf  11h,  und  ein Zugriff auf VARI erzeugt
einen Zugriff auf die Adresse 56h im Datensegment.

Anstelle  eines Symbols  kann auch  schlicht NOTHING  angegeben werden,
z.B.  wenn das  Bank-Register temporÑr  als Speicherzelle benutzt wird.
Dieser Wert ist auch die Voreinstellung.


        ST9
        ...

Die  ST9-Familie verwendet zur Adressierung  von Code- und Datenbereich
exakt  die gleichen Befehle. Welcher  Adre·raum dabei jeweils angespro-
chen  wird, hÑngt vom Stand des  DP-Flags im Flag-Register ab. Damit AS
bei  absoluten Zugriffen ÅberprÅfen  kann, ob man  mit Symbolen aus dem
korrekten  Adre·raum arbeitet (das funktioniert natÅrlich nur bei abso-
luten  Zugriffen!), mu·  man ihm  per ASSUME  mitteilen, ob das DP-Flag
momentan  auf 0 (Code) oder 1 (Daten) steht. Der Initialwert dieser An-
nahme ist 0.


        ÊPD78(C)10
        ..........

Diese  Prozessoren  besitzen  ein  Register  (V),  mit dessen Hilfe die
,,Zeropage'',  d.h.  die  Lage  der  mit  nur einem Byte adressierbaren
Speicherzellen  sich  in  Seitengrenzen  im  Speicher  frei verschieben
lÑ·t. Da man aber aus BequemlichkeitsgrÅnden nicht mit AusdrÅcken wie

        inrw    Lo(Zaehler)

arbeiten  will,  Åbernimmt  AS  diese  Arbeit, allerdings nur unter der
Voraussetzung,  da· man ihm Åber einen  ASSUME-Befehl den Inhalt des V-
Registers  mitteilt. Wird  ein Befehl  mit Kurzadressierung benutzt, so
wird  ÅberprÅft, ob die  obere HÑlfte des  Adre·ausdrucks mit dem ange-
nommenen  Inhalt Åbereinstimmt. Stimmt sie  nicht, so erfolgt eine War-
nung.


        78K2
        ....

78K2  ist  eine  8/16-Bit-Architektur,  die  nachtrÑglich durch Banking
auf  einen (Daten-)Adre·raum von einem  MByte erweitert wurde. Das Ban-
king  wird  mit  den  Registern  PM6 (Normalfall) bzw. P6 (alternativer
Fall  mit vorangestelltem &) realisiert,  die die fehlenden oberen vier
Bits   nachliefern.   Zumindest   bei   absoluten   Adressen   kann  AS
ÅberprÅfen,  ob  die  gerade  angesprochene, lineare 20-bittige Adresse
innerhalb des gegebenen 64K-Fensters liegt.


        320C3x
        ......

Da  alle  Instruktionsworte  dieser  Prozessorfamilie  nur  32 Bit lang
sind,  und von diesen 32 Bit nur  16 Bit fÅr absolute Adressen vorgese-
hen  wurden,  mÅssen  die  fehlenden  oberen  8 Bit aus dem DP-Register
ergÑnzt  werden. Bei  Adressierungen kann  man aber  trotzdem die volle
24-Bit-Adresse  angeben, AS prÅft dann, ob die oberen 8 Bit mit dem an-
genommenen  Inhalt  von  DP  Åbereinstimmen.  GegenÅber  dem LDP-Befehl
weicht  ASSUME darin ab, da· man  hier nicht eine beliebige Adresse aus
der  Speicherbank angeben  kann, das  Herausziehen der  oberen Bits mu·
man also ,,zu Fu·'' machen, z.B. so:

        ldp     @adr
        assume  dp:adr>>16
        .
        .
        .
        ldi     @adr,r2



        75K0
        ....

Da  selbst mit  Hilfe von  Doppelregistern (8  Bit) nicht der komplette
Adre·raum  von 12 Bit zu erreichen  ist, mu·te NEC (wie andere auch...)
auf  Banking zurÅckgreifen: Die oberen 4  Adre·bits werden aus dem MBS-
Register  geholt (welchem  demzufolge mit  ASSUME Werte  zwischen 0 und
15  zugeordnet werden  kînnen), das  aber nur  beachtet wird, falls das
MBE-Flag  auf 1 gesetzt  wurde. Steht es  (wie die Vorgabe  ist) auf 0,
so  kann man die obersten und untersten 128 Nibbles des Adre·raumes oh-
ne  Bankumschaltung erreichen.  Da der  75402 weder  MBE-Flag noch MBS-
Register  kennt, ist fÅr ihn der ASSUME-Befehl nicht definiert; Die In-
itialwerte von MBE und MBS lassen sich daher nicht Ñndern.


        F˝MC16L
        .......

Wie  viele andere Mikrokontroller auch,  leidet diese Familie etwas un-
ter  der Knauserei  seiner Entwickler:  einem 24  Bit breiten Adre·raum
stehen  16 Bit breite Adre·register etwas unterbemittelt gegenÅber. Al-
so  mu·ten wieder  mal Bank-Register  her. Im  einzelnen sind  dies PCB
fÅr  den Programmcode,  DTB fÅr  alle Datenzugriffe,  ADB fÅr indirekte
Zugriffe  Åber RW2/RW6 und SSB/USB fÅr die Stacks. Sie kînnen alle Wer-
te  zwischen 0 und 255 annehmen.  DefaultmÑ·ig stehen alle Annahmen von
AS auf 0, mit Ausnahme von 0ffh fÅr PCB.

Des  weiteren existiert das DPR-Register,  das angibt, welche Seite in-
nerhalb  der durch  DTB gegebenen  64K-Bank mit 8-Bit-Adressen erreicht
werden  kann. Der Default fÅr  DPR ist 1, zusammen  mit dem Default fÅr
DTB ergibt dies also eine Default-Seite bei 0001xxh.


        3.2.16.  EMULATED
        - - - - - - - - -

GÅltigkeit: 29K

AMD  hat die Ausnahmebehandlung fÅr undefinierte Befehle bei der 29000-
Serie  so definiert, da·  fÅr jeden einzelnen  Befehl ein Exceptionvek-
tor  zur VerfÅgung steht.  Dies legt es  nahe, durch gezielte Software-
Emulationen  den Befehlssatz eines  kleineren Mitgliedes dieser Familie
zu  erweitern. Damit nun  aber AS diese  zusÑtzlichen Befehle nicht als
Fehler  anmeckert, erlaubt es der  EMULATED-Befehl, AS mitzuteilen, da·
bestimmte  Befehle doch erlaubt sind. Die  PrÅfung, ob der momentan ge-
setzte  Prozessor diesen  Befehl beherrscht,  wird dann Åbergangen. Hat
man  z.B.  fÅr  einen  Prozessor  ohne  Gleitkommaeinheit ein Modul ge-
schrieben,  das  aber  nur  mit  32-Bit-IEEE-Zahlen  umgehen  kann,  so
schreibt man

        EMULATED FADD,FSUB,FMUL,FDIV
        EMULATED FEQ,FGE,FGT,SQRT,CLASS



        3.2.17. BRANCHEXT
        - - - - - - - - -

GÅltigkeit: XA

BRANCHEXT  mit ON  oder OFF  als Argument  legt fest,  ob AS kurze, nur
mit    einem   8-Bit-Displacement    verfÅgbare   SprÅnge   automatisch
,,verlÑngern'' soll, indem z.B. aus einem einfachen

        bne     target

automatisch  eine  lÑngere  Sequenz  mit  gleicher Funktion wird, falls
das  Sprungziel  zu  weit  von  momentanen ProgrammzÑhler entfernt ist.
FÅr bne wÑre dies z.B. die Sequenz

        beq     skip
        jmp     target
skip:

Falls  fÅr eine Anweisung aber  kein passendes ,,Gegenteil'' existiert,
kann die Sequenz auch lÑnger werden, z.B. fÅr jbc:

        jbc     dobr
        bra     skip
dobr:   jmp     target
skip:

Durch  dieses Feature gibt  es bei SprÅngen  keine eineindeutige Zuord-
nung    von    Maschinen-    und    Assemblercode    mehr,    und   bei
VorwÑrtsreferenzen  handelt man sich  mîglicherweise zusÑtzliche Passes
ein. Man sollte dieses Feature daher mit Vorsicht einsetzen!


        3.3. Datendefinitionen
        ----------------------

Die  hier beschriebenen  Befehle Åberschneiden  sich teilweise in ihrer
FunktionalitÑt,  jedoch  definiert  jede  Prozessorfamilie andere Namen
fÅr  die  gleiche  Funktion.  Um  mit den Standardassemblern konform zu
bleiben, wurde diese Form der Implementierung gewÑhlt.

Sofern  nicht ausdrÅcklich anders erwÑhnt,  kann bei allen Befehlen zur
Datenablage  (nicht bei denen  zur Speicherreservierung!) eine beliebi-
ge  Zahl von Parametern angegeben werden, die der Reihe nach abgearbei-
tet werden.


        3.3.1.  DC[.size]
        - - - - - - - - -

GÅltigkeit: 680x0, M*Core, 68xx, H8, SH7000, DSP56xxx, XA, ST7

Dieser  Befehl legt eine oder mehrere Konstanten des beim durch das At-
tribut  bestimmten Typs im  Speicher ab. Die  Attribute entsprechen den
in  Abschnitt 2.5  definierten, zusÑtzlich  ist fÅr Byte-Konstanten die
Mîglichkeit  vorhanden,  StringausdrÅcke  im  Speicher  abzulegen,  wie
z.B.

String  dc.b    "Hello world!\0"

Die  Parameterzahl darf zwischen  1 und 20  liegen, zusÑtzlich darf je-
dem  Parameter ein in  eckigen Klammern eingeschlossener Wiederholungs-
faktor vorausgehen, z.B. kann man mit

        dc.b    [(*+255)&$ffffff00-*]0

den  Bereich  bis  zur  nÑchsten  Seitengrenze  mit Nullen fÅllen. Vor-
sicht!  Mit  dieser  Funktion  kann  man  sehr  leicht die Grenze von 1
Kbyte erzeugten Codes pro Zeile Quellcode Åberschreiten!

Sollte  die  Byte-Summe  ungerade  sein,  so kann vom Assembler automa-
tisch  ein weiteres  Byte angefÅgt  werden, um  die Wortausrichtung von
Daten  zu erhalten. Dieses  Verhalten kann mit  dem PADDING-Befehl ein-
und ausgeschaltet werden.

Mit  diesem Befehl abgelegte  Dezimalgleitkommazahlen (DC.P ...) kînnen
zwar  den ganzen Bereich  der extended precision  Åberstreichen, zu be-
achten  ist dabei allerdings,  da· die von  Motorola verfÅgbaren Kopro-
zessoren  68881/68882 beim  Einlesen solcher  Konstanten die Tausender-
stelle des Exponenten ignorieren!

Default-Attribut ist W, also 16-Bit-Integerzahlen.

Beim  DSP56xxx ist der  Datentyp auf Integerzahlen  festgelegt (ein At-
tribut  ist deshalb weder nîtig noch erlaubt), die im Bereich -8M..16M-
1  liegen dÅrfen.  Stringkonstanten sind  ebenfalls erlaubt,  wobei je-
weils drei Zeichen in ein Wort gepackt werden.

Es  ist im Gegensatz zum  Original Motorola-Assembler auch erlaubt, mit
diesem  Kommando Speicher  zu reservieren,  indem man  als Argument ein
Fragezeichen  angibt. Diese  Erweiterung haben  wohl einige Drittanbie-
ter  von  68K-Assemblern  eingebaut,  in  Anlehnung  an das, was Intel-
Assembler  machen. Wer dies  benutzt, sollte sich  aber im klaren sein,
da·  dies zu  Problemen beim  Portieren von  Code auf  andere Assembler
fÅhren  kann.  Des  weiteren  dÅrfen  Fragenzeichen als Operanden nicht
mit 'normalen' Konstanten in einer Anweisung gemischt werden.


        3.3.2.  DS[.size]
        - - - - - - - - -

GÅltigkeit: 680x0, M*Core, 68xx, H8, SH7x00, DSP56xxx, XA, ST7

Mit  diesem Befehl lÑ·t sich zum  einen Speicherplatz fÅr die angegebe-
ne Zahl im Attribut beschriebener Zahlen reservieren. So reserviert

        DS.B    20

z.B. 20 Bytes Speicher,

        DS.X    20

aber 240 Byte !

Die  andere Bedeutung ist die  Ausrichtung des ProgrammzÑhlers, die mit
der Wertangabe 0 erreicht wird. So wird mit

        DS.W    0

der ProgrammzÑhler auf die nÑchste gerade Adresse aufgerundet, mit

        DS.D    0

dagegen  auf die nÑchste  Langwortgrenze. Eventuell dabei freibleibende
Speicherzellen  sind nicht etwa  mit Nullen oder  NOPs gefÅllt, sondern
undefiniert.

Vorgabe fÅr die Operandengrî·e ist --- wie Åblich --- W, also 16 Bit.

Beim  56xxx ist die Operandengrî·e auf Worte (a 24 Bit) festgelegt, At-
tribute gibt es deswegen wie bei DC auch hier nicht.


        3.3.3. DB,DW,DD,DQ & DT
        - - - - - - - - - - - -


GÅltigkeit: Intel, Zilog, Toshiba, NEC, TMS370, Siemens, AMD, M16(C),
            MELPS7700/65816, National, ST9, TMS7000, ÊPD77230,
            Fairchild, Intersil


Diese  Befehle  stellen  sozusagen  das  Intel-GegenstÅck  zu DS und DC
dar, und wie nicht anders zu erwarten, ist die Logik etwas anders:

Zum  einen wird  die Kennung  der Operandengrî·e  in das  Mnemonic ver-
legt:

  - DB: Byte oder ASCII-String wie bei DC.B
  - DW: 16-Bit-Integer
  - DD: 32-Bit-Integer oder single precision
  - DQ: double precision (64 Bit)
  - DT: extended precision (80 Bit)

Zum  anderen erfolgt  die Unterscheidung,  ob Konstantendefinition oder
Speicherreservierung,  im  Operanden.  Eine  Reservierung  von Speicher
wird durch ein ? gekennzeichnet:

        db  ?   ; reserviert ein Byte 
        dw  ?,? ; reserviert Speicher fuer 2 Worte (=4 Byte) 
        dd  -1  ; legt die Konstante -1 (FFFFFFFFH) ab ! 

Speicherreservierung  und  Konstantendefinition  dÅrfen  nicht in einer
Anweisung gemischt werden:

        db  "Hallo",?  ; -->Fehlermeldung 

ZusÑtzlich  ist noch der DUP-Operator  erlaubt, der die mehrfache Abla-
ge  von  Konstantenfolgen  oder  die Reservierung ganzer Speicherblîcke
erlaubt:

        db  3 dup (1,2) ; --> 1 2 1 2 1 2 
        dw  20 dup (?)  ; reserviert 40 Byte Speicher. 

Wie  man  sehen  kann,  mu·  das  DUP-Argument  geklammert werden, darf
dafÅr  aber auch wieder  aus mehreren Teilen  bestehen, die selber auch
wieder DUPs sein kînnen...das ganze funktioniert also rekursiv.

DUP  ist aber  auch eine  Stelle, an  der man  mit einer anderen Grenze
des  Assemblers in BerÅhrung kommen kann:  maximal kînnen 1024 Byte Co-
de  oder Daten in  einer Zeile erzeugt  werden. Dies bezieht sich nicht
auf  die Reservierung von Speicher, nur auf die Definition von Konstan-
tenfeldern!

Um  mit dem M80 vertrÑglich zu sein, darf im Z80-Modus anstelle von DB/
DW auch DEFB/DEFW geschrieben werden.

Analog  stellen BYTE/ADDR bzw.  WORD/ADDRW beim COP4/8  einen Alias fÅr
DB  bzw. DW dar, wobei  die beiden Paare sich  jedoch in der Byte-Order
unterscheiden:  Die Befehle, die von  National zur Adre·ablage vorgese-
hen waren, benutzen Big-Endian, BYTE bzw. WORD jedoch Little-Endian.

Der  NEC 77230 nimmt  mit seiner DW-Anweisung  eine Sonderstellung ein:
Sie  funktioniert eher  wie DATA  bei seinen  kleineren BrÅdern, akzep-
tiert  aber  neben  String-  und Integerargumenten auch Gleitkommawerte
(und  legt  sie  prozessorspezifischen  32-Bit-Format  ab). DUP gibt es
nicht!


        3.3.4.  DS, DS8
        - - - - - - - -


GÅltigkeit: Intel, Zilog, Toshiba, NEC, TMS370, Siemens, AMD, M16(C),
            National, ST9, TMS7000, Intersil


Dieser  Befehl  stellt  eine  Kurzschreibweise dar, um Speicherbereiche
zu reservieren:

    DS <Anzahl>

ist eine Kurzschreibweise fÅr

    DB <Anzahl> DUP (?)

dar,  lie·e sich also prinzipiell auch einfach Åber ein Makro realisie-
ren,  nur scheint  dieser Befehl  in den  Kîpfen einiger  mit Motorola-
CPUs  gro·  gewordener  Leute  (gell,  Michael?)  so fest verdrahtet zu
sein,  da· sie  ihn als  eingebauten Befehl erwarten...hoffentlich sind
selbige jetzt zufrieden ;-)

DS8  ist beim National  SC14xxx als Alias  fÅr DS definiert. Achten Sie
aber  darauf, da· der  Speicher dieser Prozessoren  in Worten zu 16 Bit
organisiert  ist, d.h.  es ist  unmîglich, einzelne  Bytes zu reservie-
ren.  Falls  das  Argument  von  DS  ungerade  ist,  wird  es  auf  die
nÑchstgrî·ere gerade Zahl aufgerundet.


        3.3.5. BYT oder FCB
        - - - - - - - - - -

GÅltigkeit: 6502, 68xx

Mit  diesem Befehl  werden im  65xx/68xx-Modus Byte-Konstanten oder AS-
CII-Strings  abgelegt, er entspricht  also DC.B beim  68000 oder DB bei
Intel.  Ein Wiederholungsfaktor darf analog zu DC jedem einzelnen Para-
meter in eckigen Klammern vorangestellt werden.


        3.3.6. BYTE
        - - - - - -

GÅltigkeit: ST6, 320C2(0)x, 320C5x, MSP, TMS9900

Dito.  Ein im  320C2(0)x/5x-Modus vor  dem Befehl  stehendes Label wird
als  untypisiert  gespeichert,  d.h.  keinem  Adre·raum zugeordnet. Der
Sinn  dieses  Verhaltens  wird  bei den prozessorspezifischen Hinweisen
erlÑutert.

Ob  beim MSP bzw. TMS9900 ungerade  Mengen von Bytes automatisch um ein
Null-Byte  ergÑnzt werden  sollen, kann  mit dem  PADDING-Befehl einge-
stellt werden.


        3.3.7.  DC8
        - - - - - -

GÅltigkeit: SC144xx

Dieser  Befehl  ist  ein  Alias  fÅr  DB,  d.h.  mit  ihm  kînnen Byte-
Konstanten oder Strings im Speicher abgelegt werden.


        3.3.8. ADR oder FDB
        - - - - - - - - - -

GÅltigkeit: 6502, 68xx

Mit  diesem Befehl  werden im  65xx/68xx-Modus Wortkonstanten abgelegt,
er  entspricht also  DC.W beim  68000 oder  DW bei Intel. Ein Wiederho-
lungsfaktor  darf  analog  zu  DC  jedem einzelnen Parameter in eckigen
Klammern vorangestellt werden.


        3.3.9. WORD
        - - - - - -

GÅltigkeit: ST6, i960, 320C2(0)x, 320C3x, 320C5x, MSP

FÅr  den 320C3x und i960 werden  hiermit 32-Bit-Worte abgelegt, fÅr die
alle  anderen Familien 16-Bit-Worte. Ein  im 320C2(0)x/5x-Modus vor dem
Befehl  stehendes Label  wird als  untypisiert gespeichert, d.h. keinem
Adre·raum  zugeordnet. Der Sinn dieses  Verhaltens wird bei den prozes-
sorspezifischen Hinweisen erlÑutert.


        3.3.10.  DW16
        - - - - - - -

GÅltigkeit: SC144xx

Diser  Befehl ist  beim SC144xx  der Weg,  Konstanten mit WortlÑnge (16
Bit) im Speicher abzulegen und damit ein ALIAS fÅr DW.


        3.3.11.  LONG
        - - - - - - -

GÅltigkeit: 320C2(0)x, 320C5x

Hiermit  werden 32-Bit-Integer  im Speicher  abgelegt, und  zwar in der
Reihenfolge  LoWord-HiWord. Ein eventuell vor  dem Befehl stehendes La-
bel  wird  dabei  wieder  als  untypisiert  abgelegt  (der  Sinn dieser
Ma·nahme ist in den prozessorspezifischen Hinweisen erlÑutert).


        3.3.12. SINGLE, DOUBLE und EXTENDED
        - - - - - - - - - - - - - - - - - -

GÅltigkeit: 320C3x (nicht DOUBLE), 320C6x (nicht EXTENDED)

Mit  diesen  Befehlen  werden  Gleitkomma-Konstanten  im Speicher abge-
legt,  jedoch beim 320C3x nicht im IEEE-Format, sondern in den vom Pro-
zessor  verwendeten 32-  und 40-Bit-Formaten.  Da 40  Bit nicht mehr in
eine  Speicherzelle hineinpassen,  werden im  Falle von  EXTENDED immer
derer  2 pro Wert belegt.  Im ersten Wort finden  sich die oberen 8 Bit
(der Exponent), der Rest (Vorzeichen und Mantisse) in zweiten Wort.


        3.3.13.  FLOAT und DOUBLE
        - - - - - - - - - - - - -

GÅltigkeit: 320C2(0)x, 320C5x

Mit  diesen Befehlen  kînnen 32-  bzw. 64-Bit-Gleitkommazahlen im IEEE-
Format  im  Speicher  abgelegt  werden.  Dabei wird das niederwertigste
Byte  jeweils  auf  der  ersten  Speicherstelle abgelegt. Ein eventuell
vor  dem  Befehl  stehendes  Label  wird wieder als untypisiert gespei-
chert  (der Sinn dieser Ma·nahme  ist in den prozessorspezifischen Hin-
weisen erlÑutert).


        3.3.14.  EFLOAT, BFLOAT, TFLOAT
        - - - - - - - - - - - - - - - -

GÅltigkeit: 320C2(0)x, 320C5x

Auch  diese Befehle  legen Gleitkommazahlen  im Speicher  ab, jedoch in
einem  nicht-IEEE-Format, das  evtl. leichter  von Signalprozessoren zu
verarbeiten ist:

  - EFLOAT: Mantisse mit 16 Bit, Exponent mit 16 Bit
  - BFLOAT: Mantisse mit 32 Bit, Exponent mit 16 Bit
  - DFLOAT: Mantisse mit 64 Bit, Exponent mit 32 Bit

Gemeinsam  ist den Befehlen, da· die  Mantisse vor dem Exponenten abge-
legt  wird (Lo-Word jeweils zuerst)  und beide im Zweierkomplement dar-
gestellt  werden.  Ein  eventuell  vor  dem Befehl stehendes Label wird
wieder  als untypisiert  gespeichert (der  Sinn dieser  Ma·nahme ist in
den prozessorspezifischen Hinweisen erlÑutert).


        3.3.15.  Qxx und LQxx
        - - - - - - - - - - -

GÅltigkeit: 320C2(0)x, 320C5x

Mit  diesen Befehlen  kînnen Gleitkommazahlen  in einem Festkommaformat
abgelegt  werden. xx ist dabei eine  zweistellige Zahl, mit deren Zwei-
erpotenz  der Gleitkommawert vor der Umwandlung in eine ganze Zahl mul-
tipliziert  werden soll. Er bestimmt  also praktisch, wieviele Bits fÅr
die  Nachkommastellen reserviert  werden sollen.  WÑhrend aber  Qxx nur
ein  Wort  (16  Bit)  ablegt,  wird  das  Ergebnis bei LQxx in 2 Worten
(LoWord zuerst) abgelegt. Das sieht dann z.B. so aus:

        q05     2.5      ; --> 0050h
        lq20    ConstPI  ; --> 43F7h 0032h

Mich  mîge niemand steinigen, wenn ich  mich auf meinem HP28 verrechnet
haben sollte...


        3.3.16.  DATA
        - - - - - - -

GÅltigkeit: PIC, 320xx, AVR, MELPS-4500, 4004/4040, ÊPD772x

Mit  diesem Befehl  werden Daten  im aktuellen  Segment abgelegt, wobei
sowohl  Integer- als  auch Stringwerte  zulÑssig sind.  Bei Strings be-
legt  beim 16C5x/16C8x,  17C4x im  Datensegment und  4500er ein Zeichen
ein  Wort, bei AVR,  17C4x im Codesegment,  ÊPD772x in den Datensegmen-
ten  und  3201x/3202x  passen  zwei  Zeichen  in ein Wort (LSB zuerst),
beim  ÊPD7725 drei und beim  320C3x sogar derer 4  (MSB zuerst). Im Ge-
gensatz  dazu  mu·  im  Datensegment  des  4500ers ein Zeichen auf zwei
Speicherstellen  verteilt werden,  ebenso wie  beim 4004.  Der Wertebe-
reich  fÅr Integers  entspricht der  Wortbreite des  jeweiligen Prozes-
sors  im jeweiligen  Segment. Das  bedeutet, da·  DATA beim  320C3x die
Funktion  von WORD mit einschlie·t (die  von SINGLE Åbrigens auch, wenn
AS das Argument als Gleitkommazahl erkennt).


        3.3.17.  ZERO
        - - - - - - -

GÅltigkeit: PIC

Dieser  Befehl legt  einen durch  den Parameter  spezifizierte Zahl von
Nullworten  (=NOPs) im  Speicher ab.  Es kînnen  maximal 512 Nullen mit
einem Befehl abgelegt werden.


        3.3.18. FB und FW
        - - - - - - - - -

GÅltigkeit: COP4/8

Mit  diesen  Befehlen  kann  ein  grî·erer  Block  von Speicher (dessen
LÑnge  in Bytes bzw. Worten der erste Parameter angibt) mit einer Byte-
bzw.  Wortkonstanten gefÅllt  werden, die  durch den  zweiten Parameter
angegeben  wird. Die Maximalgrî·e des  Blocks betrÑgt 1024 Elemente fÅr
FB bzw. 512 Elemente fÅr FW.


        3.3.19. ASCII und ASCIZ
        - - - - - - - - - - - -

GÅltigkeit: ST6

Mit  diesen beiden  Befehlen kînnen  Stringkonstanten im Speicher abge-
legt  werden. WÑhrend  ASCII nur  die reinen  Daten im Speicher ablegt,
versieht  ASCIZ  automatisch  jeden  angegebenen  String mit einem NUL-
Zeichen am Ende.


        3.3.20.  STRING und RSTRING
        - - - - - - - - - - - - - -

GÅltigkeit: 320C2(0)x, 320C5x

Diese  Anweisungen funktionieren analog zu DATA, jedoch werden hier In-
teger-AusdrÅcke  grundsÑtzlich als Bytes  mit einem entsprechend einge-
schrÑnkten  Wertebereich betrachtet, wodurch es mîgliich wird, die Zah-
len  zusammen mit  anderen Zahlen  oder Zeichen  paarweise in  Worte zu
verpacken.  Die beiden Befehle unterscheiden sich lediglich in der Rei-
henfolge  der Bytes  in einem  Wort: Bei  STRING wird  zuerst das obere
und danach das untere gefÅllt, bei RSTRING ist es genau umgekehrt.

Ein  eventuell vor dem  Befehl stehendes Label  wird wieder als untypi-
siert  gespeichert. Der Sinn dieser  Ma·nahme ist im entsprechenden Ka-
pitel mit den prozessorspezifischen Befehlen erlÑutert.


        3.3.21. FCC
        - - - - - -

GÅltigkeit: 6502, 68xx

Mit  diesem  Befehl  werden  im 65xx/68xx-Modus String-Konstanten abge-
legt.  Beachten  Sie  jedoch,  da·  im  Gegensatz zum Originalassembler
AS11  von Motorola  (dessentwegen dieser  Befehl existiert,  bei AS ist
diese  Funktion  im  BYT-Befehl  enthalten),  String-Argumente  nur  in
GÑnsefÅ·chen  und nicht in  Hochkommas oder SchrÑgstrichen eingeschlos-
sen  werden  dÅrfen!  Ein  Wiederholungsfaktor  darf analog zu DC jedem
einzelnen Parameter in eckigen Klammern vorangestellt werden.


        3.3.22.  DFS oder RMB
        - - - - - - - - - - -

GÅltigkeit: 6502, 68xx

Dieser  Befehl dient im 65xx/68xx-Modus  zur Reservierung von Speicher,
er entspricht DS.B beim 68000 oder DB ? bei Intel.


        3.3.23. BLOCK
        - - - - - - -

GÅltigkeit: ST6

Dito.


        3.3.24. SPACE
        - - - - - - -
GÅltigkeit: i960 Dito.


        3.3.25. RES
        - - - - - -

GÅltigkeit: PIC, MELPS-4500, 3201x, 320C2(0)x, 320C5x, AVR, ÊPD772x

Dieser  Befehl dient  zur Reservierung  von Speicher.  Er reserviert im
Codesegment  immer Wîrter  (10/12/14/16 Bit),  im Datensegment  bei den
PICs Bytes, beim 4500er Nibbles sowie bei Texas ebenfalls Wîrter.


        3.3.26. BSS
        - - - - - -

GÅltigkeit: 320C2(0)x, 320C3x, 320C5x, 320C6x, MSP

BSS  arbeitet analog  zu RES,  lediglich ein  eventuell vor  dem Befehl
stehendes  Symbol wird  beim 320C2(0)x/5x  als untypisiert gespeichert.
Der  Sinn  dieser  Ma·nahme  kann  im Kapitel mit den prozessorspezifi-
schen Hinweisen nachgelesen werden.


        3.3.27. DSB und DSW
        - - - - - - - - - -

GÅltigkeit: COP4/8

Diese  beiden Befehle stellen im COP4/8-Modus die zum ASMCOP von Natio-
nal  kompatible Methode dar,  Speicher zu reservieren.  WÑhrend DSB nur
einzelne  Bytes freihÑlt, reserviert DSW Wîrter und damit effektiv dop-
pelt soviel Bytes wie DSB.


        3.3.28.  DS16
        - - - - - - -

GÅltigkeit: SC144xx

Dieser  Befehl reserviert Speicher in  Schritten von vollstÑndigen Wor-
ten, d.h. 16 Bit. Er stellt einen Alias zu DW dar.


        3.3.29. ALIGN
        - - - - - - -

GÅltigkeit: alle Prozessoren

ALIGN  mit  einem  Integerausdruck  als  Argument  erlaubt es, den Pro-
grammzÑhler  auf eine  bestimmte Adresse  auszurichten. Die Ausrichtung
erfolgt  dergestalt, da·  der ProgrammzÑhler  so weit  erhîht wird, da·
er  ein ganzzahliges mehrfaches des  Argumentes wird. In seiner Funkti-
on  entspricht ALIGN also  DS.x 0 beim  den 680x0ern, nur  ist die Aus-
richtung noch flexibler.

Beispiel:

        align 2

macht  den ProgrammzÑhler gerade. Wie auch bei DS.x 0 ist der freiblei-
bende Speicherraum undefiniert.


        3.3.30. LTORG
        - - - - - - -

GÅltigkeit: SH7x00

Da  der SH7000-Prozessor seine Register  immediate nur mit 8-Bit-Werten
laden  kann, AS dem  Programmierer jedoch vorgaukelt,  da· es eine sol-
che  EinschrÑnkung nicht gÑbe,  mu· er die  dabei entstehenden Konstan-
ten  irgendwo im Speicher ablegen. Da es nicht sinnvoll wÑre, dies ein-
zeln  zu tun (wobei  jedes Mal Sprungbefehle  anfallen wÅrden...), wer-
den  die Literale gesammelt und kînnen vom Programmierer mit diesem Be-
fehl  gezielt blockweise (z.B. am  Ende eines Unterprogrammes) abgelegt
werden.  Zu den zu  beachtenden Details und  Fallen sei auf das Kapitel
mit den SH7000-spezifischen Dingen hingewiesen.


        3.4. Makrobefehle
        -----------------

GÅltigkeit: alle Prozessoren

Kommen  wir nun zu  dem, was einen  Makroassembler vom normalen Assemb-
ler  unterscheidet:  der  Mîglichkeit,  Makros  zu  definieren (ach was
?!).

Unter  Makros verstehe ich hier erst  einmal eine Menge von Anweisungen
(normal  oder Pseudo), die  mit bestimmten Befehlen  zu einem Block zu-
sammengefa·t  werden  und  dann  auf  bestimmte Weise bearbeitet werden
kînnen.  Zur Bearbeitung  solcher Blîcke  kennt der  Assembler folgende
Befehle:


        3.4.1.  MACRO
        - - - - - - -

ist  der wohl  wichtigste Befehl  zur Makroprogrammierung.  Mit der Be-
fehlsfolge

<Name>  MACRO   [Parameterliste]
        <Befehle>
        ENDM

wird  das  Makro  <Name:  >  als die eingeschlossene Befehlsfolge defi-
niert.  Diese Definition alleine  erzeugt noch keinen  Code! DafÅr kann
fortan  die Befehlsfolge einfach durch  den Namen abgerufen werden, das
Ganze  stellt also  eine Schreiberleichterung  dar. Um  die ganze Sache
etwas  nÅtzlicher zu machen, kann  man der Makrodefinition eine Parame-
terliste  mitgeben. Die  Parameternamen werden  wie Åblich durch Kommas
getrennt  und mÅssen --- wie der  Makroname selber --- den Konventionen
fÅr Symbolnamen (2.7) genÅgen.

Sowohl  Makronamen als auch  -parameter sind von  einer Umschaltung von
AS in den case-sensitiven Modus betroffen.

Makros  sind Ñhnlich  wie Symbole  lokal, d.h.  bei Definition in einer
Sektion  sind sie  nur in  dieser Sektion  und ihren Untersektionen be-
kannt.  Dieses  Verhalten  lÑ·t  sich  aber  durch die weiter unten be-
schriebenen Optionen PUBLIC und GLOBAL in weiten Grenzen steuern.

Neben  den  eigentlichen  Makroparametern  kînnen in der Parameterliste
auch  Steuerparameter enthalten sein, die die Abarbeitung des betroffe-
nen  Makros beeinflussen;  diese Parameter  werden von normalen Parame-
tern  dadurch  unterschieden,  da·  sie  in geschweifte Klammern einge-
schlossen sind. Es sind folgende Steuerparameter definiert:

  - EXPAND/NOEXPAND  : legen fest, ob  bei der spÑteren Verwendung die-
    se  Makros der expandierte Code  mit angezeigt werden soll. Default
    ist der durch den Pseudobefehl MACEXP festgelegte Wert.
  - PUBLIC[:Sektionsname]  : ordnet das Makro nicht der aktuellen, son-
    dern  einer ihr Åbergeordneten Sektion zu. Auf diese Weise kann ei-
    ne  Sektion  Makros  fÅr  die  ,,Au·enwelt'' zur VerfÅgung stellen.
    Fehlt  eine Sektionsangabe, so  wird das Makro  vîllig global, d.h.
    ist Åberall benutzbar.
  - GLOBAL[:Sektionsname]  :  legt  fest,  da·  neben diesem Makro noch
    ein  weiteres Makro abgelegt werden soll, das zwar den gleichen In-
    halt  hat, dessen  Name aber  zusÑtzlich mit  dem Namen der Sektion
    versehen  ist, in der  es definiert wurde  und das der spezifizier-
    ten  Sektion zugeordnet werden soll. Bei  dieser mu· es sich um ei-
    ne  Obersektion zu der  aktuellen Sektion handeln;  fehlt die Anga-
    be,  so wird das  zusÑtzliche Makro global  sichtbar. Wird z.B. ein
    Makro  A in der Sektion B  definiert, die wiederum eine Untersekti-
    on  der Sektion C ist,  so wÅrde neben z.B.  dem Makro A ein weite-
    res  globales  mit  dem  Namen  C_B_A  erzeugt. WÅrde dagegen C als
    Zielsektion  angegeben, so wÅrde das Makro  B_A hei·en und der Sek-
    tion  C  zugeordnet.  Diese  Option  ist defaultmÑ·ig ausgeschaltet
    und  hat auch nur  einen Effekt, falls  sie innerhalb einer Sektion
    benutzt  wird. Das lokal bekannte  Originalmakro wird von ihr nicht
    beeinflu·t.
  - EXPORT/NOEXPORT  : legen fest,  ob die Definition  dieses Makros in
    einer  getrennten Datei  abgelegt werden  soll, falls die Kommando-
    zeilenoption  -M gegeben wurde. Auf diese Weise kînnen einzelne De-
    finitionen  ,,privater'' Makros  selektiv ausgeblendet  werden. Der
    Default  ist FALSE, d.h. die Definition wird nicht in der Datei ab-
    gelegt.  Ist zusÑtzlich  die GLOBAL-Option  gegeben worden, so wird
    das Makro mit dem modifizierten Namen abgelegt.
  - INTLABEL/NOINTLABEL  : legen fest, ob ein  in der Zeile mit dem Ma-
    kroaufruf    definiertes   Label   innerhalb    des   Rumpfes   als
    zusÑtzlicher  Parameter verwendet werden soll,  als einfach nur die
    Adresse dieser Zeile zu 'labeln'.

Diese  eben beschriebenen Steuerparameter werden von AS aus der Parame-
terliste  ausgefiltert, haben also keine weitere Wirkung in der folgen-
den Verarbeitung und Benutzung.

Beim  Aufruf eines Makros werden die beim Aufruf angegebenen Parameter-
namen  Åberall textuell im Befehlsblock eingesetzt  und der sich so er-
gebene  Assemblercode wird  normal assembliert.  Sollten beim Aufruf zu
wenige  Parameter angegeben werden, werden Nullstrings eingefÅgt. Wich-
tig  ist  zu  wissen,  da·  bei  der Makroexpansion keine RÅcksicht auf
eventuell  in der  Zeile enthaltene  Stringkonstanten genommen wird. Zu
diesem Detail gilt die alte IBM-Regel:

    It's not a bug, it's a feature!

Diese  LÅcke kann man bewu·t ausnutzen, um Parameter mittels Stringver-
gleichen  abzuprÅfen. So kann  man auf folgende  Weise z.B. prÅfen, wie
ein Makroparameter aussieht:

mul     MACRO   para,parb
        IF      UpString("PARA")<>"A"
         MOV    a,para
        ENDIF
        IF      UpString("PARB")<>"B"
         MOV    b,parb
        ENDIF
        mul     ab
        ENDM

Wichtig  ist bei obigem  Beispiel, da· der  Assembler alle Parameterna-
men  im  case-sensitiven  Modus  in  Gro·buchstaben umsetzt, in Strings
aber  nie eine  Umwandlung in  Gro·buchstaben erfolgt. Die Makroparame-
ternamen  mÅssen in  den Stringkonstanten  daher gro·  geschrieben wer-
den.

FÅr  die Makroparameter gelten die gleichen Konventionen wie bei norma-
len  Symbolen, mit  der Ausnahme,  da· hier  nur Buchstaben und Ziffern
zugelassen  sind,  also  weder  Punkte  noch  Unterstriche.  Diese Ein-
schrÑnkung  hat ihren  Grund in  einem verstecktem  Feature: Der Unter-
strich  erlaubt es, einzelne Makroparameternamen zu einem Symbol zusam-
menzuketten, z.B. in folgendem Beispiel:

concat  MACRO   part1,part2
        CALL    part1_part2
        ENDM

Der Aufruf

        concat  Modul,Funktion

ergibt also

        CALL    Modul_Funktion


Neben  den am Makro selber  angegebenen Parametern existieren vier wei-
tere  'implizite' Parameter, die  immer vorhanden sind  und daher nicht
als eigene Makroparameter verwendet werden sollten:

  -  ATTRIBUTE  bezeichnet bei Architekturen, die Attribute fÅr Prozes-
    sorbefehle  zulassen,  das  bei  einem Makroaufruf angehÑngte Argu-
    ment. FÅr ein Beispiel siehe z.B. unten!
  -  ALLARGS  bezeichnet eine kommaseparierte Liste aller Makroargumen-
    te, z.B., um sie an eine IRP-Anweisung weiterzureichen.
  -  ARGCOUNT  bezeichnet die  tatÑchlich Åbergebene  Anzahl der an das
    Makro  Åbergebenen Argumente. Zu beachten  ist allerdings, da· die-
    se  Zahl niemals geringer als die  Zahl der formalen Parameter ist,
    da AS fehlende Argumente mit Leerstrings auffÅllt!
  -  __LABEL__  bezeichnet das Label, das  in der das Makro aufrufenden
    Zeile  stand. Diese Ersetzung findet nur statt, wenn fÅr dieses Ma-
    kro die INTLABEL-Option gesetzt wurde!


Der  Zweck, ein  Label 'intern'  im Makro  verwenden zu kînnen, ist si-
cher  nicht unmittelbar einleuchtend.  Den einen oder  anderen Fall mag
es  ja geben, in dem  es sinnvoll ist, den  Einsprungpunkt in ein Makro
irgendwo  in seinen  Rumpf zu  verschieben. Der  wichtigste Anwendungs-
fall  sind aber TI-Signalprozessoren, die eine Parallelisierung von Be-
fehlen  durch einen  doppelten senkrechten  Strich in  der Label-Spalte
kennzeichnen, etwa so:

    instr1
||  instr2

(da  die beiden Instruktionen  im Maschinencode in  ein Wort verschmel-
zen,  kann man  die zweite  Instruktion Åbrigens  gar nicht separat an-
springen  -  man  verliert  also  durch  das Belegen der Label-Position
nichts).  Das  Problem  ist  aber, da· einige 'Bequemlichkeits-Befehle'
durch  Makros realisiert werden. Ein vor das Makro geschriebenes Paral-
lelisierungssymbol  wÅrde  normalerweise  dem  Makro selber zugeordnet,
nicht  dem ersten Befehl  im Makro selber.  Aber mit diesem Trick funk-
tioniert's:

myinstr    macro {INTLABEL}
__LABEL__  instr2
           endm

           instr1
||         myinstr

Das  Ergebnis nach der Expansion von  myinstr ist identisch zu dem vor-
herigen Beispiel ohne Makro.

Rekursion  von Makros, also  das wiederholte Aufrufen  eines Makros in-
nerhalb  seines Rumpfes oder  indirekt Åber andere  von ihm aufgerufene
Makros  ist  vollkommen  legal.  Wie  bei  jeder Rekusion mu· man dabei
natÅrlich  sicherstellen, da· sie  irgendwann ein Ende  findet. FÅr den
Fall,  da· man dies vergessen hat,  fÅhrt AS in jedem definierten Makro
einen  ZÑhler mit,  der bei  Beginn einer  Makroexpansion inkrementiert
und  an deren Ende  wieder dekrementiert wird.  Bei rekursiven Aufrufen
eines  Makros erreicht dieser  ZÑhler also immer  hîhere Werte, und bei
einem  per NESTMAX einstellbaren Wert bricht  AS ab. Vorsicht, wenn man
diese  Bremse abschaltet: der  Speicherbedarf auf dem  Heap kann so be-
liebig steigen und selbst ein Unix-System in die Knie zwingen...

Um  alle Klarheiten auszurÑumen, ein  einfaches Beispiel: Ein intelver-
blîdeter  Programmierer mîchte die Befehle  PUSH/POP unbedingt auch auf
dem 68000 haben. Er lîst das ,,Problem'' folgenderma·en:

push    MACRO   op
        MOVE.ATTRIBUTE op,-(sp)
        ENDM

pop     MACRO   op
        MOVE.ATTRIBUTE (sp)+,op
        ENDM

Schreibt man nun im Code

        push    d0
        pop.l   a2        ,

so wird daraus

        MOVE.   d0,-(sp)
        MOVE.L  (sp)+,a2

Eine Makrodefinition darf nicht Åber Includefilegrenzen hinausgehen.

In  MakrorÅmpfen definierte  Labels werden  immer als lokal betrachtet,
ein  expliziter LOCAL-Befehl ist also  nicht erforderlich (und ist auch
nicht  definiert). Ist  es aus  irgendwelchen GrÅnden  erforderlich, so
kann   man  es  mit   LABEL  definieren,  dessen   Anwendung  (wie  bei
BIT,SFR...) immer globale Symbole ergibt :

<Name>  LABEL   *

Da  der Assembler  beim Parsing  einer Zeile  zuerst die Makroliste und
danach  die Prozessorbefehle abklappert,  lassen sich auch Prozessorbe-
fehle  neu definieren. Die  Definition sollte dann  aber vor der ersten
Benutzung  des  Befehles  durchgefÅhrt  werden,  um Phasenfehler wie im
folgenden Beispiel zu vermeiden:

        BSR     ziel

bsr     MACRO   target
        JSR     ziel
        ENDM

        BSR     ziel

Im  ersten Pass  ist bei  der Assemblierung  des BSR-Befehles das Makro
noch  nicht bekannt, es wird ein 4 Byte langer Befehl erzeugt. Im zwei-
ten  Pass  jedoch  steht  die  Makrodefinition  sofort  (aus dem ersten
Pass)  zur VerfÅgung, es wird  also ein 6 Byte  langer JSR kodiert. In-
folgedessen  sind alle darauffolgenden  Labels um zwei  zu niedrig, bei
allen  weiteren Labels  sind Phasenfehler  die Folge,  und ein weiterer
Pass ist erforderlich.

Da  durch  die  Definition  eines  Makros  ein gleichnamiger Maschinen-
oder  Pseudobefehl nicht mehr  zugreifbar ist, gibt  es eine HintertÅr,
die  Originalbedeutung zu erreichen: Stellt man dem Mnemonic ein ! vor-
an,  so wird das Durchsuchen der  Makroliste unterdrÅckt. Das kann bei-
spielsweise  nÅtzlich sein, um  Befehle in ihrer  MÑchtigkeit zu erwei-
tern, z.B. die Schiebebefehle beim TLCS-90:

srl     macro   op,n      ; Schieben um n Stellen
        rept    n         ; n einfache Befehle
         !srl   op
        endm
        endm

Fortan hat der SRL-Befehl einen weiteren Parameter...


        3.4.2.  IRP
        - - - - - -

ist  die  eine  vereinfachte  Form  von Makrodefinitionen fÅr den Fall,
da·  eine Befehlsfolge  einmal auf  mehrere Operanden angewendet werden
soll  und danach nicht mehr gebraucht wird. IRP benîtigt als ersten Pa-
rameter  ein Symbol fÅr den Operanden,  und danach eine (fast) beliebi-
ge  Menge von Parametern,  die nacheinander in  den Befehlsblock einge-
setzt  werden. Um eine  Menge von Registern  auf den Stack zu schieben,
kann man z.B. schreiben

        IRP     op, acc,b,dpl,dph
        PUSH    op
        ENDM

was in folgendem resultiert:

        PUSH    acc
        PUSH    b
        PUSH    dpl
        PUSH    dph

Benutzte Labels sind wieder fÅr jeden Durchgang automatisch lokal.


        3.4.3. IRPC
        - - - - - -

IRPC  ist eine Variante von IRP, bei  der das erste Argument in den bis
ENDM  folgenden Zeilen  nicht sukzessiv  durch die  weiteren Parameter,
sondern  durch  die  Zeichen  eines  Strings ersetzt wird. Einen String
kann man z.B. also auch ganz umstÑndlich so im Speicher ablegen:

        irpc    char,"Hello World"
        db      'CHAR'
        endm

ACHTUNG!  Wie das Beispiel schon zeigt, setzt IRPC nur das Zeichen sel-
ber  ein, da·  daraus ein  gÅltiger Ausdruck  entsteht (also hier durch
die  Hochkommas, inklusive des Details, da· hier keine automatische Um-
wandlung  in Gro·buchstaben  vorgenommen wird),  mu· man selber sicher-
stellen.


        3.4.4. REPT
        - - - - - -

ist  die einfachste  Form der  Makrobenutzung. Der  im Rumpf angegebene
Code  wird  einfach  sooft  assembliert,  wie  der Integerparameter von
REPT  angibt. Dieser Befehl  wird hÑufig in  kleinen Schleifen anstelle
einer  programmierten Schleife  verwendet, um  den Schleifenoverhead zu
sparen.

Der VollstÑndigkeit halber ein Beispiel:

        REPT    3
        RR      a
        ENDM

rotiert den Akku um 3 Stellen nach rechts.

Symbole sind wiederum fÅr jede einzelne Repetition lokal.

Ist  das Argument von REPT kleiner  oder gleich Null, so wird Åberhaupt
keine  Expansion  durchgefÅhrt.  Dies  ist  ein Unterschied zu frÅheren
Versionen  von AS, die hier etwas  ,,schlampig'' waren und immer minde-
stens eine Expansion ausfÅhrten.


        3.4.5.  WHILE
        - - - - - - -

WHILE  arbeitet analog  zu REPT,  allerdings tritt  an die Stelle einer
festen  Anzahl als Argument  ein boolescher Ausdruck,  und der zwischen
WHILE  und ENDM  eingeschlossene Code  wird sooft  assenbliert, bis der
Ausdruck  logisch falsch  wird. Im  Extremfall kann  dies bedeuten, da·
der  Code  Åberhaupt  nicht  assembliert  wird, falls die Bedingung be-
reits  beim Eintritt in das Konstrukt  falsch ist. Andererseits kann es
natÅrlich  auch passieren, da· die Bedingung  immer wahr bleibt, und AS
lÑuft  bis an das Ende aller  Tage...hier sollte man also etwas Umsicht
walten  lassen, d.h. im Rumpf mu· eine Anweisung stehen, die die Bedin-
gung auch beeinflu·t, z.B. so:

cnt     set     1
sq      set     cnt*cnt
        while   sq<=1000
         dc.l    sq
cnt      set     cnt+1
sq       set     cnt*cnt
        endm

Dieses Beispiel legt alle Quadratzahlen bis 1000 im Speicher ab.

Ein  unschînes Detail bei  WHILE ist im  Augenblick leider noch, da· am
Ende  der  Expansion  eine  zusÑtzliche  Leerzeile,  die  im Quellrumpf
nicht  vorhanden  war,  eingefÅgt  wird.  Dies ist ein ,,Dreckeffekt'',
der  auf einer SchwÑche des Makroprozessors  beruht und leider nicht so
einfach zu beheben ist. Hoffentlich stîrt es nicht allzusehr....


        3.4.6.  EXITM
        - - - - - - -

EXITM  stellt einen Weg dar, um  eine Makroexpansion oder einen der Be-
fehle   REPT,  IRP  oder  WHILE   vorzeitig  abzubrechen.  Eine  solche
Mîglichkeit  hilft  zum  Beispiel,  umfangreichere Klammerungen mit IF-
ENDIF-Sequenzen  in Makros Åbersichtlicher zu gestalten. Sinnvollerwei-
se  ist ein EXITM aber selber auch  immer bedingt, was zu einem wichti-
gen  Detail fÅhrt: Der Stack, der Åber momentan offene IF- oder SWITCH-
Konstrukte  Buch fÅhrt, wird auf den Stand vor Beginn der Makroexpansi-
on  zurÅckgesetzt. Dies  ist fÅr  bedingte EXITM's  zwingend notwendig,
da  das den EXITM-Befehl in  irgendeiner Form einschlie·ende ENDIF oder
ENDCASE  nicht mehr erreicht wird und  AS ohne einen solchen Trick eine
Fehlermeldung  erzeugen wÅrde. Weiterhin ist  es fÅr verschachtelte Ma-
krokonstruktionen  wichtig, zu beachten, da· EXITM immer nur das momen-
tan  innerste Konstrukt  abbricht! Wer  aus seiner  geschachtelten Kon-
struktion  vollstÑndig ,,ausbrechen'' will, mu·  auf den hîheren Ebenen
ebenfalls EXITM's vorsehen!


        3.4.7.  SHIFT
        - - - - - - -

SHIFT  ist ein Mittel,  um Makros mit  variablen Argumentlisten abzuar-
beiten:  Es verwirft den ersten Parameter,  so da· der zweite Parameter
seinen  Platz einnimmt usw. Auf diese  Weise kînnte man sich durch eine
variable  Argumentliste durcharbeiten...wenn man es richtig macht. Fol-
gendes funktioniert zum Beispiel nicht...

pushlist  macro reg
          rept  ARGCOUNT
          push  reg
          shift
          endm
          endm

...weil  das Makro einmal expandiert wird,  seine Ausgabe von REPT auf-
genommen  und dann n-fach ausgefÅhrt wird.  Das erste Argument wird al-
so n-fach gesichert...besser geht es schon so:

pushlist  macro reg
          if      "ARG"<>""
           push    arg
           shift
           pushlist ALLARGS
          endif
          endm

Also  eine Rekursion, in  der pro Schritt  die Argumentliste ( ALLARGS)
um  eins verkÅzt wird. Der wichtige Trick  ist, da· jedes Mal eine neue
Expansion gestartet wird...


        3.4.8.  MAXNEST
        - - - - - - - -

Mit  MAXNEST kann  man einstellen,  wie oft  ein Makro maximal rekursiv
aufgerufen  werden  kann,  bevor  AS  mit einer Fehlermeldung abbricht.
Dies  darf ein beliebiger  ganzer, positiver Wert  sein, wobei der Son-
derwert  0  diese  Sicherheitsbremse  komplett abschaltet (vorsicht da-
mit...).  Der  Vorgabewert  fÅr  die maximale Verschachtelungstiefe ist
256;  die momentante Einstellung kann  aus ener gleichnamigen Variablen
gelesen werden.


        3.4.9. FUNCTION
        - - - - - - - -

FUNCTION  ist zwar kein  Makrobefehl im engeren  Sinne, da hierbei aber
Ñhnliche  Mechanismen wie bei  Makroersetzungen angewendet werden, soll
er hier beschrieben werden.

Dieser  Befehl dient dazu,  neue Funktionen zu  definieren, die in For-
melausdrÅcken   wie  die  vordefinierten  Funktionen  verwendet  werden
kînnen. Die Definition mu· in folgender Form erfolgen:

<Name>  FUNCTION <Arg>,..,<Arg>,<Ausdruck>

Die   Argumente  sind  die   Werte,  die  sozusagen   in  die  Funktion
,,hineingesteckt''  werden. In der Definition  werden fÅr die Argumente
symbolische  Namen  gebraucht,  damit  der  Assembler bei der Benutzung
der  Funktion wei·, an welchen  Stellen die aktuellen Werte einzusetzen
sind. Dies kann man an folgendem Beispiel sehen:

isgit   FUNCTION ch,(ch>='0')&&(ch<='9')

Diese  Funktion ÅberprÅft,  ob es  sich bei  dem Argument  (wenn man es
als  Zeichen interpretiert)  um eine  Ziffer im  momentan gÅltigen Zei-
chencode   handelt  (der  momentane  Zeichencode  ist  mittels  CHARSET
verÑnderbar, daher die vorsichtige Formulierung).

Die  Argumentnamen (in  diesem Falle  CH) mÅssen  den gleichen hÑrteren
Symbolkonventionen  genÅgen  wie  Parameter  bei einer Makrodefinition,
d.h. die Sonderzeichen . und _ sind nicht erlaubt.

Selbstdefinierte  Funktionen  werden  genauso  benutzt  wie eingebaute,
d.h. mit einer durch Kommas getrennten, geklammerten Argumentliste:

        IF isdigit(Zeichen)
         message "\{Zeichen} ist eine Ziffer"
        ELSEIF
         message "\{Zeichen} ist keine Ziffer"
        ENDIF


Bei  dem Aufruf der Funktion werden  die Argumente nur einmal berechnet
und  danach an allen  Stellen der Formel  eingesetzt, um den Rechenauf-
wand  zu reduzieren und Seiteneffekte  zu vermeiden. Bei Funktionen mit
mehreren  Argumenten mÅssen  die einzelnen  Argumente bei der Benutzung
durch Kommata getrennt werden.

ACHTUNG!  Analog wie bei  Makros kann man  mit der Definition von Funk-
tionen  bestehende Funktionen umdefinieren. Damit lassen sich auch wie-
der  Phasenfehler  provozieren.  Solche  Definitionen sollten daher auf
jeden Fall vor der ersten Benutzung erfolgen!

Da  die  Berechnung  des  Funktionsergebnisses  anhand  des  Formelaus-
druckes  auf  textueller  Ebene  erfolgt,  kann der Ergebnistyp von dem
Typ des Eingangsargumentes abhÑngen. So kann bei folgender Funktion

double  function x,x+x

das  Ergebnis ein  Integer, eine  Gleitkommazahl oder  sogar ein String
sein, je nach Typ des Arguments!

Bei   der  Definition  und  Ansprache  von  Funktionen  wird  im  case-
sensitiven  Modus zwischen Gro·-  und Kleinschreibung unterschieden, im
Gegensatz zu eingebauten Funktionen!


        3.5. Strukturen
        ---------------

GÅltigkeit: alle Prozessoren

Auch  in Assemblerprogrammen ergibt  sich dann und  wann die Notwendig-
keit,  analog zu Hochsprachen zusammengesetzte Datenstrukturen zu defi-
nieren.  AS unterstÅtzt sowohl die Definition  als auch die Nutzung von
Strukturen  mit  einer  Reihe  von  Konstrukten und Anweisungen, die im
folgenden erlÑutert werden sollen:


        3.5.1. Definition
        - - - - - - - - -

Die  Definition einer Struktur wird  duch den Befehl STRUCT eingeleitet
und  durch  ENDSTRUCT  abgeschlossen  (schreibfaule Zeitgenossen dÅrfen
aber  auch stattdessen STRUC bzw.  ENDS schreiben). Ein diesen Befehlen
voranstehendes  Label wird als  Name der zu  definierenden Struktur ge-
nommen;  am Ende der Definition ist der  Name optional und kann von zur
Festlegung  des LÑngennamens (s.u.) genutzt  werden. Das restliche Ver-
fahren  ist simpel: Mit einem  STRUCT wird der momentane ProgrammzÑhler
gesichert  und auf  Null zurÅckgesetzt.  Alle zwischen  STRUCT und END-
STRUCT  definierten Labels ergeben mithin die Offsets der einzelnen Da-
tenfelder  in der Struktur.  Die Reservierung des  Platzes fÅr die ein-
zelnen  Felder erfolgt  mit den  fÅr den  jeweils aktiven Zielprozessor
zulÑssigen  Befehlen zur Speicherplatzreservierung,  also z.B. DS.x fÅr
die  Motorolas oder DB  & Co. fÅr  Intels. Es gelten  hier auch gleich-
falls  die Regeln fÅr das Aufrunden von LÑngen, um Alignments zu erhal-
ten  - wer  also 'gepackte'  Strukturen definieren  will, mu· eventuell
ein  PADDING  OFF  voranstellen.  Umgekehrt  lassen  sich Ausrichtungen
natÅrlich mit Befehlen wie ALIGN erzwingen.

Da  eine solche Definition nur  eine Art 'Prototypen' darstellt, kînnen
nur  Befehle benutzt werden, die  Speicherplatz reservieren, aber keine
solchen, die Konstanten im Speicher ablegen oder Code erzeugen.

Innerhalb  von Strukturen definierte Labels (also die Namen der Elemen-
te)  werden nicht direkt abgespeichert, sondern  es wird ihnen der Name
der  Struktur vorangestellt, durch ein  Trennzeichen verbunden, bei dem
es  sich defaultmÑ·ig um den  Unterstrich (_) handelt. Dieses Verhalten
lÑ·t sich aber durch dem STRUCT-Befehl mitgegebene Argumente steuern:

  - NOEXTNAMES  unterdrÅckt  das  Voranstellen  des Strukturnamens. Der
    Programmierer  ist in diesem Falle  selber dafÅr verantworlich, da·
    Feldnamen nicht mehrfach verwendet werden.
  - DOTS  weist AS  an, als  verbindendes Zeichen  einen Punkt anstelle
    des  Unterstriches zu verwenden. Es  sei jedoch ausdrÅcklich darauf
    hingewiesen,  da· der Punkt bei  vielen Zielprozessoren ein Sonder-
    funktion  zur  Bitadressierung  hat  und  diese zu Problemen fÅhren
    kann!

Des  weiteren ist es mîglich, die  Verwendung des Punktes durch den Be-
fehl

        dottedstructs <on|off>

dauerhaft ein- bzw. auszuschalten.

Neben  den Namen der Elemente definiert  AS beim Abschlu· der Definiti-
on  ein weiteres Symbol  mit dem Namen  LEN, das nach  dem gleichen Re-
geln  um den  Namen der  Struktur erweitert  wird -  oder um den Label-
Namen, der optional bei ENDSTRUCT angegeben werden kann.

Das ganze sieht dan in der Praxis z.B. so aus:

Rec     STRUCT
Ident   db      ?
Pad     db      ?
Pointer dd      ?
Rec     ENDSTRUCT

Hier wÅrde z.B. dem Symbol REC_LEN der Wert 6 zugewiesen.


        3.5.2.  Nutzung
        - - - - - - - -

Ist  eine Struktur  einmal definiert,  ist die  Nutzung denkbar einfach
und Ñhnlich wie ein Makro: ein einfaches

thisrec Rec

reserviert  Speicher  in  der  Menge,  wie  er  von der Struktur belegt
wird,  und definiert  gleichzeitig fÅr  jedes Element  der Struktur ein
passendes  Symbol  mit  dessen  Adresse,  in  diesem  Falle  also THIS-
REC_IDENT,  THISREC_PAD  und  THISREC_POINTER.  Das  Label darf bei dem
Aufruf  einer Struktur naturgemÑ· nicht  fehlen; wenn doch, gibt's eine
Fehlermeldung.

ACHTUNG!  Obwohl AS keine  Argumente bei der  Definition einer Struktur
erwartet,  werden gegebene  Argumente nicht  als Fehler  gemeldet, son-
dern  schlicht ignoriert. Dies ist vorgesehen,  um in Zukunft einer de-
klarierten Struktur direkt Werte zuweisen zu kînnen.


        3.5.3. geschachtelte Strukturen
        - - - - - - - - - - - - - - - -

Es  ist ohne weiteres erlaubt, eine  bereits definierte Struktur in ei-
ner  anderen Struktur  aufzurufen. Das  dabei ablaufende  Verfahren ist
eine  Kombination  aus  den  beiden  vorigen Punkten: Elemente der Sub-
struktur  werden  definiert,  mit  dem  Namen  dieser  Instanz vorange-
stellt,  und  vor  diese  zusammengesetzten  Namen wird wieder der Name
der  Struktur bzw. spÑter  bei einer Benutzung  gesetzt. Das sieht dann
z.B. so aus:

TreeRec struct
left    dd         ?
right   dd         ?
data    Rec
TreeRec endstruct



        3.5.4. Unions
        - - - - - - -

Eine  Union ist eine  Sonderform einer Struktur,  bei der die einzelnen
Elemente  nicht hintereinander, sondern  Åbereinander liegen, d.h. alle
Elemente  liegen an Startadresse  0 innerhalb der  Struktur und belegen
den  gleichen Speicherplatz.  NaturgemÑ· tut  so eine  Definition nicht
mehr,  als einer Reihe von Symbolen  den Wert Null zuzuweisen, sie kann
aber  sinnvoll sein, um programmtechnisch  die öberlappung der Elemente
zu  verdeutlichen und  den Code  so etwas  'lesbarer' zu gestalten. Die
Grî·e einer Struktur ist das Maximum der Grî·en aller Elemente.


        3.5.5. Strukturen und Sektionen
        - - - - - - - - - - - - - - - -

Im  Verlaufe der Definition oder  der Nutzung von Strukturen definierte
Symbole  werden  genauso  behandelt  wie  normale Symbole, d.h. bei der
Nutzung  innerhalb einer Sektion werden diese Symbole als lokal zu die-
ser  Sektion definiert. Analoges gilt aber auch fÅr die Strukturen sel-
ber,  d.h. eine innerhalb einer  Sektion definierte Struktur kann nicht
auârhalb der Sektion benutzt werden.


        3.6. bedingte Assemblierung
        ---------------------------

GÅltigkeit: alle Prozessoren

Der  Assembler  unterstÅtzt  die  bedingte  Assemblierung mit Hilfe der
Konstrukte  IF... sowie  SWITCH... .  Diese Befehle  wirken zur Assemb-
lierzeit,   indem  entsprechend  der  Bedingung  Teile  Åbersetzt  oder
Åbersprungen  werden.  Diese  Befehle  sind  also  nicht  mit  den  IF-
Statements  hîherer Programmiersprachen zu  vergleichen (obwohl es sehr
verlockend  wÑre, den  Assembler um  die Strukturierungsbefehle hîherer
Sprachen zu erweitern...).

Die  folgenden  Konstrukte  dÅrfen  beliebig (bis zum SpeicherÅberlauf)
geschachtelt werden.


        3.6.1.  IF / ELSEIF / ENDIF
        - - - - - - - - - - - - - -

IF  ist das gebrÑuchlichere und  allgemeiner verwendbare Konstrukt. Die
allgemeine Form eines IF-Befehles lautet folgenderma·en:

       IF       <Ausdruck 1>
        <Block 1>
       ELSEIF   <Ausdruck 2>
        <Block 2>
       (evtl. weitere ELSEIFs)
       ELSEIF
        <Block n>
       ENDIF

IF  dient als Einleitung und wertet den ersten Ausdruck aus und assemb-
liert  Block 1,  falls der  Ausdruck wahr  (d.h. ungleich  0) ist. Alle
weiteren  ELSEIF-Teile werden  dann ignoriert.  Falls der Ausdruck aber
nicht  wahr ist, wird Block 1  Åbersprungen und Ausdruck 2 ausgewertet.
Sollte  dieser nun  wahr sein,  wird Block  2 assembliert. Die Zahl der
ELSEIF-Teile  ist variabel und ergibt eine IF-THEN-ELSE-Leiter beliebi-
ger  LÑnge. Der dem  letzten ELSEIF (ohne  Parameter) zugeordnete Block
wird  nur assembliert, falls alle  vorigen AusdrÅcke falsch ergaben und
bildet  sozusagen  einen  ,,Default-Zweig''.  Wichtig  ist, da· von den
Blîcken  immer nur einer  assembliert wird, und  zwar der erste, dessen
zugeordnetes IF/ELSEIF einen wahren Ausdruck hatte.

Die  ELSEIF-Teile sind  optional, d.h.  auf IF  darf auch  direkt ENDIF
folgen,  ein  parameterloses  ELSEIF  bildet  aber  immer  den  letzten
Zweig.  Ein ELSEIF bezieht sich immer  auf das letzte, noch nicht abge-
schlossene IF.

Neben IF sind noch folgende weitere bedingte Befehle definiert:

  - IFDEF  <Symbol> : wahr, falls das Symbol definiert wurde. Die Defi-
    nition mu· vor IFDEF erfolgt sein.
  - IFNDEF <Symbol> : Umkehrung zu IFDEF
  - IFUSED  <Symbol> : wahr, falls  das Symbol bisher mindestens einmal
    benutzt wurde.
  - IFNUSED <Symbol> : Umkehrung zu IFUSED
  - IFEXIST  <Name:  >  :  wahr,  falls die angegebene Datei existiert.
    FÅr  Schreibweise und Suchpfade gelten  gleiche Regeln wie beim IN-
    CLUDE-Befehl (siehe Abschnitt 3.9.2).
  - IFNEXIST <Name: > : Umkehrung zu IFEXIST
  - IFB  <Arg-Liste> :  wahr, falls  alle Argumente  der Parameterliste
    leer sind.
  - IFNB <Arg-Liste> : Umkehrung zu IFB.


Anstelle  von ELSEIF darf  auch ELSE geschrieben  werden, weil das wohl
alle so gewohnt sind....

Zu  jeder  IF...-Anweisung  gehîrt  ein  entsprechendes ENDIF, 'offene'
Konstrukte  fÅhren zu  einer Fehlermeldung  am Ende des Assemblierungs-
laufes.  Die Zuordnung,  welches ENDIF  AS mit  welchem IF... 'gepaart'
hat,  lÑ·t sich  im Listing  erkennen: dort  wird die  Zeilennummer des
entsprechenden IFs angezeigt.


        3.6.2. SWITCH / CASE / ELSECASE / ENDCASE
        - - - - - - - - - - - - - - - - - - - - -

SWITCH  ist ein Spezialfall  von IF und  fÅr den Fall  gedacht, da· ein
Ausdruck  mit einer Reihe  von Werten verglichen  werden soll. Dies ist
natÅrlich  auch mit IF und einer Reihe von ELSEIFs machbar, die folgen-
de Form

       SWITCH   <Ausdruck>
       ...
       CASE     <Wert 1>
       ...
       <Block 1>
       ...
       CASE <Wert 2>
       ...
       <Block 2>
       ...
       (weitere CASE-Konstrukte)
       ...
       CASE <Wert n-1>
       ...
       <Block n-1>
       ...
       ELSECASE
       ...
       <Block n>
       ...
       ENDCASE

bietet  aber den Vorteil, da· der  zu prÅfende Ausdruck nur einmal hin-
geschrieben  und  berechnet  werden  mu·,  er  ist  also  weniger  feh-
leranfÑllig  und  etwas  schneller  als  eine IF-Kette, dafÅr natÅrlich
auch nicht so flexibel.

Es  ist mîglich,  bei den  CASE-Anweisungen mehrere,  durch Kommata ge-
trennte  Werte  anzugeben,  um  den  entsprechenden  Block  in mehreren
FÑllen  assemblieren zu  lassen. Der  ELSECASE-Zweig dient wiederum als
,,Auffangstelle''   fÅr  den  Fall,   da·  keine  der  CASE-Bedingungen
greift.  Fehlt er und fallen alle PrÅfungen negativ aus, so gibt AS ei-
ne Warnung aus.

Auch  wenn die Wertelisten der CASE-Teile  sich Åberlappen, so wird im-
mer  nur ein  Zweig ausgefÅhrt,  und zwar  bei Mehrdeutigkeiten der er-
ste.

SWITCH  dient nur der  Einleitung des ganzen  Konstruktes; zwischen ihm
und  dem ersten  CASE darf  beliebiger Code  stehen (andere  IFs dÅrfen
aber  nicht offen bleiben!), im Sinne eines durchschaubaren Codes soll-
te davon aber kein Gebrauch gemacht werden.

éhnlich  wie bei IF...-Konstrukten,  mu· es fÅr  jedes SWITCH genau ein
ENDCASE  geben. Analog zu ENDIF wird bei ENDCASE im Listing die Zeilen-
nummer des korrespondierenden SWITCH angezeigt.


        3.7. Listing-Steuerung
        ----------------------

GÅltigkeit: alle Prozessoren


        3.7.1. PAGE
        - - - - - -

Mit  PAGE kann man AS die Dimensionen  des Papiers, auf dem das Listing
ausgedruckt  werden soll,  mitteilen. Als  erster Parameter  wird dabei
die  Anzahl von Zeilen angegeben, nach der AS automatisch einen Zeilen-
vorschub  ausgeben  soll.  Zu  berÅcksichtigen  ist allerdings, da· bei
dieser  Angabe die Kopfzeilen inklusive  einer evtl. mit TITLE spezifi-
zierten  Zeile nicht mitgerechnet werden.  Der Minimalwert fÅr die Zei-
lenzahl  ist 5, der Maximalwert 255. Eine  Angabe von 0 fÅhrt dazu, da·
AS  Åberhaupt  keine  automatischen  SeitenvorschÅbe  ausfÅhrt, sondern
nur  noch solche, die  explizit durch NEWPAGE-Befehle  oder implizit am
Ende  des Listings (z.B.  vor der Symboltabelle)  von AS ausgelîst wur-
den.

Die  Angabe  der  Breite  des  Listings  in Zeichen kann als optionaler
zweiter  Parameter erfolgen  und erfÅllt  zwei Zwecke:  Zum einen lÑuft
der  ZeilenzÑhler  von  AS  korrekt  weiter, wenn eine Quell-Zeile Åber
mehrere  Listing-Zeilen geht, zum anderen gibt es Drucker (wie z.B. La-
serdrucker),  die beim  öberschreiten des  rechten Randes nicht automa-
tisch   in  eine  neue  Zeile   umbrechen,  sondern  den  Rest  einfach
,,verschlucken''.  Aus  diesem  Grund  fÅhrt  AS auch den Zeilenumbruch
selbststÑndig  durch, d.h. zu  lange Zeilen werden  in BruchstÅcke zer-
legt,  die eine LÑnge  kleiner oder gleich  der eingestellten LÑnge ha-
ben.  In Zusammenhang  mit Druckern,  die einen automatischen Zeilenum-
bruch  besitzen, kann  das aber  zu doppelten  ZeilenvorschÅben fÅhren,
wenn  man als  Breite exakt  die Zeilenbreite  des Druckers angibt. Die
Lîsung  in einem solchen  Fall ist, als  Zeilenbreite ein Zeichen weni-
ger  anzugeben. Die eingestellte  Zeilenbreite darf zwischen  5 und 255
Zeichen  liegen; analog  zur SeitenlÑnge  bedeutet ein  Wert von 0, da·
AS   keine   Splittung   der   Listing-Zeilen   vornehmen   soll;  eine
BerÅcksichtigung  von zu  langen Zeilen  im Listing  beim Seitenumbruch
kann dann natÅrlich auch nicht mehr erfolgen.

Die  Defaulteinstellung fÅr die SeitenlÑnge ist 60 Zeilen, fÅr die Zei-
lenbreite  0; letztere Wert wird auch angenommen, wenn PAGE nur mit ei-
nem Argument aufgerufen wird.

ACHTUNG!  AS hat keine Mîglichkeit,  zu ÅberprÅfen, ob die eingestellte
Listing-LÑnge und Breite mit der Wirklichkeit Åbereinstimmen!


        3.7.2.  NEWPAGE
        - - - - - - - -

NEWPAGE  kann dazu  benutzt werden,  einen Seitenvorschub zu erzwingen,
obwohl  die  Seite  noch  gar  nicht  voll ist. Dies kann z.B. sinnvoll
sein,  um  logisch  voneinander  getrennte  Teile  im Assemblerprogramm
auch  seitenmÑ·ig  zu  trennen.  Der  programminterne ZeilenzÑhler wird
zurÅckgesetzt,  der SeitenzÑhler  um Eins  heraufgezÑhlt. Der optionale
Parameter  steht in  Zusammenhang mit  einer hierarchischen Seitennume-
rierung,  die AS bis zu einer  Kapiteltiefe von 4 unterstÅtzt. 0 bedeu-
tet  dabei immer  die tiefste  Kapitelebene, der  Maximalwert kann sich
wÑhrend  des Laufes  verÑndern, wenn  das auch  verwirrend wirken kann,
wie folgendes Beispiel zeigt:


    Seite 1,    Angabe NEWPAGE 0    -> Seite 2
    Seite 2,    Angabe NEWPAGE 1    -> Seite 2.1
    Seite 2.1,  Angabe NEWPAGE 1    -> Seite 3.1
    Seite 3.1,  Angabe NEWPAGE 0    -> Seite 3.2
    Seite 3.2,  Angabe NEWPAGE 2    -> Seite 4.1.1


Je  nach momentan  vorhandener Kapiteltiefe  kann NEWPAGE <Nummer> also
an  verschiedenen  Stellen  eine  Erhîhung  bedeuten. Ein automatischer
Seitenvorschub  wegen ZeilenÅberlauf  oder ein  fehlender Parameter ist
gleichbedeutend  mit NEWPAGE 0.  Am Ende des  Listings wird vor Ausgabe
der   Symboltabelle  ein  implizites  NEWPAGE  <bish.  Maximum>  durch-
gefÅhrt, um sozusagen ein neues Hauptkapitel zu beginnen.


        3.7.3. MACEXP
        - - - - - - -

Mit dem Befehl

        MACEXP  off

kann  man erreichen, da· bei  Makroexpansionen nur noch der Makroaufruf
und  nicht der expandierte  Text ausgegeben wird.  Die ist bei makroin-
tensivem  Code sinnvoll, um  das Listing nicht  ins Uferlose wachsen zu
lassen. Mit

        MACEXP  on

wird  die vollstÑndige Listingform wieder  eingeschaltet, dies ist auch
die Default-Vorgabe.

Zwischen  der Bedeutung von MACEXP fÅr  Makros und der fÅr alle anderen
makroartigen  Konstrukte (z.B. REPT)  besteht ein subtiler Unterschied:
WÑhrend  Makros intern ein  Flag besitzen, das  anzeigt, ob Expansionen
dieses  Makros ausgegeben  werden sollen  oder nicht,  wirkt MACEXP di-
rekt  auf alle  anderen Konstrukte,  die ,,vor  Ort'' aufgelîst werden.
Der  Sinn  dieser  Differenzierung  besteht  darin, da· es Makros geben
kann,  die ausgetestet sind  und die man  nicht mehr sehen will, andere
aber  sehr wohl noch. MACEXP dient hier als Default fÅr das bei der De-
finition  des Makros zu setzende Flag, der mit den Steuerparametern NO-
EXPAND/EXPAND Åbersteuert werden kann.

Die momentane Einstellung lÑ·t sich aus dem Symbol MACEXP auslesen.


        3.7.4.  LISTING
        - - - - - - - -

funktioniert  wie MACEXP und akzeptiert  die gleichen Parameter, arbei-
tet aber wesentlich radikaler: Mit

        LISTING off

wird  Åberhaupt  nichts  mehr  im  Listing  ausgegeben. Diese Anweisung
macht  Sinn fÅr erprobte Codeteile oder Includefiles, um den Papierver-
brauch  nicht ins Unerme·liche zu steigern. ACHTUNG! Wer spÑter das Ge-
genstÅck  vergi·t,  bekommt  auch  keine  Symboltabelle  mehr zu sehen!
ZusÑtzlich  zu ON und OFF akzeptiert LISTING auch NOSKIPPED und PURECO-
DE  als Argument. Mit der NOSKIPPED-Einstellung werden aufgrund beding-
ter  Assemblierung  nicht  assemblierte  Teile  nicht  im  Listing auf-
gefÅhrt,  wÑhrend PURECODE  - wie  der Name  schon erahnen  lÑ·t - auch
die  IF-Konstrukte selber  nicht mehr  im Listing  auffÅhrt. Diese Ein-
stellungen  sind nÅtzlich, wenn  man Makros, die  anhand von Parametern
verschiedene  Aktionen ausfÅhren, benutzt, und  im Listing nur noch die
jeweils benutzten Teile sehen mîchte.

Die  momentane  Einstellung  lÑ·t  sich  aus dem Symbol LISTING (0=OFF,
1=ON, 2=NOSKIPPED, 3=PURECODE) auslesen.


        3.7.5.  PRTINIT und PRTEXIT
        - - - - - - - - - - - - - -

Bei  der  Listingausgabe  auf  Druckern  ist  es  oftmals sinnvoll, den
Drucker  in eine  andere Betriebsart  (z.B. Schmalschrift) umzuschalten
und  am  Ende  des  Listings  diese Betriebsart wieder zu deaktivieren.
Mit  diesen  Befehlen  kann  die  Ausgabe dieser Steuerfolgen automati-
siert werden, indem man mit

        PRTINIT <String>

die  Zeichenfolge angibt, die vor Listingbeginn an das AusgabegerÑt ge-
schickt werden soll und mit

        PRTEXIT <String>

analog  den  Deinitialisierungsstring.  In  beiden  FÑllen mu· <String>
ein   Stringausdruck  sein.   Die  Syntaxregeln   fÅr  Stringkonstanten
ermîglichen  es, ohne  Verrenkungen Steuerzeichen  in den String einzu-
bauen.

Bei  der Ausgabe dieser Strings  unterscheidet der Assembler nicht, wo-
hin  das  Listing  geschickt  wird,  d.h.  Druckersteuerzeichen  werden
rÅcksichtslos auch auf den Bildschirm geschickt!

Beispiel :

Bei  Epson-Druckern ist  es sinnvoll,  fÅr die  breiten Listings in den
Kompre·druck zu schalten. Die beiden Zeilen

        PRTINIT "\15"
        PRTEXIT "\18"

sorgen  dafÅr, da· der Kompre·druck ein- und nach dem Druck wieder aus-
geschaltet wird.


        3.7.6.  TITLE
        - - - - - - -

Normalerweise  versieht der Assembler bereits jede Listingseite mit ei-
ner  Titelzeile, die Quelldatei, Datum  und Uhrzeit enthÑlt. Mit diesem
Befehl  kann man den Seitenkopf um eine beliebige zusÑtzliche Zeile er-
weitern.  Der anzugebende  String ist  dabei ein  beliebiger Stringaus-
druck.

Beispiel:

Bei  dem bereits  oben angesprochenenen  Epson-Drucker soll eine Titel-
zeile  im Breitdruck  ausgegeben werden,  wozu vorher  der Kompre·modus
abgeschaltet werden mu·:

        TITLE   "\18\14Breiter Titel\15"

(Epson-Drucker   schalten  den  Breitdruck  automatisch  am  Zeilenende
aus.)


        3.7.7.  RADIX
        - - - - - - -

RADIX  mit  einem  numerischen  Argument  zwischen  2  und  36 legt das
Default-Zahlensystem  fÅr Integer-Konstanten  fest, d.h.  das Zahlensy-
stem,  das angenommen wird, wenn  man nichts ausdrÅcklich anderes ange-
geben  hat. DefaultmÑ·ig  ist dies  10, und  bei der VerÑnderung dieses
Wertes  sind einige Fallstricke zu beachten, die in Abschnitt 2.9.1 be-
schrieben sind.

UnabhÑngig  von der momentanen  Einstellung ist das  Argument von RADIX
immer  dezimal;  weiterhin  dÅrfen  keine  symbolischen oder Formelaus-
drÅcke verwendet werden, sondern nur einfache Zahlenkonstanten!


        3.7.8. OUTRADIX
        - - - - - - - -

OUTRADIX  is gewisserma·en  das GegenstÅck  zu RADIX:  Mit ihm kann man
festlegen,  in  welchem  Zahlensystem  berechnete  Integer-AusdrÅcke in
Strings   eingesetzt  werden  sollen,  wenn  man  \{...}-Konstrukte  in
Stringkonstanten  verwendet (siehe Abschnitt  2.9.3). Als Argument sind
wieder Werte zwischen 2 und 36 erlaubt; der Default ist 16.


        3.8. lokale Symbole
        -------------------

GÅltigkeit: alle Prozessoren

Bei  den lokalen Labels und den  dazu eingefÅhrten Sektionen handelt es
sich  um  eine  grundlegend  neue  Funktion,  die mit Version 1.39 ein-
gefÅhrt  wird. Da dieser Teil sozusagen  ,,1.0'' ist, ist er sicherlich
noch  nicht der Weisheit letzter  Schlu·. Anregungen und (konstruktive)
Kritik  sind daher besonders erwÅnscht.  Insbesondere habe ich die Ver-
wendung  von Sektionen hier so dargestellt,  wie ich sie mir vorstelle.
Es  kann dadurch passiert sein, da·  die RealitÑt nicht ganz meinem Mo-
dell  im  Kopf  entspricht.  FÅr  den  Fall von Diskrepanzen verspreche
ich,  da· die RealitÑt der Dokumentation angepa·t wird, und nicht umge-
kehrt,  wie  es  bei  grî·eren  Firmen  schon  einmal  vorgekommen sein
soll...

AS  erzeugt keinen  linkfÑhigen Code  (und wird  es wohl  auch nicht in
nÑherer  Zukunft tun  :-( ).  Diese Tatsache  zwingt dazu, ein Programm
immer  im  ganzen  zu  Åbersetzen.  Dieser Technik gegenÅber hÑtte eine
Aufteilung in Linker-Module einige Vorteile:

  - kÅrzere  öbersetzungszeiten,  da  lediglich  die  geÑnderten Module
    neu Åbersetzt werden mÅssen;
  - die  Mîglichkeit, durch Definition îffentlicher und privater Symbo-
    le definierte Schnittstellen zwischen den Modulen festzulegen;
  - Durch  die geringere LÑnge der  einzelnen Module reduziert sich die
    Anzahl  der Symbole im  einzelnen Modul, so  da· kÅrzere und trotz-
    dem eindeutige Symbolnamen benutzt werden kînnen.

Insbesondere   der  letzte  Punkt  hat   mich  persînlich  immer  etwas
gestîrt:  War ein Label-Name einmal am  Anfang eines 2000 Zeilen langen
Programmes  benutzt, so durfte er nirgendwo wieder verwendet werden ---
auch  nicht am anderen Ende des Quelltextes, wo Routinen mit ganz ande-
rem  Kontext standen.  Ich war  dadurch gezwungen, zusammengesetzte Na-
men der Form

<Unterprogrammname>_<Symbolname>

zu  verwenden, die  dann LÑngen  zwischen 15  und 25 Zeichen hatten und
das  Programm unÅbersichlich machten. Das  im folgenden eingehender be-
schriebene  Sektionen-Konzept sollte  zumindest den  beiden letzten ge-
nannten  Punkten abhelfen. Es ist vollstÑndig optional: Wollen Sie kei-
ne  Sektionen verwenden, so lassen Sie  es einfach bleiben und arbeiten
weiter wie unter den Ñlteren AS-Versionen.


        3.8.1. Grunddefinition (SECTION/ENDSECTION)
        - - - - - - - - - - - - - - - - - - - - - -

Eine  Sektion stellt  einen durch  spezielle Befehle  eingerahmten Teil
des  Assembler-Programmes dar und hat  einen vom Programmierer festleg-
baren, eindeutigen Namen:

        ...
        <anderer Code>
        ...
        SECTION <Sektionsname>
        ...
        <Code in der Sektion>
        ...
        ENDSECTION [Sektionsname]
        ...
        <anderer Code>
        ...

Der  Name fÅr eine  Sektion mu· den  Konventionen fÅr einen Symbolnamen
entsprechen;  da  AS  Sektions-und  Symbolnamen  in getrennten Tabellen
speichert,  darf ein Name  sowohl fÅr ein  Symbol als auch eine Sektion
verwendet  werden. Sektionsnamen  mÅssen in  dem Sinne  eindeutig sein,
da·  auf  einer  Ebene  nicht  zwei  Sektionen den gleichen Namen haben
dÅrfen  (was  es  mit  den  ,,Ebenen''  auf  sich hat, erlÑutere ich im
nÑchsten  Abschnitt). Das Argument zu  ENDSECTION ist optional, es darf
auch  weggelassen werden; Falls  es weggelassen wird,  zeigt AS den Na-
men  der Sektion an, der er das  ENDSECTION zugeordnet hat. Code in ei-
ner  Sektion  wird  von  AS  genauso behandelt wie au·erhalb, lediglich
mit drei entscheidenden Unterschieden:

  - Innerhalb  der  Sektion  definierte  Symbole (z.B. Labels, EQUs...)
    werden  mit einer von AS  intern vergebenen, der Sektion zugeordne-
    ten  Nummer  versehen.  Diese  Symbole  sind von Code au·erhalb der
    Sektion  nicht ansprechbar (das lÑ·t sich natÅrlich durch Pseudobe-
    fehle variieren, aber dazu spÑter mehr).
  - Durch   das  zusÑtzliche   Attribut  kann   ein  Symbolname  sowohl
    au·erhalb  der Sektion als auch innerhalb definiert werden, das At-
    tribut  erlaubt also,  Symbolnamen mehrfach  zu benutzen,  ohne da·
    AS Protest anmeldet.
  - Falls  ein  Symbol  sowohl  au·erhalb  als auch innerhalb definiert
    ist,  wird innerhalb der Sektion  das ,,lokale'' verwendet, d.h. AS
    sucht   in  der   Symboltabelle  zuerst   nach  einem   Symbol  des
    gewÅnschten  Namens, das  auch gleichzeitig  der Sektion zugeordnet
    wurde.  Erst danach wird  nach einem globalen  Symbol dieses Namens
    gefahndet.

Mit  diesem Mechanismus  kann man  z.B. den  Code in  Module aufteilen,
wie  man es mit einem Linker  getan hÑtte. Eine feinere Aufteilung wÑre
dagegen,  alle Routinen  in getrennte  Sektionen zu  verpacken. Je nach
LÑnge  der Routinen kînnen die nur  intern benîtigten Symbole dann sehr
kurze Namen haben.

DefaultmÑ·ig  unterscheidet  AS  Gro·-und  Kleinschreibung in Sektions-
namen  nicht; schaltet man  jedoch in den  case-sensitiven Modus um, so
wird die Schreibweise genauso wie bei Symbolnamen berÅcksichtigt.

Die  bisher beschriebene  Aufteilung wÅrde  in etwa  der Sprache C ent-
sprechen,  in der alle Funktionen auf gleicher Ebene nebeneinander ste-
hen.  Da  mein  ,,hochsprachliches''  Vorbild  aber Pascal ist, bin ich
noch einen Schritt weiter gegangen:


        3.8.2.  Verschachtelung und Sichtbarkeitsregeln
        - - - - - - - - - - - - - - - - - - - - - - - -

Es  ist erlaubt, in einer Sektion weitere Sektionen zu definieren, ana-
log  zu der Mîglichkeit  in Pascal, in  einer Prozedur/Funktion weitere
Prozeduren zu definieren. Dies zeigt folgendes Beispiel:

sym     EQU        0

        SECTION    ModulA
         SECTION    ProcA1
sym       EQU        5
         ENDSECTION ProcA1
         SECTION    ProcA2
sym       EQU        10
         ENDSECTION ProcA2
        ENDSECTION ModulA

        SECTION    ModulB
sym      EQU        15
         SECTION    ProcB
         ENDSECTION ProcB
        ENDSECTION ModulB

Bei  der Suche nach  einem Symbol sucht  AS zuerst ein  Symbol, das der
aktuellen  Sektion zugeordnet ist, und  geht danach die ganze ,,Liste''
der  Vatersektionen durch, bis er  bei den globalen Symbolen angekommen
ist.  Im Beispiel  sehen die  Sektionen die  in Tabelle 3.5 angegebenen
Werte fÅr das Symbol sym.

                 +---------+------+----------------+
                 | Sektion | Wert | aus Sektion... |
                 +---------+------+----------------+
                 +---------+------+----------------+
                 | Global  | 0    | Global         |
                 +---------+------+----------------+
                 | ModulA  | 0    | Global         |
                 +---------+------+----------------+
                 | ProcA1  | 5    | ProcA1         |
                 +---------+------+----------------+
                 | ProcA2  | 10   | ProcA2         |
                 +---------+------+----------------+
                 | ModulB  | 15   | ModulB         |
                 +---------+------+----------------+
                 | ProcB   | 15   | ModulB         |
                 +---------+------+----------------+

Tabelle 3.5: FÅr die einzelnen Sektionen gÅltigen Werte

Diese  Regel kann man durchbrechen, indem man explizit an den Symbolna-
men  die Sektion anhÑngt, aus  der man das Symbol  holen will, und zwar
in eckigen Klammern am Ende des Symbolnamens:

        move.l  #sym[ModulB],d0

Es  dÅrfen dabei nur Sektionsnamen  verwendet werden, die eine Obersek-
tion  zur aktuellen Sektion  darstellen. Als Sonderwert  sind die Namen
PARENT0..PARENT9  erlaubt, mit  denen man  die n-ten ,,Vatersektionen''
relativ  zur momentanen Sektion ansprechen kann; PARENT0 entspricht al-
so  der momentanen  Sektion selber,  PARENT1 der  direkt Åbergeordneten
usw.  Anstelle PARENT1  kann man  auch kurz  nur PARENT schreiben. LÑ·t
man  dagegen den Platz  zwischen den Klammern  komplett frei, also etwa
so

        move.l  #sym[],d0 ,

so  erreicht man  das globale  Symbol. ACHTUNG!  Wenn man  explizit ein
Symbol  aus einer Sektion anspricht, so wird auch nur noch bei den Sym-
bolen  dieser  Sektion  gesucht,  der  Sektionsbaum wird nicht mehr bis
nach oben durchgegangen!

Analog  zu Pascal ist es  erlaubt, da· verschiedene Sektionen Untersek-
tionen  gleichen Namens haben dÅrfen, das Prinzip der LokalitÑt verhin-
dert  hier Irritationen. M.E. sollte  man davon aber trotzdem sparsamen
Gebrauch  machen, da  in Symbol-und  Querverweisliste Symbole  zwar mit
der  Sektion, in der sie  definiert wurden, gekennzeichnet werden, aber
nicht     mit    der    Åber    dieser    Sektion    evtl.    liegenden
,,Sektionshierarchie''  (das hÑtte einfach  den Platz in  der Zeile ge-
sprengt); Unterscheidungen sind dadurch nicht erkennbar.

Da  ein SECTION-Befehl  von selber  kein Label  definiert, besteht hier
ein  wichtiger Unterschied  zu Pascal:  Eine Pascal-Prozedur  kann ihre
Unterprozeduren/funktionen  automatisch  ,,sehen'',  unter  AS  mu· man
noch  einen Einsprungpunkt extra definieren. Das kann man z.B. mit fol-
gendem Makro-PÑrchen tun:

proc    MACRO   name
        SECTION name
name    LABEL   $
        ENDM

endp    MACRO   name
        ENDSECTION name
        ENDM

Diese  Beispiel zeigt gleichzeitig, da· die LokalitÑt von Labels in Ma-
kros  nicht von  den Sektionen  beeinflu·t wird,  deshalb der Trick mit
dem LABEL-Befehl.

NatÅrlich  ist  mit  dieser  Definition  das  Problen  noch  nicht ganz
gelîst,  bisher ist  das Einsprung-Label  ja noch  lokal und  von au·en
nicht  zu erreichen.  Wer nun  meint, man  hÑtte das  Label einfach nur
vor  der  SECTION-Anweisung  plazieren  mÅssen,  sei jetzt bitte ruhig,
denn er verdirbt mir den öbergang auf das nÑchste Thema:


        3.8.3.  PUBLIC und GLOBAL
        - - - - - - - - - - - - -

Die  PUBLIC-Anweisung erlaubt  es, die  Zugehîrigkeit eines  Symbols zu
einer  bestimmten Sektion zu  verÑndern. Es ist  mîglich, mit einem PU-
BLIC-Befehl  mehrere Symbole zu bearbeiten,  ohne BeschrÑnkung der All-
gemeinheit  will ich aber  ein Beispiel mit  nur einer Variable verwen-
den:  Im einfachsten Falle erklÑrt man  ein Symbol als vollstÑndig glo-
bal, d.h. es ist von allen Stellen des Programmes ansprechbar:

        PUBLIC  <Name>

Da  ein  Symbol  bei  seiner  Definition endgÅltig in der Symboltabelle
einsortiert  wird, mu· diese  Anweisung vor der  Definition des Symbols
erfolgen.  Alle PUBLICs werden  von AS in  einer Liste vermerkt und bei
ihrer  Definition aus dieser Liste  wieder entfernt. Bei Beendigung ei-
ner   Sektion  gibt  AS  Fehlermeldungen  fÅr  alle  nicht  aufgelîsten
,,VorwÑrtsreferenzen'' aus.

Angesichts  des hierarchischen  Sektionenkonzepts erscheint  die Metho-
de,  ein Symbol als vollstÑndig global zu definieren, reichlich brachi-
al.  Es  geht  aber  auch  etwas  differenzierter, indem man zusÑtzlich
einen Sektionsnamen angibt:

        PUBLIC  <Name>:<Sektion>

Damit  wird das Symbol der genannten  Sektion zugeordnet und damit auch
allen  ihren Untersektionen  zugÑnglich (es  sei denn, diese definieren
wiederum  ein  Symbol  gleichen  Namens,  das  dann  das  ,,globalere''
Åbersteuert).  NaturgemÑ· protestiert AS,  falls mehrere Untersektionen
ein  Symbol gleichen Namens  auf die gleiche  Ebene exportieren wollen.
Als  Spezialwert fÅr <Sektion> sind  die im vorigen Abschnitt genannten
PARENTx-Namen  zugelassen, um das Symbol  genau n Ebenen hinaufzuexpor-
tieren.   Es   sind   als   Sektionen   nur   der   momentanen  Sektion
Åbergeordnete  Sektionen zugelassen, also keine, die im Baum aller Sek-
tionen  in einem anderen Zweig  stehen. Sollten dabei mehrere Sektionen
den  gleichen  Namen  haben  (dies  ist  legal),  so  wird  die tiefste
gewÑhlt.

Mit diesem Werkzeug kann das obige Prozedurmakro nun Sinn ergeben:

proc    MACRO   name
        SECTION name
        PUBLIC  name:PARENT
name    LABEL   $
        ENDM

Diese  Einstellung entspricht dem Modell von Pascal, in der eine Unter-
prozedur  auch  nur  von  ihrem  ,,Vater''  gesehen werden kann, jedoch
nicht vom ,,Gro·vater''.

Falls  mehrere Untersektionen versuchen, ein  Symbol gleichen Namens in
die  gleiche Obersektion zu exportieren,  meckert AS Åber doppelt defi-
nierte  Symbole, was an  sich ja korrekt  ist. War das  gewollt, so mu·
man  die Symbole in irgendeiner Weise ,,qualifizieren'', damit sie von-
einander   unterschieden  werden  kînnen.  Dies  ist  mit  der  GLOBAL-
Anweisung  mîglich.  Die  Syntax  von  GLOBAL  ist der von PUBLIC iden-
tisch,  das Symbol bleibt aber lokal, anstatt einer hîheren Sektion zu-
geordnet  zu  werden.  Stattdessen  wird  ein  weiteres Symbol gleichen
Werts  erzeugt, dem jedoch der  Untersektionsname mit einem Unterstrich
vorangestellt  wird, und nur dieses Symbol wird der Sektionsangabe ent-
sprechend  îffentlich gemacht. Definieren  z.B. zwei Sektionen  A und B
ein  Symbol SYM  und exportieren  es mit  GLOBAL zu ihrer Vatersektion,
so  werden dort die  Symbole unter den  Namen A_SYM und B_SYM eingeord-
net.

Falls  zwischen Quell-  und Zielsektion  mehrere Stufen stehen sollten,
so  wird entsprechend der  komplette Namenszweig von  der Ziel- bis zur
Quellsektion dem Symbolnamen vorangestellt.


        3.8.4.  FORWARD
        - - - - - - - -

So  schîn das bisher besprochene Modell  ist, ein bei Pascal nicht auf-
tauchendes   Detail   macht   érger:   die   bei   Assembler  mîglichen
VorwÑrtsreferenzen.  Bei VorwÑrtsreferenzen kann es sein, da· AS im er-
sten  Pass auf ein  Symbol einer hîheren  Sektion zugreift. Dies ist an
sich  nicht weiter tragisch, solange im  zweiten Pass das richtige Sym-
bol  genommen wird,  es kînnen  aber UnfÑlle  der folgenden Art passie-
ren:

loop:   .
        <Code>
        ..
        SECTION sub
        ..              ; ***
        bra.s   loop
        ..
loop:   ..
        ENDSECTION
        ..
        jmp     loop    ; Hauptschleife

AS  wird im  ersten Pass  das globale  Label loop verwenden, sofern das
ProgrammstÅck  bei <Code> hinreichend lang ist,  wird er sich Åber eine
zu  gro·e Sprungdistanz  beklagen und  den zweiten  Pass erst gar nicht
versuchen.  Um die Uneindeutigkeit zu vermeiden, kann man den Symbolna-
men mit einem expliziten Bezug versehen:

        bra.s   loop[sub]

Falls  ein lokales Symbol  hÑufig referenziert wird,  kînnen die vielen
Klammern  mit dem FORWARD-Befehl eingespart werden. Das Symbol wird da-
mit  explizit als  lokal angekÅndigt.  AS wird  dann bei  Zugriffen auf
dieses  Symbol automatisch nur im lokalen Symbolbereich suchen. In die-
sem  Falle mÅ·te an  der mit ***  gekennzeichneten Stelle dafÅr der Be-
fehl

        FORWARD loop

stehen.  Damit FORWARD Sinn macht, mu·  es nicht nur vor der Definition
des  Symbols, sondern vor seiner ersten  Benutzung in der Sektion gege-
ben  werden. Ein Symbol gleichzeitig  privat und îffentlich zu definie-
ren, ergibt keinen Sinn und wird von AS auch angemahnt.


        3.8.5.  Geschwindigkeitsaspekte
        - - - - - - - - - - - - - - - -

Die  mehrstufige Suche in  der Symboltabelle und  die Entscheidung, mit
welchem  Attribut  ein  Symbol  eingetragen  werden soll, kosten natur-
gemÑ·  etwas Rechenzeit. Ein 1800 Zeilen langes 8086-Programm z.B. wur-
de  nach der Umstellung auf Sektionen statt  in 33 in 34,5 Sekunden as-
sembliert  (80386 SX, 16MHz, 3 DurchgÑnge).  Der Overhead hÑlt sich al-
so  in Grenzen:  Ob man  ihn in  Kauf nehmen  will, ist  (wie am Anfang
erwÑhnt)  eine Frage des Geschmacks; man  kann AS genauso gut ohne Sek-
tionen verwenden.


        3.9. Diverses
        -------------


        3.9.1. SHARED
        - - - - - - -

GÅltigkeit: alle Prozessoren

Mit  diesem Befehl weist man den AS an, die in der Parameterliste ange-
gebenen  Symbole (egal ob Integer,  Gleitkomma oder String) im Sharefi-
le  mit ihren Werten  abzulegen. Ob eine  solche Datei Åberhaupt und in
welchem  Format erzeugt wird,  hÑngt von den  in 2.4 beschriebenen Kom-
mandozeilenschaltern  ab. Findet AS diesen Befehl und es wird keine Da-
tei erzeugt, fÅhrt das zu einer Warnung.

VORSICHT!  Ein  eventuell  der  Befehlszeile anhÑngender Kommentar wird
in  die erste, ausgegebene Zeile mit Åbertragen (sofern die Argumentli-
ste  von SHARED  leer ist,  wird nur  der Kommentar  ausgegeben). Falls
die  Share-Datei fÅr C  oder Pascal erzeugt  wird, sind einen C/Pascal-
Kommentar  schlie·ende Zeichenfolgen (*/ bzw.  *)) im Kommentar zu ver-
meiden. AS prÅft dies nicht!


        3.9.2.  INCLUDE
        - - - - - - - -

GÅltigkeit: alle Prozessoren

Dieser  Befehl fÅgt die im Parameter  angegebene Datei (die optional in
GÑnsefÅ·chen  eingeschlossen  sein  darf)  so  im  Text ein, als ob sie
dort  stehen wÅrde. Dieser Befehl  ist sinnvoll, um Quelldateien aufzu-
spalten,  die alleine nicht in den  Speicher passen wÅrden oder um sich
''Toolboxen'' zu erzeugen.

Falls  der angegebene Dateiname  keine Endung hat,  wird er automatisch
um die Endung INC erweitert.

Mit der Kommandozeilenoption

   -i <Pfadliste>

lÑ·t  sich eine Liste von  Verzeichnissen angeben, in denen automatisch
zusÑtzlich  nach der Includedatei  gesucht werden soll.  Wird die Datei
nicht  gefunden, so  ist dies  ein fataler  Fehler, d.h.  der Assembler
bricht sofort ab.

Aus  KompatibilitÑtsgrÅnden ist  es erlaubt,  den Namen in GÑnsefÅ·chen
zu schreiben,

        INCLUDE stddef51

und

        INCLUDE "stddef51.inc"

sind  also Ñquivalent. ACHTUNG! Wegen  dieser Wahlfreiheit ist hier nur
eine Stringkonstante, aber kein Stringausdruck zulÑssig!

Sollte  der Dateiname eine Pfadangabe  enthalten, so wird die Suchliste
ignoriert.


        3.9.3. BINCLUDE
        - - - - - - - -

GÅltigkeit: alle Prozessoren

BINCLUDE  dient dazu, in den von AS erzeugten Code BinÑrdaten einzubet-
ten,   die  von  einem  anderen   Programm  erzeugt  wurden  (das  kann
natÅrlich  theoretisch auch von AS selber erzeugter Code sein...). BIN-
CLUDE hat drei Formen:

   BINCLUDE <Datei>

In dieser Form wird die Datei komplett eingebunden.
 
   BINCLUDE <Datei>,<Offset>

In  dieser Form wird der Inhalt der  Datei ab <Offset> bis zum Ende der
Datei eingebunden.

   BINCLUDE <Datei>,<Offset>,<Len>

In dieser Form werden <Len> Bytes ab Offset <Offset> eingebunden.

Es gelten die gleichen Regeln bezÅglich Suchpfaden wie bei INCLUDE.


        3.9.4.  MESSAGE, WARNING, ERROR und FATAL
        - - - - - - - - - - - - - - - - - - - - -

GÅltigkeit: alle Prozessoren

Der  Assembler prÅft zwar die Quelltexte so streng wie mîglich und lie-
fert  diffenzierte  Fehlermeldungen,  je  nach  Anwendung  kann es aber
sinnvoll  sein, unter bestimmten  Bedingungen zusÑtzliche Fehlermeldun-
gen  auszulîsen, mit denen sich logische Fehler automatisch prÅfen las-
sen.  Der Assembler  unterscheidet drei  Typen von Fehlermeldungen, die
Åber die drei Befehle auch dem Programmierer zugÑnglich sind:

  - WARNING:  Fehler, die auf  mîglicherweise falschen oder ineffizien-
    ten  Code hinweisen.  Die Assemblierung  lÑuft weiter, eine Codeda-
    tei wird erzeugt.
  - ERROR:  echte Fehler  im Programm.  Die Assemblierung lÑuft weiter,
    um  mîgliche weitere Fehler in einem Durchgang entdecken und korri-
    gieren zu kînnen. Eine Codedatei wird nicht erzeugt.
  - FATAL:  schwerwiegende Fehler, die einen sofortigen Abbruch des As-
    semblers  bedingen. Eine  Codedatei kann  mîglicherweise entstehen,
    ist aber unvollstÑndig.

Allen  drei Befehlen  ist das  Format gemeinsam,  in dem die Fehlermel-
dung  angegeben  werden  mu·:  Ein  beliebig (berechneter?!) Stringaus-
druck, der damit sowohl eine Konstante als auch variabel sein darf.

Diese  Anweisungen ergeben nur in Zusammenhang mit bedingter Assemblie-
rung  Sinn. Ist fÅr ein Programm z.B. nur ein begrenzter Adre·raum vor-
handen, so kann man den öberlauf folgenderma·en testen:

ROMSize equ     8000h   ; 27256-EPROM

ProgStart: ..
        <das eigentliche Programm>
           ..
ProgEnd:
        if      ProgEnd-ProgStart>ROMSize
         error   "\aDas Programm ist zu lang!"
        endif

Neben  diesen fehlererzeugenden Befehlen gibt es noch den Befehl MESSA-
GE,  der einfach nur eine  Meldung auf der Konsole  bzw. im Listing er-
zeugt. Seine Benutzung ist den anderen drei Befehlen gleich.


        3.9.5. READ
        - - - - - -

GÅltigkeit: alle Prozessoren

READ  ist sozusagen  das GegenstÅck  zu der  vorigen Befehlsgruppe: mit
ihm  ist es mîglich,  wÑhrend der Assemblierung  Werte von der Tastatur
einzulesen.  Wozu das gut sein soll?  Um das darzulegen, soll hier aus-
nahmsweise  einmal das  Beispiel vor  die genauere  ErlÑuterung gezogen
werden:

Ein  Programm  benîtigt  zum  Datentransfer  einen Puffer mit einer zur
öbersetzungszeit  festzulegenden Grî·e. Um die  Grî·e des Puffers fest-
zulegen,  kînnte man  sie einmal  mit EQU  in einem  Symbol ablegen, es
geht aber auch interaktiv mit READ :

        IF      MomPass=1
         READ    "Puffer (Bytes)",BufferSize
        ENDIF

Auf  diese Weise kînnen Programme sich wÑhrend der öbersetzung interak-
tiv  konfigurieren, man kann sein Programm  z.B. jemandem geben, der es
mit    seinen   Parametern   Åbersetzen   kann,   ohne   im   Quellcode
,,herumstochern''  zu  mÅssen.  Die  im  Beispiel  gezeigte IF- Abfrage
sollte  Åbrigens immer verwendet werden,  damit der Anwender nur einmal
mit der Abfrage belÑstigt wird.

READ  Ñhnelt sehr stark dem  SET- Befehl, nur da·  der dem Symbol zuzu-
weisende  Wert nicht  rechts vom  SchlÅsselwort steht,  sondern von der
Tastatur  eingelesen wird. Dies  bedeutet z.B. auch,  da· AS anhand der
Eingabe  automatisch festlegt, ob es sich  um eine Integer- oder Gleit-
kommazahl  oder einen String handelt  und anstelle einzelner Konstanten
auch ganze FormelausdrÅcke eingegeben werden kînnen.

READ  darf  entweder  nur  einen  Parameter  oder zwei Parameter haben,
denn  die Meldung zur  Eingabeaufforderung ist optional.  Fehlt sie, so
gibt AS eine aus dem Symbolnamen konstruierte Meldung aus.


        3.9.6.  RELAXED
        - - - - - - - -

GÅltigkeit: alle Prozessoren

DefaultmÑ·ig  ist  einer  Prozessorfamilie  eine bestimmte Schreibweise
von  Integer-Konstanten zugeordnet (die i.a. der Herstellervorgabe ent-
spricht,  solange der nicht eine  allzu abgefahrene Syntax benutzt...).
Nun  hat aber jeder seine persînlichen  Vorlieben fÅr die eine oder an-
dere  Schreibweise und kann  gut damit leben,  da· sich seine Programme
nicht  mehr  mit  dem  Standard-Assembler  Åbersetzen lassen. Setzt man
ein

        RELAXED ON

an  den Programmanfang, so kann  man fortan alle Schreibweisen beliebig
gemischt  und durcheinander  verwenden; bei  jedem Ausdruck versucht AS
automatisch  zu  ermitteln,  welche  Schreibweise  verwendet wurde. Da·
diese  Automatik nicht immer das Ergebnis  liefert, das man sich vorge-
stellt  hat, ist auch  der Grund, weshalb  diese Option explizit einge-
schaltet  werden mu· (und  man sich davor  hÅten sollte, sie einfach in
einem  existierenden Programm dazuzusetzen): Ist  nicht durch vor- oder
nachgestellte  Zeichen zu erkennen, da· es  sich um Intel- oder Motoro-
la-Konstanten  handelt, wird im  C-Modus gearbeitet. Eventuell vorange-
stellte,  eigentlich ÅberflÅssige  Nullen haben  in diesem Modus durch-
aus eine Bedeutung:

        move.b  #08,d0

Diese  Konstante wÅrde  als Oktalkonstante  verstanden werden, und weil
Oktalzahlen  nur Ziffern von 0..7 enthalten  kînnen, fÅhrt das zu einem
Fehler.  Dabei  hÑtte  man  in  diesem  Fall noch GlÅck gehabt, bei der
Zahl  077 z.B. hÑtte man ohne  Meldung Probleme bekommen. Ohne RELAXED-
Modus  wÑre in beiden FÑllen klar gewesen, da· es sich um dezimale Kon-
stanten handelt.

Die  momentane Einstellung  kann aus  dem gleichnamigen Symbol ausgele-
sen werden.


        3.9.7.  END
        - - - - - -

GÅltigkeit: alle Prozessoren

END  kennzeichnet das Ende des  Assemblerprogrammes. Danach noch in der
Quelldatei  stehende Zeilen  werden ignoriert.  WICHTIG: END  darf zwar
aus  einem Makro heraus aufgerufen werden, der Stapel der bedingten As-
semblierung  wird aber  nicht automatisch  abgerÑumt. Das folgende Kon-
strukt fÅhrt daher zu einer Fehlermeldung:

        IF      KeineLustMehr
         END
        ENDIF

Optional  darf END auch einen  Integer-Ausdruck als Argument haben, der
den  Startpunkt des  Programmes vermerkt.  Dieser wird  von AS in einem
speziellen  Record der Datei  vermerkt und kann  z.B. von P2HEX weiter-
verarbeitet werden.

END  war  eigentlich  schon  immer  in  AS  definiert,  nur  war es bei
frÅheren  Versionen  von  AS  aus  KompatibilitÑt zu anderen Assemblern
vorhanden und hatte keine Wirkung.


        4. Prozessorspezifische Hinweise
        ================================

Ich  habe mich bemÅht, die einzelnen Codegeneratoren mîglichst kompati-
bel  zu den  Originalassemblern zu  halten, jedoch  nur soweit,  wie es
keinen  unvertretbaren  Mehraufwand  bedeutete.  Wichtige Unterschiede,
Details und Fallstricke habe ich im folgenden aufgelistet.


        4.1. 6811
        ---------

,,Wo  gibt es  denn das  zu kaufen,  den HC11  in NMOS?'',  fragt jetzt
vielleicht  der eine oder  andere. Gibt es  natÅrlich nicht, aber ein H
lÑ·t  sich nun einmal nicht in einer Hexzahl darstellen (Ñltere Versio-
nen  von AS  hÑtten solche  Namen deswegen  nicht akzeptiert), und dann
habe ich die Buchstaben gleich ganz weggelassen...


    ,,Jemand,  der sagt,  etwas sei  unmîglich,sollte wenigstens so ko-
    operativ  sein, denjenigen,  der es  gerade tut,  nicht am Arbeiten
    zu hindern.''

Ab  und zu ist man gezwungen,  seine Meinung zu revidieren. Vor einigen
Versionen  hatte ich an  dieser Stelle noch  behauptet, ich kînne es im
Parser  von AS nicht  realisieren, da· man  die Argumente von BSET/BCLR
bzw.  BRSET/BRCLR  auch  mit  Leerzeichen  trennen kann. Offensichtlich
kann  selbiger aber mehr, als ich vermutet habe...nach der soundsoviel-
ten  Anfrage habe ich  mich noch einmal  drangesetzt, und jetzt scheint
es  zu laufen. Man  darf sowohl Leerzeichen  als auch Kommas verwenden,
aber  nicht in allen  Varianten, um es  nicht uneindeutig zu machen: Es
gibt  zu jeder Befehlsvariante  zwei Mîglichkeiten; eine,  die nur Kom-
mas  verwendet, sowie eine,  wie sie von  Motorola wohl definiert wurde
(leider  sind die  DatenbÅcher nicht  immer so  gut wie  die zugehîrige
Hardware...):

   Bxxx  abs8 #mask         entspricht    Bxxx  abs8,#mask
   Bxxx  disp8,X #mask      entspricht    Bxxx  disp8,X,#mask
   BRxxx abs8 #mask adr     entspricht    BRxxx abs8,#mask,adr
   BRxxx disp8,X #mask adr  entspricht    BRxxx disp8,X,#mask,adr

Dabei  steht xxx entweder fÅr SET oder CLR und #mask fÅr die zu verwen-
dende  Bitmaske;  der  Lattenzaun  ist  dabei optional. Anstelle des X-
Registers darf natÅrlich auch Y verwendet werden.

Mit  der  K4-Version  des  HC11  hat  Motorola  ein Banking-Schema ein-
gefÅhrt,  mit dem man zwar einerseits eine zu klein gewordene Architek-
tur  noch  einmal  aufbohren  kann,  den Software- und Tool-Entwicklern
aber  nicht unbedingt das Leben einfacher macht...wie stellt man so et-
was vernÅnftig dar?

Die  K4-Architektur erweitert  den Adre·raum  des HC11  um 2x512 Kbyte,
so  da·  jetzt  insgesamt  64+1024=1088  Kbyte zur VerfÅgung stehen. AS
tut  so, als  ob es  sich dabei  um einen  Adre·raum handeln wÅrde, der
folgenderma·en organisiert ist:

  - $000000...$00ffff: der alte HC11-Adre·raum
  - $010000...$08ffff: Fenster 1
  - $090000...$10ffff: Fenster 2

öber  den ASSUME-Befehl teilt man AS mit, wie die Banking-Register ein-
gestellt  sind und  damit, wie  und wo  die erweiterten Bereiche einge-
blendet  werden.  Bei  absoluten  Adressierungen  mit Adressen jenseits
$10000  berechnet AS dann automatisch, welche Adresse innerhalb der er-
sten  64K anzusprechen ist.  Das kann natÅrlich  wieder nur fÅr direkte
Adressierungsarten   funktionieren,   bei   indizierten/indirekten  Ad-
reÑusdrÅcken  ist der Programmierer dafÅr  verantwortlich, Åber die mo-
mentan aktiven Banks den öberblick zu behalten!

Wer  sich nicht ganz  sicher ist, ob  die momentane Einstellung korrekt
ist, kann den Pseudobefehl PRWINS benutzen, der dann z.B.

MMSIZ e1 MMWBR 84 MM1CR 00 MM2CR 80
Window 1: 10000...12000 --> 4000...6000
Window 1: 90000...94000 --> 8000...c000

ausgibt. Ein z.B. an Stelle $10000 liegender Befehl

        jmp     *+3

wÅrde effektiv einen Sprung auf Adresse $4003 auslîsen.


        4.2. PowerPC
        ------------

Sicher  hat es ein bi·chen den  Anflug einer Schnapsidee, einen Prozes-
sor,  der eher fÅr den Einsatz  in Workstations konzipiert wurde, in AS
einzubauen,  der sich  ja eher  an Programmierer  von Einplatinencompu-
tern  wendet. Aber was heute  noch das Hei·este vom  Hei·en ist, ist es
morgen  schon nicht mehr,  und sowohl der  Z80 als auch  der 8088 haben
ja  inzwischen  die  Mutation  von  der  Personal Computer-CPU zum sog.
,,Mikrocontroller''  vollzogen.  Mit  dem  Erscheinen  von  MPC505  und
PPC403  hat sich die Vermutung dann auch bestÑtigt, da· IBM und Motoro-
la diese Prozessorserie auf allen Ebenen durchdrÅcken wollen.

Die  UnterstÅtzung ist  momentan noch  nicht vollstÑndig: Als Pseudobe-
fehle   zur  Datenablage   werden  momentan   provisorisch  die  Intel-
Mnemonics  unterstÅtzt  und  es  fehlen  die etwas ungewîhnlicheren, in
[57]   genannten  RS6000-Befehle  (die  aber  hoffentlich  keiner  ver-
mi·t...).  Das  wird  aber  nachgeholt,  sobald Informationen verfÅgbar
sind!


        4.3. DSP56xxx
        -------------

Motorola,  was ist nur  in Dich gefahren!  Wer bei Dir  ist nur auf das
schmale  Brett gekommen, die einzelnen parallelen Datentransfers ausge-
rechnet  durch Leerzeichen zu trennen! Wer  immer nun seine Codes etwas
Åbersichtlicher formatieren will, z.B. so:

        move    x:var9 ,r0
        move    y:var10,r3   ,

der  ist gekniffen, weil das Leerzeichen als Trennung paralleler Daten-
transfers erkannt wird!

Sei's  drum;  Motorola  hat  es  so  definiert,  und  ich kann es nicht
Ñndern.  Als Trennung der Operationen sind statt Leerzeichen auch Tabu-
latoren  zugelassen, und die  einzelnen Teile sind  ja wieder ganz nor-
mal mit Kommas getrennt.

In  [52] steht, da·  bei den Befehlen  MOVEC, MOVEM, ANDI  und ORI auch
die  allgemeineren Mnemonics MOVE, AND  und OR verwendet werden kînnen.
Bei AS geht das (noch) nicht.


        4.4. H8/300
        -----------

Bei  der Assemblersyntax  dieser Prozessoren  hat Hitachi reichlich bei
Motorola  abgekupfert (was so  verkehrt ja nun  auch nicht war...), nur
leider  wollte die Firma unbedingt  ihr eigenes Format fÅr Hexadezimal-
zahlen  einfÅhren, und dazu  noch eines, das  Ñhnlich wie bei Microchip
Hochkommas  verwendet. Das konnte  (und wollte) ich  bei AS nicht nach-
vollziehen,  bei dem Hochkommas zur  Einrahmung von ASCII-Sequenzen be-
nutzt  werden. Anstelledessen  werden Zahlen  in der Åblichen Motorola-
Syntax geschrieben, d.h. mit einem Dollarzeichen.


        4.5. SH7000/7600/7700
        ---------------------

Leider  hat Hitachi auch hier  wieder das Extrawurst-Format fÅr Hexade-
zimalzahlen  verwendet, und wieder habe ich in AS das nicht nachvollzo-
gen...bitte Motorola-Syntax benutzen!

Bei  der Verwendung von Literalen und  dem LTORG-Befehl sind einige De-
tails  zu beachten, wenn man nicht  auf einmal mit eigenartigen Fehler-
meldungen konfrontiert werden will:

Literale  existieren, weil  der Prozessor  nicht in  der Lage ist, Kon-
stanten  au·erhalb  des  Bereiches  von  -128  bis  127  mit immediate-
Adressierung  zu laden. AS (und  der Hitachi-Assembler) verstecken die-
se  UnzulÑnglichkeit,  indem  sie  automatisch entsprechende Konstanten
im  Speicher ablegen, die dann  mittels PC-relativer Adressierung ange-
sprochen  werden. Die  Frage, die  sich nun  erhebt, ist  die, wo diese
Konstanten  im Speicher abgelegt  werden sollen. AS  legt sie nicht so-
fort  ab, sondern sammelt sie so lange auf, bis im Programm eine LTORG-
Anweisung  auftritt. Dort werden alle  Konstanten abgelegt, wobei deren
Adressen  mit ganz  normalen Labels  versehen werden,  die man  auch in
der Symboltabelle sehen kann. Ein Label hat die Form

   LITERAL_s_xxxx_n   .

Dabei  reprÑsentiert s den Typ des Literals. Unterschieden werden Lite-
rale,   die  16-Bit-Konstanten  (s=W),   32-Bit-Konstanten  (s=L)  oder
VorwÑrtsreferenzen,  bei denen  AS die  Operandengrî·e nicht  im voraus
erkennen  kann (s=F), enthalten. FÅr W oder L bedeutet xxxx den hexade-
zimal  geschriebenen  Wert  der  Konstante, bei VorwÑrtsreferenzen, bei
denen  man den  Literalwert ja  noch nicht  kennt, bezeichnet xxxx eine
einfache  Durchnumerierung. n kennzeichnet das wievielte Auftreten die-
ses  Literals in dieser Sektion. Literale  machen ganz normal die Loka-
lisierung  durch Sektionen mit, es  ist daher zwingend erforderlich, in
einer Sektion entstandene Literale mit LTORG auch dort abzulegen!

Die  Durchnumerierung mit n  ist erforderlich, weil  ein Literal in ei-
ner  Sektion mehrfach auftreten kann.  Dies ist einmal bedingt dadurch,
da·  die PC-relative  Adressierung nur  positive Displacements erlaubt,
einmal  mit LTORG abgelegte Literale also  im folgenden Code nicht mit-
benutzt  werden kînnen, andererseits auch, weil die Reichweite der Dis-
placements  beschrÑnkt  ist  (512  bzw.  1024  Byte). Ein automatisches
LTORG  am Ende  des Programmes  oder beim  Umschalten zu  einer anderen
CPU  erfolgt nicht; findet  AS in einer  solchen Situation noch abzule-
gende Literale, so wird eine Fehlermeldung ausgegeben.

Da  bei der PC-relativen Adressierung der zur Adressierung herangezoge-
ne   PC-Wert  der   Instruktionsadresse+4  entspricht,   ist  es  nicht
mîglich,  ein Literal zu benutzen,  welches direkt hinter dem betroffe-
nen Befehl abgelegt wird, also z.B. so:

        mov     #$1234,r6
        ltorg

Da  der Prozessor  dann aber  sowieso versuchen  wÅrde, Daten  als Code
auszufÅhren,  sollte diese Situation in realen Programmen nicht auftre-
ten.  Wesentlich realer  ist aber  ein anderer  Fallstrick: Wird hinter
einem  verzîgerten  Sprung  PC-relativ  zugegriffen,  so  ist  der Pro-
grammzÑhler  bereits auf die Sprungzieladresse gesetzt, und das Displa-
cement  wird relativ zum Sprungziel+2  berechnet. Im folgenden Beispiel
kann daher das Literal nicht erreicht werden:

        bra     Target
        mov	#$12345678,r4        ; wird noch ausgefuehrt
        .
        .
        ltorg                        ; hier liegt das Literal
        .
        .
Target: mov     r4,r7                ; hier geht es weiter

Da  Target+2 hinter dem Literal liegt, wÅrde sich ein negatives Displa-
cement  ergeben. Besonders haarig  wird es, wenn  mit den Befehlen JMP,
JSR,  BRAF oder BSRF  verzweigt wird: Da  AS die Zieladresse hier nicht
ermitteln  kann (sie ergibt sich erst  zur Laufzeit aus dem Registerin-
halt),  nimmt AS hier  eine Adresse an,  die nach Mîglichkeit nie pa·t,
so da· PC-relative Adressierung gÑnzlich unmîglich wird.

Es  ist nicht direkt mîglich,  aus der Zahl und  Grî·e der Literale auf
den  belegten Speicher zu  schlie·en. U.u. mu·  AS ein FÅllwort einbau-
en,  um einen  Langwort-Wert auf  eine durch  4 teilbare Adresse auszu-
richten,  andererseits kann  er mîglicherweise  Teile eines 32-bittigen
Literals  fÅr 16-Bit-Literale mitbenutzten.  Mehrfach auftretende Lite-
rale  erzeugen natÅrlich  nur einen  Eintrag. Solche Optimierungen wer-
den  fÅr  VorwÑrtsreferenzen  allerdings  ganz  unterdrÅckt,  da AS den
Wert dieser Literale noch nicht kennt.

Da  Literale die PC-relative Adressierung  ausnutzen, die nur beim MOV-
Befehl  erlaubt sind, beschrÑnken sich  Literale ebenfalls auf die Ver-
wendung  in MOV. Etwas  trickreich ist hier  die Art und  Weise, in der
AS  die Operandengrî·e auswertet. Eine Angabe von Byte oder Wort bedeu-
tet,  da· AS einen mîglichst kurzen MOV-Befehl erzeugt, der den angege-
benen  Wert in den  unteren 8 oder  16 Bit erzeugt,  d.h. die oberen 24
oder  16 Bit  werden als  don't care  behandelt. Gibt man dagegen Lang-
wort  oder gar nichts an,  so sagt dies aus,  da· das komplette 32-Bit-
Register  den angegebenen  Wert enthalten  soll. Das  hat z.B.  den Ef-
fekt, da· in folgendem Beispiel

        mov.b   #$c0,r0
        mov.w   #$c0,r0
        mov.l   #$c0,r0

der  erste Befehl echte immediate-Adressierung  erzeugt, der zweite und
dritte  jedoch ein Wort-Literal benutzen: Da das  Bit 7 in der Zahl ge-
setzt  ist,  erzeugt  der  Byte-Befehl  effektiv $FFFFFFC0 im Register,
was  nach der Konvention nicht  das wÑre, was man  im zweiten und drit-
ten  Fall haben mîchte.  Im dritten Fall  reicht auch ein Wort-Literal,
weil  das gelîschte  Bit 15  des Operanden  vom Prozessor in Bit 16..31
fortgesetzt wird.

Wie  man sieht, ist dieses ganze Literal-Konzept reichlich kompliziert;
einfacher  ging's aber  wirklich nicht.  Es liegt  leider in  der Natur
der  Sache, da· man manchmal Fehlermeldungen Åber nicht gefundene Lite-
rale  bekommt, die eigentlich logisch  nicht auftreten kînnten, weil AS
die  Literale ja komplett  in eigener Regie  verwaltet. Treten aber bei
der  Assemblierung  Fehler  erst  im  zweiten  Pass auf, so verschieben
sich  z.B. hinter  der Fehlerstelle  liegende Labels  gegenÅber dem er-
sten  Pass, weil AS fÅr die jetzt als fehlerhaft erkannten Befehle kei-
nen  Code mehr  erzeugt. Da  aber Literalnamen  u.a. aus den Werten von
Symbolen  erzeugt werden, werden als  Folgefehler davon eventuell ande-
re  Literalnamen nachgefragt,  als im  ersten Pass  abgelegt wurden und
AS  beschwert sich  Åber nicht  gefundene Symbole...sollten  also neben
anderen  Fehlern solche  Literal-Fehler auftreten,  beseitigen Sie erst
die anderen Fehler, bevor Sie mich und alle Literale verfluchen...

Wer  aus der Motorola-Ecke kommt  und PC-relative Adressierung explizit
benutzen  will (z.B. um Variablen  lageunabhÑngig zu erreichen), sollte
wissen,  da· beim  Ausschreiben der  Adressierung nach Programmierhand-
buch, also z.B. so:

        mov.l   @(Var,PC),r8

keine  implizite Umrechnung  der Adresse  auf ein Displacement erfolgt,
d.h.  der Operand wird so  eingesetzt, wie er ist  (und wÅrde in diesen
Beispiel  wohl mit hoher  Wahrscheinlichkeit eine Fehlermeldung hervor-
rufen...).  Will  man  beim  SH7x00  PC-relativ adressieren, so tut man
das  einfach mit ,,absoluter'' Adressierung,  die auf Maschinenebene ja
gar nicht existiert:

        mov.l   Var,r8

Hier  wird das Displacement korrekt  berechnet (es gelten natÅrlich die
gleichen EinschrÑnkungen fÅr das Displacement wie bei Literalen).


        4.6. MELPS-4500
        ---------------

Der  Programmspeicher dieser Mikrokontroller ist  in Seiten zu 128 Wor-
ten  eingeteilt.  Diese  Einteilung  existiert eigentlich nur deswegen,
weil  es Sprungbefehle  gibt, deren  Ziel innerhalb  der gleichen Seite
liegen  darf, und andererseits ,,lange''  Exemplare, die den ganzen Ad-
re·bereich  erreichen kînnen.  Die Standard-Syntax  von Mitsubishi ver-
langt  eigentlich,  da·  Seite  und  Offset  als getrennte Argument ge-
schrieben   werden  mÅssen.  Da  das  aber  reichlich  unpraktisch  ist
(ansonsten  hat man als Programmierer  keine Veranlassung, sich um Sei-
ten  zu kÅmmern, mit der Ausnahme  von indirekten SprÅngen), erlaubt es
AS auch wahlweise, die Zieladresse linear zu schreiben, also z.B.

      bl        $1234

anstelle

      bl        $24,$34  .



        4.7. 6502UNDOC
        --------------

Da  die undokumentierten Befehle des 6502 sich naturgemÑ· in keinem Da-
tenbuch  finden, sollen sie  an dieser Stelle  kurz aufgelistet werden.
Die  Verwendung  erfolgt  naturgemÑ·  auf  eigene  Gefahr,  da es keine
GewÑhr  gibt,  da·  alle  Maskenversionen  alle Varianten unterstÅtzen!
Bei  den  CMOS-Nachfolgern  des  6502  funktionieren  sie sowieso nicht
mehr,  da diese die ensprechenden  Bitkombinationen mit offiziellen Be-
fehlen belegen...


Es bedeuten:


 
&         binÑres UND
|         binÑres ODER
 ^        binÑres EXOR
<<        logischer Linksshift
>>        logischer Rechtsshift
<<<       Linksrotation
>>>       Rechtsrotation
<-        Zuweisung
(..)      Inhalt von ..
..        Bits ..
A         Akkumulator
X,Y       Indexregister X,Y
S         Stapelzeiger
An        Akkumulatorbit n
M         Operand
C         Carry
PCH       obere HÑlfte ProgrammzÑhler



 
Anweisung         : JAM, KIL oder CRS
Funktion          : keine, Prozessor wird angehalten
Adressierungsmodi : implizit


 
Anweisung         : SLO
Funktion          : M<-((M)<<1)|(A)
Adressierungsmodi : absolut lang/kurz, X-indiziert lang/kurz,
                    Y-indiziert lang, X/Y-indirekt


 
Anweisung         : ANC
Funktion          : A<-(A)&(M), C<- A7
Adressierungsmodi : immediate


 
Anweisung         : RLA
Funktion          : M<-((M)<<1)&(A)
Adressierungsmodi : absolut lang/kurz, X-indiziert lang/kurz,
                    Y-indiziert lang, X/Y-indirekt


 
Anweisung         : SRE
Funktion          : M<-((M)>>1)^(A)
Adressierungsmodi : absolut lang/kurz, X-indiziert lang/kurz,
                    Y-indiziert lang, X/Y-indirekt


 
Anweisung         : ASR
Funktion          : A<-((A)&(M))>>1
Adressierungsmodi : immediate


 
Anweisung         : RRA
Funktion          : M<-((M)>>>1)+(A)+(C)
Adressierungsmodi : absolut lang/kurz, X-indiziert lang/kurz,
                    Y-indiziert lang, X/Y-indirekt


 
Anweisung         : ARR
Funktion          : A<-((A)&(M))>>>1
Adressierungsmodi : immediate


 
Anweisung         : SAX
Funktion          : M<-(A)&(X)
Adressierungsmodi : absolut lang/kurz, Y-indiziert kurz,
                    Y-indirekt


 
Anweisung         : ANE
Funktion          : M<-((A)&$ee)|((X)&(M))
Adressierungsmodi : immediate


 
Anweisung         : SHA
Funktion          : M<-(A)&(X)&(PCH+1)
Adressierungsmodi : X/Y-indiziert lang


 
Anweisung         : SHS
Funktion          : X<-(A)&(X), S<-(X), M<-(X)&(PCH+1)
Adressierungsmodi : Y-indiziert lang


 
Anweisung         : SHY
Funktion          : M<-(Y)&(PCH+1)
Adressierungsmodi : Y-indiziert lang


 
Anweisung         : SHX
Funktion          : M<-(X)&(PCH+1)
Adressierungsmodi : X-indiziert lang


 
Anweisung         : LAX
Funktion          : A,X<-(M)
Adressierungsmodi : absolut lang/kurz, Y-indiziert lang/kurz,
                    X/Y-indirekt


 
Anweisung         : LXA
Funktion          : X04<-(X)04 & (M)04,
                    A04<-(A)04 & (M)04
Adressierungsmodi : immediate


 
Anweisung         : LAE
Funktion          : X,S,A<-((S)&(M))
Adressierungsmodi : Y-indiziert lang


 
Anweisung         : DCP
Funktion          : M <-(M)-1, Flags<-((A)-(M))
Adressierungsmodi : absolut lang/kurz, X-indiziert lang/kurz,
                    Y-indiziert lang, X/Y-indirekt


 
Anweisung         : SBX
Funktion          : X<-((X)&(A))-(M)
Adressierungsmodi : immediate


 
Anweisung         : ISB
Funktion          : M<-(M)+1, A<-(A)-(M)-(C)
Adressierungsmodi : absolut lang/kurz, X-indiziert lang/kurz,
                    Y-indiziert lang, X/Y-indirekt



        4.8. MELPS-740
        --------------

Die  Mikrokontroller dieser  Reihe haben  ein sehr  nettes, verstecktes
Feature:  Setzt man mit  dem Befehl SET  das Bit 5 des Statusregisters,
so  wird bei  allen arithmetischen  Operationen (und  Ladebefehlen) der
Akkumulator  durch die  durch das  X-Register adressierte Speicherzelle
ersetzt.  Dieses Feature syntaxmÑ·ig sauber  zu integrieren, ist bisher
nicht   geschehen,  d.h.   es  kann   bisher  nur   im  ,,Handbetrieb''
(SET...Befehle mit Akkuadressierung...CLT) genutzt werden.

Nicht  alle MELPS-740-Prozessoren implementieren  alle Befehle. An die-
ser  Stelle mu· der Programmierer aufpassen, da· er nur die Befehle be-
nutzt,  die auch wirklich vorhanden sind,  da AS die Prozessoren dieser
Familie  nicht  nÑher  unterscheidet.  Die  Besonderheiten der Special-
Page-Adressierung   werden   bei   der   ErklÑrung   von  ASSUME  nÑher
erlÑutert.


        4.9. MELPS-7700/65816
        ---------------------

Offensichtlich  haben  diese  beiden  Prozessorfamilien  ausgehend  vom
6502  (Åber ihre 8-bittigen  VorgÑnger) etwas disjunkte Entwicklungswe-
ge hinter sich. Kurz aufgelistet, ergeben sich folgende Unterschiede:

  - der 65816 hat keinen B-Akkumulator.
  - beim 65816 fehlen Multiplikations- sowie Divisionsbefehle.
  - Die  Befehle SEB, CLB, BBC, BBS, CLM,  SEM, PSH, PUL und LDM fehlen
    beim  65816. An deren  Stelle in der  Code-Tabelle finden sich TSB,
    TRB, BIT, CLD, SED, XBA, XCE und STZ.

Identische Funktion, jedoch andere Namen haben folgende Befehle:

             +-------+------------++-------+------------+
             | 65816 | MELPS-7700 || 65816 | MELPS-7700 |
             +-------+------------++-------+------------+
             +-------+------------++-------+------------+
             |  REP  |     CLP    ||  PHK  |     PHG    |
             |  TCS  |     TAS    ||  TSC  |     TSA    |
             |  TCD  |     TAD    ||  TDC  |     TDA    |
             |  PHB  |     PHT    ||  PLB  |     PLT    |
             |  WAI  |     WIT    ||       |            |
             +-------+------------++-------+------------+

Besonders  tÅckisch sind  die Befehle  PHB, PLB  und TSB: diese Befehle
haben jeweils eine vîllig andere Funktion und Kodierung!

Leider  tun diese  Prozessoren mit  ihrem Speicher  etwas, was fÅr mich
auf  der  nach  oben  offenen  PerversitÑtsskala  noch  vor  der Intel-
mÑ·igen  Segmentierung rangiert: sie  banken ihn! Nunja,  dies ist wohl
der  Preis fÅr die  6502-AufwÑrtskompatibilitÑt; wie dem  auch sei, da-
mit  AS den gewÅnschten Code erzeugen kann,  mu· man ihn Åber den ASSU-
ME-Befehl Åber den Inhalt einiger Register in Kenntnis setzen:

Das  M-Flag bestimmt, ob  die Akkumulatoren A  und B 8  Bit (1) oder 16
Bit  (0)  breit  sein  sollen.  Analog  entscheidet das Flag X Åber die
Breite  der Indexregister  X und  Y. AS  benîtigt die  Information Åber
die  Registerbreite bei  unmittelbarer Adressierung  (#<Konstante>), ob
das Argument 8 oder 16 Bit breit sein soll.

Der  Speicher ist in  256 BÑnke zu  64 Kbyte geteilt.  Da alle Register
im  Prozessor nur maximal 16 Bit breit  sind, kommen die obersten 8 Ad-
re·bits  aus 2 speziellen Bank-Registern: DT  liefert die oberen 8 Bits
bei  Datenzugriffen,  PG  erweitert  den 16-bittigen ProgrammzÑhler auf
24  Bit. Die  vom 6502  her bekannte  ,,Zero-Page'' ist  mittels des 16
Bit  breiten Registers  DPR frei  innerhalb der  ersten Bank verschieb-
bar.  Trifft AS nun im Code auf  eine Adresse (egal ob in einem absolu-
ten,  indizierten oder indirekten  Ausdruck), so versucht  er der Reihe
nach folgende Adressierungsvarianten:

  1 Liegt  die Adresse im Bereich  von DPR...DPR+$ff? Falls ja, Verwen-
    dung von direkter Adressierung mit 8-Bit-Adresse.
  2 Liegt  die Adresse innerhalb der durch DT (bzw. PG fÅr Sprungbefeh-
    le)  festgelegten Seite? Falls ja,  Verwendung von absoluter Adres-
    sierung mit 16-Bit-Adresse.
  3 Falls  nichts  anderes  hilft,  Verwendung  von langer Adressierung
    mit 24-Bit-Adresse.

Aus  dieser AufzÑhlung folgt, da· das  Wissen Åber die momentanen Werte
von  DT,PG und DPR fÅr die Funktion von AS essentiell ist; sind die An-
gaben  fehlerhaft,  adressiert  das  Programm  ,,in  die WÅste''. Diese
AufzÑhlung   geht  Åbrigens  davon  aus,   da·  alle  drei  Adre·lÑngen
verfÅgbar  sind; sollte  dies einmal  nicht der  Fall sein, so wird die
Entscheidungskette entsprechen kÅrzer.

Die  oben  geschilderte,  automatische  Festlegung  der Adre·lÑnge lÑ·t
sich  auch durch  die Verwendung  von PrÑfixen  Åbersteuern. Stellt man
der  Adresse ein  <, >  oder >>  ohne trennendes  Leerzeichen voran, so
wird  eine Adresse mit 1, 2 oder  3 Bytes benutzt, unabhÑngig davon, ob
dies  die optimale LÑnge ist. Benutzt  man eine fÅr diesen Befehl nicht
erlaubte  oder fÅr die Adresse zu  kurze LÑnge, gibt es eine Fehlermel-
dung.

Um  die  Portierung  von  6502-Programmen  zu erleichtern, verwendet AS
fÅr  Hexadezimalkonstanten die  Motorola-Syntax und  nicht die von Mit-
subishi  Åbrigens fÅr  die 740er  favorisierte Intel/IEEE-Schreibweise.
Ich  halte erstere auch fÅr die  bessere Schreibweise, und die Entwick-
ler  des 65816  werden dies  vermutlich Ñhnlich  gesehen haben  (da man
mittels  der RELAXED-Anweisung auch  Intel-Notation benutzen kann, wird
durch  diese Entscheidung auch niemand festgelegt). Ein fÅr die Portie-
rung  Ñhnlich wichtiges Detail ist, da·  der Akkumulator A als Ziel von
Operationen  auch weggelassen werden  darf, anstelle von  LDA A,#0 darf
also z.B. auch einfach LDA #0 geschrieben werden.

Ein  echtes Bonbon in dem Befehlssatz sind dagegen die Blocktransferbe-
fehle  MVN und MVP.  Etwas eigenartig ist  nur die Adre·angabe: Bit 0--
15  im Indexregister, Bit 16--23  im Befehl. Bei AS  gibt man als Argu-
ment  fÅr  beide  Speicherblîcke  einfach  die  vollen  Adressen an, AS
fischt  sich dann die  passenden Bits automatisch  heraus. Dies ist ein
feiner,  aber wichtiger  Unterschied zum  Mitsubishi-Assembler, bei dem
man  die oberen 8  Bit selber herausziehen  mu·. Richtig bequem wird es
aber erst mit einem Makro im folgendem Stil:

mvpos   macro   src,dest,len
        if      MomCPU=$7700
         lda    #len
        elseif
         lda    #(len-1)
        endif
        ldx     #(src&$ffff)
        ldy     #(dest&$ffff)
        mvp     dest,src
        endm

Vorsicht,  Falle: Steht im Akkumulator die  Zahl n, so transferiert der
Mitsubishi n Bytes, der 65816 jedoch n+1 Bytes!

Sehr  nett  sind  auch  die  Befehle  PSH  und  PUL, mit deren Hilfe es
mîglich  ist, mit einem Befehl einen  frei wÑhlbaren Satz von Registern
auf  dem Stack zu sichern  oder von ihm zu  laden. Nach dem Mitsubishi-
Datenbuch[41]  mu·  die  Angabe  der  Bitmasken immediate erfolgen, der
Programmierer    soll   also   entweder   alle   Register<->Bitstellen-
Zuordnungen  im Kopf  behalten oder  sich passende  Symbole definieren.
Hier  habe ich  die Syntax  eigenmÑchtig erweitert,  um die Sache etwas
angenehmer  zu machen: Es darf eine  Liste angegeben werden, die sowohl
immediate-AusdrÅcke  als auch Registernamen  enthalten darf. Damit sind
z.B. die Anweisungen

        psh     #$0f

und

        psh     a,b,#$0c

und

        psh     a,b,x,y

Ñquivalent.  Da die immediate-Version weiterhin  erlaubt ist, bleibt AS
hier ,,aufwÑrtskompatibel'' zu den Mitsubishi-Assemblern.

Nicht  ganz habe ich beim  Mitsubishi-Assembler die Behandlung des PER-
Befehles  verstanden: Mit  diesem Befehl  kann man eine 16-Bit-Variable
auf  den Stack legen, deren  Adresse relativ zum ProgrammzÑhler angege-
ben  wird. Es ist  aus der Sicht  des Programmierers also eine absolute
Adressierung  einer Speicherzelle.  Nichtsdestotrotz verlangt Mitsubis-
hi  eine immediate-Adressierung, und  das Argument wird  so in den Code
eingesetzt,  wie es  im Quelltext  steht. Die  Differenz mu· man selber
ausrechnen,  was mit der EinfÅhrung  von symbolischen Assemblern ja ab-
geschafft  werden sollte...da ich aber  auch ein bi·chen ,,kompatibel''
denken  mu·,  enthÑlt  AS  eine  Kompromi·lîsung:  WÑhlt man immediate-
Adressierung  (also mit Gartenzaun), so verhÑlt  sich AS wie das Origi-
nal  von Mitsubishi. LÑ·t man ihn jedoch  weg, so berechnet AS die Dif-
ferenz  vom  Argument  zum  momentanen  ProgrammzÑhler  und setzt diese
ein.

éhnlich  sieht es  beim PEI-Befehl  aus, der  den Inhalt  einer 16-Bit-
Variablen  auf der Zeropage auf den  Stack legt: Obwohl der Operand ei-
ne  Adresse  ist,  wird  wieder  immediate-Adressierung  verlangt. Hier
lÑ·t AS schlicht beide Versionen zu (d.h. mit oder ohne Gartenzaun).


        4.10. M16
        ---------

Die  M16-Familie  ist  eine  Familie Ñu·erst komplexer CISC-Prozessoren
mit  einem entsprechend  komplizierten Befehlssatz.  Zu den Eigenschaf-
ten  dieses Befehlssatzes gehîrt es  unter anderem, da· bei Operationen
mit  zwei Operanden  beide Operanden  verschiedene LÑngen haben dÅrfen.
Die  bei Motorola Åbliche  und von Mitsubishi  Åbernommene Methode, die
Operandengrî·e  als Attribut an den  Befehl anzuhÑngen, mu·te daher er-
weitert  werden: Es ist erlaubt, auch  an die Operanden selber Attribu-
te anzuhÑngen. So wird im folgenden Beispiel

        mov     r0.b,r6.w

Register  0 8-bittig  gelesen, auf  32 Bit  vorzeichenerweitert und das
Ergebnis  in Register  6 kopiert.  Da man  in 9  von 10 FÑllen aber von
diesen  Mîglichkeiten doch  keinen Gebrauch  macht, kann  man weiterhin
die Operandengrî·e an den Befehl selber schreiben, z.B. so:

        mov.w   r0,r6

Beide   Varianten   dÅrfen   auch   gemischt   verwendet  werden,  eine
Grî·enangabe  am Operanden Åbersteuert dann  den ,,Default'' am Befehl.
Eine  Ausnahme stellen Befehle  mit zwei Operanden  dar. Bei diesen ist
der  Default  fÅr  den  Quelloperanden  die Grî·e des Zieloperanden. In
folgendem Beispiel

        mov.h   r0,r6.w

wird  also auf  Register 0  32-bittig zugegriffen,  die Grî·enangabe am
Befehl  wird Åberhaupt nicht mehr  benutzt. Finden sich Åberhaupt keine
Angaben  zur Operandengrî·e, so  wird Wort(w) verwendet.  Merke: im Ge-
gensatz zu den 68000ern bedeutet dies 32 und nicht 16 Bit!

Reichlich  kompliziert sind auch die verketteten Adressierungsmodi; da-
durch,  da· AS die Verteilung  auf Kettenelemente automatisch vornimmt,
bleibt  die  Sache  aber  einigerma·en  Åbersichtlich. Die einzige Ein-
griffsmîglichkeit,  die bei  AS gegeben  ist (der Originalassembler von
Mitsubishi/Green  Hills  kann  da  noch  etwas mehr), ist die explizite
Festlegung  von Displacement-LÑngen  mittels der  AnhÑngsel :4, :16 und
:32.


        4.11. 4004/4040
        ---------------

John  Weinrich  sei  dank,  habe  ich  nun  auch die offiziellen Daten-
blÑtter  von  Intel  Åber  diese  'UrvÑter' aller Mikroprozessoren, und
die  Unklarheiten  Åber  die  Syntax  von  Registerpaaren  (fÅr  8-Bit-
Operationen)  sind fÅrs erste  ausgerÑumt. Die Syntax  lautet RnRm, wo-
bei  n bzw. m gerade Integers im Bereich 0 bis E bzw. 1 bis F sind. Da-
bei gilt immer m = n + 1.


        4.12. MCS-48
        ------------

Der  maximale  Adre·raum  dieser  Prozessoren  betrÑgt  4 Kbyte. Dieser
Raum  ist jedoch  nicht linear  organisiert (wie  kînnte das  bei Intel
auch  anders sein...), sondern in 2 BÑnke zu 2 Kbyte geteilt. Ein Wech-
sel  zwischen diesen beiden  BÑnken ist nur  durch die Befehle CALL und
JMP  erlaubt, indem vor dem Sprung  das hîchste Adre·bit mit den Befeh-
len  SEL MB0 bzw. SEL MB1 vorgegeben  wird. Um den Wechsel zwischen den
BÑnken  zu vereinfachen,  ist eine  Automatik in  den Befehlen  JMP und
CALL  eingebaut,  die  einen  dieser  beiden Befehle einfÅgt, falls die
Adresse  des  Sprungbefehles  und  das  Sprungziel in unterschiedlichen
BÑnken  liegen. Die explizite Benutzung  der SEL MBx-Befehle sollte da-
her  nicht notwendig sein (obwohl sie mîglich ist) und kann die Automa-
tik auch durcheinanderbringen, wie in dem folgenden Beispiel:

000:    SEL     MB1
	JMP     200h

AS  nimmt an,  da· das  MB-Flag auf  0 steht  und fÅgt  keinen SEL MB0-
Befehl  vor dem Sprung ein, mit der Folge, da· der Prozessor zur Adres-
se  A00h  springt.  Weiterhin  ist  zu  beachten,  da· ein Sprungbefehl
durch diesen Mechanismus unter UmstÑnden ein Byte lÑnger wird.


        4.13. MCS-51
        ------------

Dem  Assembler liegen die Dateien  STDDEF51.INC bzw. 80C50X.INC bei, in
denen  alle Bits  und SFRs  der Prozessoren  8051, 8052  und 80515 bzw.
80C501,  502 und 504 verzeichnet sind.  Je nach Einstellung des Prozes-
sortyps  mit dem CPU-Befehl  wird dabei die  korrekte Untermenge einge-
bunden,  die richtige Reihenfolge  fÅr den Anfang  eines Programmes ist
daher

	CPU     <Prozessortyp>
	INCLUDE stddef51.inc   ,

sonst  fÅhren die MCS-51-Pseudobefehle in  der Include-Datei zu Fehler-
meldungen.

Da  der 8051 keinen  Befehl kennt, um  die Register 0..7  auf den Stack
zu  legen, mu·  mit deren  absoluten Adressen  gearbeitet werden. Diese
hÑngen  aber  von  der  momentan  aktiven  Registerbank  ab.  Um diesem
Mi·stand  etwas abzuhelfen, ist in  den Include-Dateien das Makro USING
definiert,  dem als  Parameter die  Symbole Bank0..Bank3 gegeben werden
kînnen.  Das Makro belegt  daraufhin die Symbole  AR0..AR7 mit den pas-
senden  absoluten Adressen der  Register. Dieses Makro  sollte nach je-
der  Bankumschaltung benutzt werden. Es  erzeugt selber keinen Code zur
Umschaltung!

Das  Makro fÅhrt in der Variablen  RegUsage gleichzeitig Buch Åber alle
jemals  benutzten RegisterbÑnke;  Bit 0  entspricht Bank  0, Bit  1 der
Bank  1 usw. . Der Inhalt kann  am Ende der Quelldatei z.B. mit folgen-
dem CodestÅck ausgegeben werden:

	irp     BANK,Bank0,Bank1,Bank2,Bank3
	 if      (RegUsage&(2^BANK))<>0
	  message "Bank \{BANK} benutzt"
	 endif
	endm

Mit   der  Mehrpass-FÑhigkeit   ab  Version   1.38  wurde  es  mîglich,
zusÑtzlich  die  Befehle  JMP  und  CALL einzufÅhren. Bei der Kodierung
von  SprÅngen mit  diesen Befehlen  wÑhlt AS  je nach Adre·lage automa-
tisch  die optimale  Variante, d.h.  SJMP/AJMP/LJMP fÅr  JMP und ACALL/
LCALL  fÅr CALL. Es ist natÅrlich  weiterhin mîglich, die Varianten di-
rekt zu verwenden, um eine bestimmte Kodierung zu erzwingen.


        4.14. MCS-251
        -------------

Intel  hat sich beim 80C251 ja bemÅht, den öbergang fÅr den Programmie-
rer  auf die neue Familie so weich  wie mîglich zu gestalten, was darin
gipfelt,  da· alte Anwendungen  ohne NeuÅbersetzung auf  dem neuen Pro-
zessor  ablaufen kînnen. Sobald man  jedoch den erweiterten Befehlssatz
der  80C251 nutzen will, gilt es,  einige Details zu beachten, die sich
als versteckte Fu·angeln auftun.

An  vorderster Stelle steht  dabei die Tatsache,  da· der 80C251 keinen
getrennten  Bitadre·raum  mehr  hat.  Es  sind  nunmehr  alle  SFRs un-
abhÑngig  von ihrer Adre·lage sowie  die ersten 128 Speicherstellen des
internen  RAMs bitadressierbar. Mîglich wird dies dadurch, da· die Bit-
adressierung  nicht mehr Åber  einen zusÑtzlichen virtuellen Adre·raum,
der  andere Adre·rÑume Åberdeckt,  erfolgt, sondern so  wie bei anderen
Prozessoren  auch  durch  eine  zweidimensionale  Adressierung, die aus
der  Speicherstelle,  die  das  Bit  beinhaltet  sowie der Bitstelle im
Byte  besteht. Dies  bedeutet zum  einen, da·  bei einer  Bitangabe wie
z.B.  PSW.7 AS die Zerlegung der Teile  links und rechts vom Punkt sel-
ber  vornimmt.  Es  ist  also  nicht  mehr  nîtig,  mittels eines SFRB-
Befehls  wie noch beim 8051 explizit 8 Bitsymbole zu erzeugen. Dies be-
deutet  zum anderen, da· es den  SFRB-Befehl Åberhaupt nicht mehr gibt.
Wird  er  in  zu  portierenden  8051-Programmen  benutzt, kann er durch
einen einfachen SFR-Befehl ersetzt werden.

Weiterhin  hat  Intel  in  den  unterschiedlichen  Adre·rÑumen des 8051
gehîrig  aufgerÑumt: Der Bereich  des internen RAMs  (DATA bzw. IDATA),
der  XDATA-Bereich und er bisherige CODE-Bereich wurden in einem einzi-
gen,  16 Mbyte gro·en  CODE-Bereich vereinigt. Das  interne RAM beginnt
bei  Adresse 0,  das interne  ROM beginnt  bei Adresse ff0000h, dorthin
mu·  also auch  der Code  mittels ORG  hinverlagert werden. Ausgelagert
wurden  dagegen die SFRs in einen eigenen Adre·raum (der bei AS als IO-
Segment  definiert ist). In  diesem neuen Adre·raum  haben sie aber die
gleichen  Adressen wie  beim 8051.  Der SFR-Befehl  kennt diesen Unter-
schied  und legt mit ihm erzeugte Symbole je nach Zielprozessor automa-
tisch  ins  DATA-  bzw.  IO-Segment.  Da  es  keinen Bit-Adre·raum mehr
gibt,  funktioniert der BIT-Befehl vîllig anders: anstelle einer linea-
ren  Adresse von  0 bis  255 beinhalten  Bit-Symbole jetzt  in Bit 0..7
die  Adresse, in  Bit 24..26  die Bitstelle.  Damit ist es jetzt leider
nicht  mehr so einfach  mîglich, Felder von  Flags mit symbolischen Na-
men anzulegen: Wo man beim 8051 noch z.B.

        segment bitdata

bit1    db      ?
bit2    db      ?

oder

defbit	macro   name
name    bit     cnt
cnt     set     cnt+1
        endm

schreiben  konnte,  hilft  jetzt  nur  noch die zweite Variante weiter,
z.B. so:

adr     set     20h     ; Startadresse Flags im internen RAM
bpos    set     0

defbit  macro   name
name    bit     adr.bpos
bpos    set     bpos+1
        if      bpos=8
bpos     set     0
adr      set     adr+1
        endif
        endm

Ein  weiteres, kleines Detail: Da Intel  als Kennzeichnung fÅr den Car-
ry  nun CY statt  C bevorzugt, sollte  man ein eventuell benutztes Sym-
bol  umbenennen. AS versteht  aber auch weiterhin  die alte Variante in
den  Befehlen CLR,  CPL, SETB,  MOV, ANL,  und ORL. Gleiches gilt sinn-
gemÑ·  fÅr die  dazugekommenen Register  R8..R15, WR0..WR30, DR0..DR28,
DR56, DR60, DPX und SPX.

Intel  mîchte es gerne,  da· man absolute  Adressen in der Form XX:YYYY
schreibt,  wobei XX eine 64K-Bank im  Adre·raum angibt bzw. mit einem S
Adressen  im IO-Raum kennzeichnet. Wie man sich schon denken kann, hal-
te  ich davon nicht  allzu viel, weshalb  man an allen Stellen Adressen
genauso  gut linear angeben kann; lediglich um das S fÅr die Kennzeich-
nung von I/O-Adressen kommt man nicht herum, z.B. hier:

Carry   bit   s:0d0h.7

Ohne  den PrÑfix wÅrde AS die  absolute Adresse in das Code-Segment le-
gen, und dort sind ja nur die ersten 128 Byte bitadressierbar...

Wie  auch  schon  beim  8051  gibt  es  die generischen Befehle JMP und
CALL,  die je nach Adre·lage  automatisch die kÅrzeste Variante einset-
zen.  WÑhrend JMP aber  die Variante mit  24 Bit mitberÅcksichtigt, tut
CALL  dies aus gutem Grund nicht:  Der ECALL-Befehl legt nÑmlich im Ge-
gensatz  zu ACALL und LCALL 3 Bytes  auf den Stack, und man hÑtte sonst
einen  CALL-Befehl, bei dem man nicht mehr  genau wei·, was er tut. Bei
JMP tritt diese Problem nicht auf.

Aus  einer Sache  bin ich  nicht ganz  schlau geworden:  Der 80251 kann
auch  immediate-Operanden auf den Stack  legen, und zwar sowohl einzel-
ne  Bytes als auch ganze Wîrter. FÅr beide Varianten ist aber der glei-
che  Befehl PUSH vorgesehen  -- und woher  soll bitte ein Assembler bei
einer Anweisung wie

        push #10

wissen,  ob ein Byte  oder ein Wort  mit dem Wert  10 auf den Stack ge-
legt  werden  soll?  Daher  gilt  im  Augenblick die Regelung, da· PUSH
grundsÑtzlich  ein  Byte  ablegt;  wer  ein Wort ablegen will, schreibt
einfach PUSHW anstelle PUSH.

Noch  ein gutgemeinter  Ratschlag: Wer  den erweiterten Befehlssatz des
80C251  nutzt, sollte den Prozessor  auch tunlichst im Source-Modus be-
treiben,  sonst werden alle  neuen Anweisungen ein  Byte lÑnger! Um die
originÑren  8051-Anweisungem, die dafÅr  im Source-Modus lÑnger werden,
ist  es nicht besonders schade: Sie  werden entweder von AS automatisch
durch  neue, leistungsfÑhigere ersetzt oder  sind be- treffen veraltete
Adressierungsarten (indirekte Adressierung mit 8-Bit-Registern).


        4.15. 8085UNDOC
        ---------------

éhnlich  wie beim Z80 oder 6502, sind auch beim 8085 die undokumentier-
ten  Befehle  nicht  nÑher  von  Intel  spezifiziert worden, weshalb es
nicht  undenkbar ist, da· andere  Assembler andere Mnemonics dafÅr ver-
wenden.  Deshalb sollen auch diese Befehle  und ihre Funktion hier kurz
aufgelistet  werden. Und auch hier wieder ist die Verwendung dieser Be-
fehle   auf   eigenes   Risiko   -   schon   der   an   sich  zum  8085
aufwÑrtskompatible  Z80 benutzt  diese Opcodes  fÅr vîllig andere Funk-
tionen...


 
Anweisung : DSUB [reg]
Funktion  : HL <- HL - reg
Flags     : CY, S, X5, AC, Z, V, P
Argumente : reg = B fÅr BC (optional)



 
Anweisung : ARHL
Funktion  : HL,CY <- HL >> 1 (arithmetisch)
Flags     : CY
Argumente : keine



 
Anweisung : RDEL
Funktion  : CY,DE <- DE << 1
Flags     : CY, V
Argumente : keine



 
Anweisung : LDHI d8
Funktion  : DE <- HL + d8
Flags     : keine
Argumente : d8 = 8-Bit-Konstante



 
Anweisung : LDSI d8
Funktion  : DE <- SP + d8
Flags     : keine
Argumente : d8 = 8-Bit-Konstante



 
Anweisung : RST flag
Funktion  : Restart zu 40h wenn flag=1
Flags     : keine
Argumente : flag = V fÅr Overflow-Bit



 
Anweisung : SHLX [reg]
Funktion  : [reg] <- HL
Flags     : keine
Argumente : reg = D fÅr DE (optional)



 
Anweisung : LHLX [reg]
Funktion  : HL <-[reg]
Flags     : keine
Argumente : reg = D fÅr DE (optional)



 
Anweisung : JNX5 adr
Funktion  : springe zu adr wenn X5=0
Flags     : keine
Argumente : adr = absolute 16-Bit-Adresse



 
Anweisung : JX5 adr
Funktion  : springe zu adr wenn X5=1
Flags     : keine
Argumente : adr = absolute 16-Bit-Adresse


Mit  X5 ist  dabei das  ansonsten unbenutzte  Bit 5 im PSW-Register ge-
meint.


        4.16. 8086..V35
        ---------------

Eigentlich  hatte ich mir geschworen,  die Segmentseuche der 8086er aus
diesem  Assembler herauszuhalten.  Da aber  nun eine  Nachfrage kam und
Studenten  flexiblere  Menschen  als  die  Entwickler dieses Prozessors
sind,  findet sich ab  sofort auch eine  rudimentÑre UnterstÅtzung die-
ser  Prozessoren in AS. Unter  ,,rudimentÑr'' verstehe ich dabei nicht,
da·  der Befehlssatz nicht vollstÑndig  abgedeckt wird, sondern da· ich
nicht  den ganzen Wust  an Pseudoanweisungen integriert  habe, die sich
bei  MASM, TASM  & Co.  finden. AS  ist auch  nicht in erster Linie ge-
schrieben  worden,  um  PC-Programme  zu  entwickeln (Gott bewahre, das
hie·e  wirklich, das Rad neu zu erfinden), sondern zur Programmentwick-
lung  fÅr Einplatinenrechner, die  eben unter anderem  auch mit 8086ern
bestÅckt sein kînnen.

FÅr  Unentwegte, die mit  AS doch DOS-Programme  schreiben wollen, eine
kleine Liste dessen, was zu beachten ist:

  - Es kînnen nur COM-Programme erzeugt werden.
  - Verwenden  Sie nur das CODE-Segment, und legen Sie auch alle Varia-
    blen darin ab.
  - Alle  Segmentregister werden von DOS auf das Codesegment vorinitia-
    lisiert.  Ein ASSUME  DS:CODE, SS:CODE  am Programmanfang ist daher
    notwendig.
  - DOS  lÑdt den Code ab  Adresse 100h. Ein ORG  auf diese Adresse ist
    daher zwingend.
  - Die  Umwandlung in eine BinÑrdatei  erfolgt mit P2BIN (s.u.), wobei
    als als Adre·bereich $-$ anzugeben ist.

Allgemein   unterstÅtzt  AS  fÅr  diese   Prozessoren  nur  ein  Small-
Programmiermodell,  d.h. ein Codesegment  mit maximal 64  KByte und ein
ebenfalls  hîchstens 64 KByte gro·es  Datensegment mit (fÅr COM-Dateien
uninitialisierten)  Daten.  Zwischen  diesen  beiden Segmenten kann mit
dem  SEGMENT-Befehl hin-und  hergeschaltet werden.  Aus dieser Tatsache
folgert,  da· SprÅnge  immer intrasegmentÑr  sind, sofern  sie sich auf
Adressen  im Codesegment beziehen. Falls  weite SprÅnge doch einmal er-
forderlich  sein sollten, kînnen sie mit CALLF und JMPF und einer Spei-
cheradresse  oder einen Segment:Offset-Wert  als Argument erreicht wer-
den.

Ein  weiteres gro·es Problem dieser Prozessoren ist deren Assemblersyn-
tax,  deren genaue  Bedeutung nur  aus dem  Zusammenhang erkennbar ist.
So  kann im  folgenden Beispiel  je nach  Symboltyp sowohl unmittelbare
als auch absolute Adressierung gemeint sein:

        mov     ax,wert

Bei  AS ist immer  unmittelbare Adressierung gemeint,  wenn um den Ope-
randen  keine eckigen Klammern  stehen. Soll z.B.  die Adresse oder der
Inhalt  einer Variablen geladen werden, so  ergeben sich die in Tabelle
4.1 aufgelisteten Unterschiede.

          +-----------+--------------------+---------------+
          | Assembler | Adresse            | Inhalt        |
          +-----------+--------------------+---------------+
          +-----------+--------------------+---------------+
          | MASM      | mov ax,offset vari | mov ax,vari   |
          |           | lea ax,vari        | mov ax,[vari] |
          |           | lea ax,[vari]      |               |
          |           |                    |               |
          | AS        | mov ax,vari        | mov ax,[vari] |
          |           | lea ax,[vari]      |               |
          |           |                    |               |
          +-----------+--------------------+---------------+

Tabelle 4.1: Unterschiede in der Adressierungssyntax AS<->MASM


Der  Assembler prÅft  bei Symbolen,  ob sie  im Datensegment liegen und
versucht,  automatisch einen  passenden SegmentprÑfix  einzufÅgen, z.B.
falls  ohne CS-PrÑfix auf Symbole im  Code zugegriffen wird. Dieser Me-
chanismus  kann  jedoch  nur  funktionieren,  falls  der  ASSUME-Befehl
(siehe dort) korrekt angewendet wurde.

Die  Intel-Syntax verlangt eine  Abspeicherung, ob an  einem Symbol By-
tes  oder Wîrter abgelegt  wurden. AS nimmt  diese Typisierung nur vor,
falls  in der gleichen  Zeile wie das  Label ein DB  oder DW steht. FÅr
alle  anderen FÑlle mu· mit den Operatoren  WORD PTR, BYTE PTR usw. ex-
plizit  angegeben werden, um  was fÅr eine  Operandengrî·e es sich han-
delt.  Solange ein  Register an  der Operation  beteiligt ist, kann auf
diese  Kennzeichnung verzichtet werden, da  durch den Registernamen die
Operandengrî·e eindeutig bestimmt ist.

Der  Koprozessor in  8086-Systemen wird  Åblicherweise durch  den TEST-
Eingang  des Prozessors  synchronisiert, indem  selbiger mit  dem BUSY-
Ausgang  des Koprozessors verbunden wird.  AS unterstÅtzt dieses Hands-
haking,  indem vor  jedem 8087-Befehl  automatisch ein WAIT-Befehl ein-
gefÅgt  wird.  Ist  dies  aus  irgendwelchen  GrÅnden unerwÅnscht (z.B.
wÑhrend  der Initialisierung), so mu· im Opcode hinter dem F ein N ein-
gefÅgt werden; aus

        FINIT
        FSTSW   [vari]

wird so z.B.

        FNINIT
        FNSTSW  [vari]

Diese Variante ist bei allen Koprozessorbefehlen erlaubt.


        4.17. 8X30x
        -----------

Die  Prozessoren dieser Reihe  sind auf eine  einfache Manipulation von
Bitgruppen  auf  Peripherieadressen  optimiert  worden.  Um mit solchen
Bitgruppen  auch symbolisch  umgehen zu  kînnen, existieren die Befehle
LIV  und RIV, mit  denen einer solchen  Bitgruppe ein symbolischer Name
zugewiesen  wird.  Diese  Befehle  arbeiten  Ñhnlich wie EQU, benîtigen
aber drei Parameter:

  1 die  Adresse der peripheren Speicherzelle, in der sich die Bitgrup-
    pe befindet (0..255);
  2 die Bitnummer des ersten Bits in der Gruppe (0..7);
  3 die LÑnge der Gruppe in Bits (1..8).

ACHTUNG!  Der  8X30x  unterstÅtzt  keine  Bitgruppen,  die Åber mehrere
Speicherstellen  hinausreichen, so da· je nach Startposition der Werte-
bereich  fÅr die  LÑnge eingeschrÑnkt  sein kann.  AS nimmt  hier keine
PrÅfung  vor, man bekommt lediglich  zur Laufzeit merkwÅrdige Ergebnis-
se!

Im  Maschinencode drÅcken sich LÑnge  und Position durch ein 3-Bit-Feld
im  Instruktionswort sowie  ein passende  Registernummer (LIVx bzw. RI-
Vx)  aus. Bei der Verwendung eines  symbolischen Objektes wird AS diese
Felder  automatisch  richtig  besetzen,  es  ist aber auch erlaubt, die
LÑnge  als  dritten  Operanden  explizit  anzugeben, wenn man nicht mit
symbolischen  Busobjekten  arbeitet.  Trifft  AS  auf eine LÑngenangabe
trotz  eines symbolischen Operanden, so  vergleicht er beide LÑngen und
gibt  eine  Fehlermeldung  bei  Ungleichheit  aus (das gleiche passiert
Åbrigens  auch, wenn man bei einem MOVE-Befehl zwei symbolische Operan-
den  mit unterschiedlicher LÑnge benutzt  - die Instruktion hat einfach
nur ein LÑngenfeld...).

Neben  den  eigentlichen  Maschinenbefehlen  des 8X30x implementiert AS
noch  Ñhnlich  wie  das  ,,Vorbild''  MCCAP einige Pseudoinstruktionen,
die als eingebaute Makros ausgefÅhrt sind:

  - NOP ist eine Kurzschreibweise fÅr MOVE AUX,AUX
  - HALT ist eine Kurzschreibweise fÅr JMP *
  - XML ii ist eine Kurzschreibweise fÅr XMIT ii,R12 (nur 8X305)
  - XMR ii ist eine Kurzschreibweise fÅr XMIT ii,R13 (nur 8X305)
  - SEL  <busobj>  ist  eine  Kurzschreibweise  fÅr XMIT <adr>,IVL/IVR,
    fÅhrt  also die notwendige Vorselektion  durch, um <busobj> anspre-
    chen zu kînnen.

Die  bei MCCAP  ebenfalls noch  vorhandenen CALL- und RTN-Instruktionen
sind  mangels  ausreichender  Dokumentation  momentan  nicht  implemen-
tiert.  Das gleiche gilt fÅr einen  Satz an Pseudoinstruktionen zur Da-
tenablage. Kommt Zeit, kommt Rat...


        4.18. XA
        --------

éhnlich  wie  sein  VorgÑnger  MCS/51,  jedoch im Unterschied zu seinem
,,Konkurrenten''  MCS/251  besitzt  der  Philips  XA  einen  getrennten
Bitadre·raum,  d.h. alle mit Bitbefehlen manipulierbaren Bits haben ei-
ne  bestimmte,  eindimensionale  Adresse,  die in den Maschinenbefehlen
auch  so abgelegt  wird. Die  naheliegende Mîglichkeit,  diesen dritten
Adre·raum  (neben Code  und Daten)  auch so  in AS anzubieten, habe ich
nicht  nutzen kînnen,  und zwar  aus dem  Grund, da·  ein Teil der Bit-
adressen  im Gegensatz  zum MCS/51  nicht mehr  eindeutig ist: Bits mit
den  Adressen 256 bis  511 bezeichnen Bits  der Speicherzellen 20h..3fh
aus  dem aktuellen Datensegment.  Dies bedeutet aber,  da· diese Adres-
sen  je nach  Situation unterschiedliche  Bits ansprechen  kînnen - ein
definieren  von Bits  mit Hilfe  von DC-Befehlen,  was durch  ein extra
Segment  mîglich geworden  wÑre, wÅrde  also nicht  ÅbermÑ·ig viel Sinn
ergeben.   Zur  Definition  einzelner,  symbolisch  ansprechbarer  Bits
steht  aber nach wie vor der BIT-Befehl zur VerfÅgung, mit dem beliebi-
ge  Bitadressen (Register, RAM, SFR)  definiert werden kînnen. FÅr Bit-
adressen  im internen  RAM wird  auch die 64K-Bank-Adresse gespeichert,
so  da·  AS  Zugriffe  ÅberprÅfen  kann, sofern das DS-Register korrekt
mit ASSUME vorbesetzt wurde.

Nichts  drehen kann man  dagegen an den  BemÅhungen von AS, potentielle
Sprungziele  (also Zeilen im Code mit Label) auf gerade Adressen auszu-
richten.  Dies  macht  AS  genauso  wie  andere XA-Assembler auch durch
EinfÅgen von NOPs vor dem fraglichen Befehl.


        4.19. AVR
        ---------

Im  Gegensatz zum  AVR-Assembler verwendet  AS defaultmÑ·ig  das Intel-
Format  zur  Darstellung  von  Hexadezimalkonstanten  und  nicht die C-
Syntax.  OK,  nicht  vorher  in  den  (freien)  AVR-Assembler hineinge-
schaut,  aber als  ich mit  dem AVR-Teil  anfing, gab  es zum  AVR noch
nicht  wesentlich mehr  als ein  vorlÑufiges Datenbuch mit Prozessorty-
pen,  die dann doch  nie kamen...mit einem  RELAXED ON schafft man die-
ses Problem aus der Welt.

Optional  kann AS  fÅr die  AVRs (es  geht auch  fÅr andere  CPU's, nur
macht  es dort keinen  Sinn...) sogenannte ,,Objekt-Dateien'' erzeugen.
Das  sind Dateien,  die sowohl  Code als  auch Quellzeileninformationen
enthalten  und  z.B.  eine  schrittweise Abarbeitung auf Quellcodeebene
mit  dem  von  Atmel  gelieferten  Simulator  WAVRSIM  erlauben. Leider
scheint  dieser mit  Quelldateispezifikationen, die  lÑnger als  ca. 20
Zeichen  sind,  seine  liebe  Not  zu haben: Namen werden abgeschnitten
oder   um   wirre   Sonderzeichen   ergÑnzt,   wenn   die  MaximallÑnge
Åberschritten  wird. AS speichert deshalb in den Objekt-Dateien Datein-
amen  ohne Pfadangabe, so da· es  eventuell Probleme geben kînnte, wenn
Dateien (z.B. Includes) nicht im Arbeitsverzeichnis liegen.

Eine  kleine Besonderheit sind Befehle, die Atmel bereits in der Archi-
tektur  vorgesehen hat, aber noch in keinem Mitglied der Familie imple-
mentiert  wurden. Dabei  handelt es  sich um  die Befehle  MUL, JMP und
CALL.  Besonders bei letzteren fragt man  sich vielleicht, wie man denn
nun  den 4 KWorte  gro·en Adre·raum des  AT90S8515 erreichen kann, wenn
die  'nÑchstbesten'  Befehle  RJMP  und  RCALL  doch  nur 2 KWorte weit
springen  kann.  Der  Kunstgriff  lautet  'Abschneiden  der  oberen Ad-
re·bits' und ist nÑher bei der WRAPMODE-Anweisung beschrieben.


        4.20. Z80UNDOC
        --------------

Da  es von Zilog naturgemÑ· keine Syntaxvorgaben fÅr die undokumentier-
ten  Befehle gibt und wohl auch  nicht jeder den kompletten Satz kennt,
ist es vielleicht sinnvoll, diese Befehle hier kurz aufzuzÑhlen:

Wie  auch beim Z380 ist es mîglich, die Byte-HÑlften von IX und IY ein-
zeln anzusprechen. Im einzelnen sind dies folgende Varianten:

 INC Rx              LD R,Rx             LD  Rx,n
 DEC Rx              LD Rx,R             LD  Rx,Ry
 ADD/ADC/SUB/SBC/AND/XOR/OR/CP A,Rx

Dabei  stehen Rx bzw.  Ry fÅr IXL,  IXU, IYL oder  IYU. Zu beachten ist
jedoch,  da· in der  LD Rx,Ry-Variante beide  Register aus dem gleichen
Indexregister stammen mÅssen.

Die  Kodierung von Schiebebefehlen besitzt  noch eine undefinierte Bit-
kombination,  die  als  SLIA-Befehl  zugÑnglich  ist. SLIA funktioniert
wie  SLA, es wird jedoch eine Eins und  nicht eine Null in Bit 0 einge-
schoben.  Dieser  Befehl  kann,  wie  alle anderen Schiebebefehle auch,
noch in einer weiteren Variante geschrieben werden:

        SLIA    R,(XY+d)

Dabei  steht R fÅr  ein beliebiges 8-Bit-Register  (aber nicht eine In-
dexregisterhÑlfte...),  und  (XY+d)  fÅr  eine  normale  indexregister-
relative  Adressierung.  Das  Ergebnis  dieser  Operation  ist, da· das
Schiebeergebnis  zusÑtzlich  ins  Register  geladen wird. Dies funktio-
niert auch bei den RES- und SET-Befehlen:

        SET/RES R,n,(XY+d)

Des weiteren gibt es noch zwei versteckte I/O-Befehle:

        IN      (C) bzw. TSTI
        OUT     (C),0

Deren  Funktionsweise sollte klar  sein. ACHTUNG! Es  gibt keine Garan-
tie  dafÅr,  da·  alle  Z80-Masken  alle diese Befehle beherrschen, und
die  Z80-Nachfolger lîsen  zuverlÑssig Traps  aus. Anwendung  daher auf
eigene Gefahr...


        4.21. Z380
        ----------

Da  dieser Prozessor als Enkel des  wohl immer noch beliebtesten 8-Bit-
Prozessors  konzipiert wurde,  war es  bei der Entwicklung unabdingbar,
da·  dieser  bestehende  Z80-Programme  ohne  énderung  ausfÅhren  kann
(natÅrlich  geringfÅgig schneller, etwa  um den Faktor  10...). Die er-
weiterten  FÑhigkeiten kînnen daher nach einem Reset mit zwei Flags zu-
geschaltet  werden,  die  XM  (eXtended  Mode,  d.h.  32- statt 16-Bit-
Adre·raum)  und LW (long  word mode, d.h.  32- statt 16- Bit-Operanden)
hei·en.  Deren Stand mu· man AS  Åber die Befehle EXTMODE und LWORDMODE
mitteilen,  damit  Adressen  und  Konstantenwerte  gegen  die korrekten
Obergrenzen  geprÅft werden.  Die Umschaltung  zwischen 32- und 16-Bit-
Befehlen  bewirkt natÅrlich  nur bei  solchen Befehlen  etwas, die auch
in  einer 32-Bit-Version existieren;  beim Z380 sind  das momentan lei-
der  nur Lade-  und Speicherbefehle,  die ganze  Aritmetik kann nur 16-
bittig  ausgefÅhrt  werden.  Hier  sollte  Zilog wohl noch einmal etwas
nachbessern,  sonst kann  man den  Z380 selbst  beim besten  Willen nur
als ,,16-Bit-Prozessor mit 32-Bit-Erweiterungen'' bezeichnen...

Kompliziert  wird die Sache  dadurch, da· die  mit LW eingestellte Ope-
randengrî·e  fÅr einzelne Befehle  mit den PrÑfixen  DDIR W und DDIR LW
Åbersteuert  werden kann. AS  merkt sich das  Auftreten solcher Befehle
und  schaltet  dann  fÅr  den  nÑchsten Prozessorbefehl automatisch mit
um.  Andere DDIR-Varianten als W und  LW sollte man Åbrigens nie expli-
zit  verwenden, da  AS bei  zu langen  Operanden diese automatisch ein-
setzt,  und  das  kînnte  zu  Verwirrungen  fÅhren.  Die Automatik geht
Åbrigens so weit, da· in der Befehlsfolge

        DDIR    LW
        LD      BC,12345678h

automatisch  der erforderliche IW-PrÑfix mit in die vorangehende Anwei-
sung hineingezogen wird, effektiv wird also der Code

        DDIR    LW,IW
        LD      BC,12345678h

erzeugt.  Der im ersten Schritt erzeugte  Code fÅr DDIR LW wird verwor-
fen, was an einem R im Listing zu erkennen ist.


        4.22. TLCS-900(L)
        -----------------

Diese  Prozessoren kînnen in zwei Betriebsarten laufen, einmal im Mini-
mum-Modus,  der  weitgehende  Z80-  und TLCS-90-QuellcodekompatibilitÑt
bietet,  und zum  anderen im  Maximum-Modus, in  dem der Prozessor erst
seine  wahren QualitÑten entfaltet.  Die Hauptunterschiede zwischen den
beiden Betriebsarten sind:

  - Breite der Register WA,BC,DE und HL: 16 oder 32 Bit;
  - Anzahl der Registerbanks: 8 oder 4;
  - Programmadre·raum: 64 Kbyte oder 16 Mbyte;
  - Breite von RÅcksprungadressen: 16 oder 32 Bit.

Damit  AS gegen die richtigen  Grenzen prÅfen kann, mu·  man ihm zu An-
fang  mit dem  Befehl MAXMODE  (siehe dort)  mitteilen, in  welcher Be-
triebsart  der Code ausgefÅhrt werden  wird; Voreinstellung ist der Mi-
nimum-Modus.

Je  nach  Betriebsart  mÅssen  demzufolge  auch  die  16-  oder 32-Bit-
Versionen  der  Bankregister  zur  Adressierung  verwendet werden, d.h.
WA,  BC, DE und HL im Minimum-Modus sowie  XWA, XBC, XDE und XHL im Ma-
ximum-Modus.  Die Register  XIX..XIZ und  XSP sind  immer 32  Bit breit
und  mÅssen zur Adressierung  auch immer in  dieser Form verwendet wer-
den;  hier mu· bestehender  Z80-Code also auf  jeden Fall angepa·t wer-
den  (neben der  Tatsache, da·  es gar  keinen I/O-Adre·raum  mehr gibt
und alle I/O-Register memory-mapped sind...).

Die  von Toshiba gewÑhlte Syntax fÅr  Registernamen ist in der Hinsicht
etwas  unglÅcklich, als da· zur  Anwahl der vorherigen Registerbank ein
Hochkomma  (') benutzt wird.  Dieses Zeichen wird  von den prozessorun-
abhÑngigen  Teilen von AS bereits zur Kennzeichnung von Zeichenkonstan-
ten benutzt. Im Befehl

        ld      wa',wa

erkennt  AS z.B. nicht das  Komma zur Parametertrennung. Dieses Problem
kann  man aber umgehen, indem man ein umgekehrtes Hochkomma (`) verwen-
det, z.B.

        ld      wa`,wa

Toshiba   liefert  fÅr   die  TLCS-900-Reihe   selber  einen  Assembler
(TAS900), der sich in einigen Punkten von AS unterscheidet:


        Symbolkonventionen
        ..................


  - TAS900  unterscheidet Symbolnamen  nur auf  den ersten  32 Zeichen.
    AS  dagegen speichert  Symbolnamen immer  in der  vollen LÑnge (bis
    255 Zeichen) und unterscheidet auch auf dieser LÑnge.
  - Unter  TAS900  kînnen  Integerkonstanten  sowohl in C-Notation (mit
    vorangestellter  0 fÅr oktal  bzw. 0x fÅr  hexadezimal) als auch in
    normaler  Intel-Notation geschrieben werden.  AS unterstÅtzt in der
    Default-Einstellung   nur  die  Intel-Notation.  Mit  dem  RELAXED-
    Befehl bekommt man (unter anderem) auch die C-Notation.
  - AS  macht  keinen  Unterschied  zwischen Gro·- und Kleinschreibung,
    TAS900  hingegen unterscheidet Gro·-und  Kleinbuchstaben in Symbol-
    namen.  Dieses Verhalten erhÑlt  man bei AS  erst, wenn man die -u-
    Kommandozeilenoption benutzt.



        Syntax
        ......

AS  ist bei  vielen Befehlen  in der  SyntaxprÅfung weniger  streng als
TAS900,  bei einigen weicht er (sehr) geringfÅgig ab. Diese Erweiterun-
gen  bzw. énderungen dienen teilweise der leichteren Portierung von be-
stehendem  Z80-Code, teilweise einer  Schreiberleichterung und teilwei-
se einer besseren OrthogonalitÑt der Assemblersyntax:

  - Bei   den  Befehlen  LDA,  JP  und   CALL  verlangt  TAS,  da·  Ad-
    re·ausdrÅcke  wie XIX+5 nicht geklammert  sein dÅrfen, wie es sonst
    Åblich  ist. AS verlangt im Sinne  der OrthogonalitÑt fÅr LDA dage-
    gen  immer eine  Klammerung, bei  JP und  CALL ist  sie dagegen fÅr
    einfache, absolute Adressen optional.
  - Bei  den bedingten Befehlen JP,  CALL, JR und SCC  stellt AS es dem
    Programmierer  frei, die  Default-Bedingung T  (= true)  als ersten
    Parameter  anzugeben oder  nicht. TAS900  hingegen erlaubt  es nur,
    die  Default-Bedingung implizit  zu benutzen  (also z.B. jp (xix+5)
    anstelle von jp t,(xix+5)).
  - AS  erlaubt  beim  EX-Befehl  auch Operandenkombinationen, die zwar
    nicht  direkt im User's Manual[106] genannt werden, aber durch Ver-
    tauschung  auf eine genannte  zurÅckgefÅhrt werden kînnen. Kombina-
    tionen  wie EX f`,f  oder EX wa,(xhl)  werden damit mîglich. TAS900
    hingegen lÑ·t nur die ,,reine Lehre'' zu.
  - AS  erlaubt, bei  den Befehlen  INC und  DEC die  Angabe des Inkre-
    ments  oder Dekrements wegzulassen,  wenn dies 1  ist. Unter TAS900
    dagegen mu· auch eine 1 hingeschrieben werden.
  - éhnlich  verhÑlt es sich bei allen Schiebebefehlen: Ist der zu ver-
    schiebende  Operand ein Register, so  verlangt TAS900, da· auch ei-
    ne  Schiebeamplitude von  1 ausgeschrieben  werden mu·; ist dagegen
    eine   Speicherstelle   der   Operand,   so   ist  die  Schiebezahl
    (hardwarebedingt)  immer 1 und darf  auch nicht hingeschrieben wer-
    den.  Unter AS  dagegen ist  die Schiebezahl  1 immer  optional und
    auch fÅr alle Operandentypen zulÑssig.



        Makroprozessor
        ..............

Der  Makroprozessor  wird  TAS900  als  externes Programm vorgeschaltet
und  besteht aus zwei Komponenten: einem C-artigen PrÑprozessor und ei-
ner  speziellen Makrosprache  (MPL), die  an hîhere Programmiersprachen
erinnert.   Der  Makroprozessor  von  AS  dagegen  orientiert  sich  an
,,klassischen''  Makroassemblern wie dem M80 oder MASM (beides Program-
me von Microsoft). Er ist fester Bestandteil des Programmes.


        Ausgabeformat
        .............

TAS900  erzeugt relokatiblen Code, so da· sich mehrere, getrennt assem-
blierte  Teile zu einem Programm zusammenbinden lassen. AS hingegen er-
zeugt  direkt absoluten Maschinencode,  der nicht linkbar  ist. An eine
Erweiterung ist (vorlÑufig) nicht gedacht.


        Pseudoanweisungen
        .................

Bedingt  durch den fehlenden  Linker fehlen in  AS eine ganze Reihe von
fÅr  relokatiblen Code erforderlichen Pseudoanweisungen, die TAS900 im-
plementiert.  In gleicher Weise wie  bei TAS900 sind folgende Anweisun-
gen vorhanden:

    EQU, DB, DW, ORG, ALIGN, END, TITLE, SAVE, RESTORE,

wobei  die  beiden  letzteren  einen erweiterten Funktionsumfang haben.
Einige  weitere TAS900-Pseudobefehle lassen  sich durch Ñquivalente AS-
Befehle ersetzen (siehe Tabelle 4.2).

Von  Toshiba existieren zwei Versionen des Prozessorkerns, wobei die L-
Variante  eine ,,Sparversion''  darstellt. Zwischen  TLCS-900 und TLCS-
900L macht AS folgende Unterschiede:

  - Die  Befehle MAX und  NORMAL sind fÅr  die L-Version nicht erlaubt,
    der MIN-Befehl ist fÅr die Vollversion gesperrt.
  - Die  L-Version kennt den  Normal-Stapelzeiger XNSP/NSP nicht, dafÅr
    das Steuerregister INTNEST.

Die  Befehle SUPMODE und MAXMODE  werden nicht beeinflu·t, ebenso nicht
deren  initiale Einstellung OFF. Die Tatsache, da· die L-Version im Ma-
ximum-Modus  startet und keinen  Normal-Modus kennt, mu·  also vom Pro-
grammierer  berÅcksichtigt werden.  AS zeigt  sich jedoch  insofern ku-
lant  gegenÅber der L-Variante, als  da· Warnungen wegen privilegierter
Anweisungen im L-Modus unterdrÅckt werden.

+------------+-------------------+------------------------------------+
| TAS900     | AS                | Bedeutung/Funktion                 |
+------------+-------------------+------------------------------------+
+------------+-------------------+------------------------------------+
| DL <Daten> | DD <Daten>        | Speicher in Langworten belegen     |
+------------+-------------------+------------------------------------+
| DSB <Zahl> | DB <Zahl> DUP (?) | Speicher byteweise reservieren     |
+------------+-------------------+------------------------------------+
| DSW <Zahl> | DW <Zahl> DUP (?) | Speicher wortweise reservieren     |
+------------+-------------------+------------------------------------+
| DSD <Zahl> | DD <Zahl> DUP (?) | Speicher langwortweise reservieren |
+------------+-------------------+------------------------------------+
| $MIN[IMUM] | MAXMODE OFF       | folgender Code im Minimum-Modus    |
+------------+-------------------+------------------------------------+
| $MAX[IMUM] | MAXMODE ON        | folgender Code im Maximum-Modus    |
+------------+-------------------+------------------------------------+
| $SYS[TEM]  | SUPMODE ON        | folgender Code im System-Modus     |
+------------+-------------------+------------------------------------+
| $NOR[MAL]  | SUPMODE OFF       | folgender Code im User-Modus       |
+------------+-------------------+------------------------------------+
| $NOLIST    | LISTING OFF       | Assemblerlisting ausschalten       |
+------------+-------------------+------------------------------------+
| $LIST      | LISTING ON        | Assemblerlisting einschalten       |
+------------+-------------------+------------------------------------+
| $EJECT     | NEWPAGE           | neue Seite im Listing beginnen     |
+------------+-------------------+------------------------------------+

Tabelle 4.2: Ñquivalente Befehle TAS900<->AS



        4.23. TLCS-90
        -------------

Vielleicht  fragt sich der eine oder  andere, ob bei mir die Reihenfol-
ge  durcheinandergekommen ist,  es gab  ja von  Toshiba zuerst den 90er
als  ,,aufgebohrten  Z80''  und  danach  den  900er als 16-Bit-Version.
Nun,  ich bin  einfach Åber  den 900er  zum 90er  gekommen (Danke, Oli-
ver!).  Die beiden Familien  sind sich sehr  artverwandt, nicht nur was
ihre  Syntax angeht,  sondern auch  ihre Architektur.  Die Hinweise fÅr
den  90er sind daher eine Untermenge  derer fÅr den 900er: Da Schieben,
Inkrementieren  und  Dekrementieren  hier  nur  um  eins  mîglich sind,
braucht  und  darf  diese  Eins  auch  nicht als erstes Argument hinge-
schrieben  werden. Bei  den Befehlen  LDA, JP  und CALL  mîchte Toshiba
wieder  die Klammern um Speicheroperanden  weglassen, bei AS mÅssen sie
aber  aus GrÅnden der OrthogonalitÑt  gesetzt werden (der tiefere Grund
ist  natÅrlich, da· ich mir damit  eine Sonderabfrage im Parser gespart
habe, aber das sagt man nicht so laut).

Die  TLCS-90er  besitzen  bereits  prinzipiell  einen  Adre·raum  von 1
Mbyte,  dieser Raum  erschlie·t sich  aber nur  bei Datenzugriffen Åber
die  Indexregister. AS  verzichtet daher  auf eine BerÅcksichtigung der
Bankregister  und begrenzt den Adre·raum fÅr  Code auf 64 Kbyte. Da der
Bereich  jenseits aber sowieso nur Åber indirekte Adressierung erreich-
bar ist, sollte dies keine allzu gro·e EinschrÑnkung darstellen.


        4.24. TLCS-870
        --------------

Schon  wieder  Toshiba...diese  Firma  ist  im Augenblick wirklich sehr
produktiv!  Speziell dieser  Spro· der  Familie (Toshibas Mikrokontrol-
ler  sind sich  ja alle  in BinÑrkodierung  und Programmiermodell recht
Ñhnlich)  scheint auf den 8051-Markt  abzuzielen: Die Methode, Bitstel-
len  durch einen Punkt getrennt  an den Adre·ausdruck anzuhÑngen, hatte
ja  beim 8051 ihren Ursprung,  fÅhrt jetzt aber auch  genau zu den Pro-
blemen,  die ich  beim 8051  geahnt hatte:  Der Punkt  ist jetzt einer-
seits  legales Zeichen in Symbolnamen,  andererseits aber auch Teil der
Adre·syntax,  d.h.  AS  mu·  Adresse  und Bitstelle trennen und einzeln
weiterverarbeiten.   Diesen  Interessenkonflikt  habe  ich  vorerst  so
gelîst,  da· der  Ausdruck von  hinten an  nach Punkten durchsucht wird
und  so der  letzte Punkt  als Trenner  gilt, eventuelle weitere Punkte
werden  dem Symbolnamen  zugerechnet. Es  gilt weiterhin die flehentli-
che  Bitte, im eigenen Interesse auf  Punkte in Symbolnamen zu verzich-
ten, sie fÅhren nur zu Verwirrungen:

        LD      CF,A.7  ; Akku Bit 7 nach Carry
        LD      C,A.7   ; Konstante A.7 nach Register C



        4.25. TLCS-47
        -------------

Mit  dieser 4-Bit-Prozessorfamilie  dÅrfte wohl  das unter  Ende dessen
erreicht  sein, was AS  unterstÅtzen kann. Neben  dem ASSUME-Befehl fÅr
das  Datenbankregister  (siehe  dort)  ist  eigentlich  nur  ein Detail
erwÑhnenswert:  im Daten-  und I/O-Segment  werden keine Bytes, sondern
Nibbles  reserviert (eben 4-Bitter...).  Die Sache funktioniert Ñhnlich
wie  das Bitdatensegment beim 8051,  wo ein DB ja  nur einzelne Bit re-
serviert, nur da· es hier eben Nibbles sind.

Toshiba  hat  fÅr  diese  Prozessorfamilie einen ,,erweiterten Befehls-
satz''  in Makroform definiert,  um das Arbeiten  mit diesem doch recht
beschrÑnkten  Befehlssatz zu erleichtern. Im Fall  von AS ist er in der
Datei  STDDEF47.INC definiert. Einige Befehle, deren makromÑ·ige Reali-
sierung  nicht mîglich  war, sind  allerdings ,,eingebaut''  und stehen
daher auch ohne die Include-Datei zur VerfÅgung:

  - der  B-Befehl, der  die jeweils  optimale Version des Sprungbefehls
    (BSS, BS oder BSL) automatisch wÑhlt;
  - LD in der Variante HL mit immediate;
  - ROLC und RORC mit einer Schiebeamplitude >1.



        4.26. TLCS-9000
        ---------------

Hier  ist es zum ersten Mal passiert, da· ich einen Prozessor in AS im-
plementiert  habe,  der  zu  diesem  Zeitpunkt  noch  gar nicht auf dem
Markt  war. Toshiba  hat sich  leider auch  vorlÑufig dazu entschieden,
diesen  Prozessor ,,auf Eis''  zu legen, bis  auf weiteres wird es also
auch  kein  Silizium  geben.  Das  hat  natÅrlich zur Folge, da· dieser
Teil

 1. ein  ,,Paper-Design'' ist, d.h. noch  nicht praktisch getestet wur-
    de und
 2. Die  Unterlagen, die ich zum 9000er hatte [109], noch vorlÑufig wa-
    ren, also noch nicht bis ins letzte Klarheit lieferten.

Fehler  in  diesem  Teil  sind  also  durchaus noch mîglich (und werden
natÅrlich  bereinigt,  wenn  es  denn  einmal gehen sollte!). Zumindest
die Handvoll Beispiele in [109] werden aber richtig Åbersetzt.


        4.27. 29xxx
        -----------

Wie  schon  beim  ASSUME-Befehl  beschrieben,  kann AS mit der Kenntnis
Åber  den Inhalt  des RBP-Registers  feststellen, ob  im User-Modus auf
gesperrte  Register zugegriffen  wird. Diese  FÑhigkeit beschrÑnkt sich
natÅrlich   auf  direkte  Zugriffe  (also   nicht,  wenn  die  Register
IPA...IPC  benutzt werden), und  sie hat noch  einen weiteren Haken: da
lokale  Register (also  solche mit  Nummern>127) relativ zum Stackpoin-
ter  adressiert werden,  die Bits  in RBP  sich aber immer auf absolute
Nummern  beziehen, wird  die PrÅfung  fÅr lokale  Register NICHT durch-
gefÅhrt.  Eine Erweiterung auf  lokale Register wÅrde  bedingen, da· AS
zu  jedem  Zeitpunkt  den  absoluten  Wert  von SP kennt, und das wÅrde
spÑtestens bei rekursiven Unterprogrammen scheitern...


        4.28. 80C16x
        ------------

Wie  in der ErklÑrung des  ASSUME-Befehls schon erlÑutert, versucht AS,
dem  Programmierer die Tatsache, da·  der Prozessor mehr physikalischen
als  logischen Speicher hat, soweit  als mîglich zu verbergen. Beachten
Sie  aber, da·  die DPP-Register  nur Datenzugriffe  betreffen und auch
dort  nur absolute  Adressierung, also  weder indirekte noch indizierte
Zugriffe,  da AS ja  nicht wissen kann,  wie die berechnete Adresse zur
Laufzeit   aussehen  wird...Bei  Codezugriffen   arbeitet  die  Paging-
Einheit  leider nicht,  man mu·  also explizit  mit langen  oder kurzen
CALLs,  JMPs oder RETs arbeiten. Zumindest bei den ,,universellen'' Be-
fehlen  CALL  und  JMP  wÑhlt  AS  automatisch  die kÅrzeste Form, aber
spÑtestens  beim RET sollte man wissen, woher der Aufruf kam. Prinzipi-
ell  verlangen JMPS  und CALLS  dabei, da·  man Segment und Adresse ge-
trennt  angibt, AS ist jedoch so  geschrieben, da· er eine Adresse sel-
ber zerlegen kann, z.B.

        jmps    12345h

anstelle von

        jmps    1,2345h

Leider  sind nicht alle  Effekte der chipinternen Instruktions-Pipeline
versteckt:  Werden CP (Registerbankadresse), SP  (Stack) oder eines der
Paging-Register  verÑndert, so steht  der neue Wert  noch nicht fÅr den
nÑchsten  Befehl zur VerfÅgung. AS  versucht, solche Situationen zu er-
kennen  und gibt im Falle eines Falles eine Warnung aus. Aber auch die-
se Mimik greift nur bei direkten Zugriffen.

Mit  BIT definierte Bits  werden intern in  einem 13-Bit-Wort abgelegt,
wobei  die Bitadresse in Bit 4..11 liegt und die Bitnummer in den unte-
ren  vier  Bits.  Diese  Anordnung  erlaubt  es,  das nÑchsthîhere bzw.
nÑchstniedrigere  Bit  durch  Inkrementieren  bzw. Dekrementieren anzu-
sprechen.  Bei expliziten  Bitangaben mit  Punkt funktioniert  das aber
nicht  Åber Wortgrenzen hinaus. So erzeugt folgender Ausdruck eine Wer-
tebereichsÅberschreitung:

        bclr    r5.15+1

Hier mu· ein BIT her:

msb     bit     r5.15
        .
        .
        .
        bclr    msb+1

FÅr  den 80C167/165/163 ist der  SFR-Bereich verdoppelt worden; da· ein
Bit  im zweiten Teil  liegt, wird durch  ein gesetztes Bit 12 vermerkt.
Leider  hatte Siemens bei  der Definition des  80C166 nicht vorausgese-
hen,  da·  256  SFRs  (davon  128  bitadressierbar)  fÅr Nachfolgechips
nicht  reichen wÅrden.  So wÑre  es unmîglich,  den zweiten SFR-Bereich
von  F000H..F1DFH mit  kurzen Adressen  oder Bitbefehlen  zu erreichen,
hÑtten die Entwickler nicht einen Umschaltbefehl eingebaut:

        EXTR    #n

Dieser  Befehl bewirkt, da· fÅr die  nÑchsten n Befehle (0<n<5) anstel-
le  des normalen  der erweiterte  SFR-Bereich angesprochen werden kann.
AS  erzeugt  bei  diesm  Befehl  nicht  nur den passenden Code, sondern
setzt  intern ein  Flag, da·  fÅr die  nÑchsten n  Befehle nur Zugriffe
auf  den  erweiterten  SFR-Bereich  zulÑ·t.  Da  dÅrfen natÅrlich keine
SprÅnge  dabei sein... Bits aus  beiden Bereichen lassen sich natÅrlich
jederzeit  definieren, ebenso  sind komplette  Register aus beiden SFR-
Bereichen  jederzeit  mit  absoluter  Adressierung  erreichbar. Nur die
kurze  bzw. Bitadressierung geht immer nur abwechselnd, Zuwiderhandlun-
gen werden mit einer Fehlermeldung geahndet.

éhnlich  sieht es mit  den PrÑfixen fÅr  absolute bzw. indirekte Adres-
sierung  aus: Da  aber sowohl  Argument des  PrÑfixes als  auch der Ad-
re·ausdruck  nicht  immer  zur  öbersetzungszeit  bestimmbar sind, sind
die  PrÅfungsmîglichkeiten durch  AS sehr  eingeschrÑnkt, weshalb er es
auch  bei  Warnungen  belÑ·t...im  einzelnen  sieht  das folgenderma·en
aus:

  - feste  Vorgabe  einer  64K-Bank  mittels  EXTS  oder  EXTSR: Im Ad-
    re·ausdruck  werden direkt die unteren  16 Bit der Zieladresse ein-
    gesetzt.  Haben sowohl PrÑfix als auch Befehl einen konstanten Ope-
    randen,  so wird  ÅberprÅft, ob  PrÑfixargument und  Bit 16..23 der
    Zieladresse identisch sind.
  - feste  Vorgabe  einer  16K-Seite  mittels  EXTP  oder EXTPR: Im Ad-
    re·ausdruck  werden direkt die unteren  14 Bit der Zieladresse ein-
    gesetzt.  Bit 14 und 15 bleiben konstant  0, da sie in diesem Modus
    nicht  vom Prozessor  ausgewertet werden.  Haben sowohl  PrÑfix als
    auch  Befehl  einen  konstanten  Operanden,  so  wird ÅberprÅft, ob
    PrÑfixargument und Bit 14..23 der Zieladresse identisch sind.

Damit  das etwas klarer wird, ein  Beispiel (die DPP-Register haben die
Reset-Vorbelegung) :

       extp     #7,#1           ; Bereich von 112K..128K
       mov      r0,1cdefh       ; ergibt Adresse 0defh im Code
       mov      r0,1cdefh       ; -->Warnung
       exts     #1,#1           ; Bereich von 64K..128K
       mov      r0,1cdefh       ; ergibt Adresse 0cdefh im Code
       mov      r0,1cdefh       ; -->Warnung



        4.29. PIC16C5x/16C8x
        --------------------

éhnlich  wie die  MCS-48-Familie teilen  auch die  PICs ihren Programm-
speicher  in mehrere BÑnke  auf, da im  Opcode nicht genÅgend Platz fÅr
die  vollstÑndige Adresse  war. AS  verwendet fÅr  die Befehle CALL und
GOTO  die gleiche Automatik, d.h. setzt  die PA-Bits im Statuswort ent-
sprechend  Start- und Zieladresse.  Im Gegensatz zu  den 48ern ist die-
ses Verfahren hier aber noch deutlich problematischer:

  1 Die  Befehle sind nicht mehr nur ein Wort, sondern bis zu drei Wor-
    ten  lang, kînnen also  nicht mehr in  jedem Fall mit einem beding-
    ten Sprung Åbergangen werden.
  2 Es  ist mîglich, da· der ProgrammzÑhler beim normalen Programmfort-
    gang  eine Seitengrenze Åberschreitet. Die vom Assembler angenomme-
    ne  Belegung der  PA-Bits stimmt  dann nicht  mehr mit der RealitÑt
    Åberein.

Bei  den Befehlen, die  das Register W  mit einem anderen Register ver-
knÅpfen,  mu· normalerweise als zweiter  Parameter angegeben werden, ob
das  Ergebnis in  W oder  im Register  abgelegt werden soll. Bei diesem
Assembler  ist es  erlaubt, den  zweiten Parameter wegzulassen. Welches
Ziel  dann angenommen  werden soll,  hÑngt vom  Typ des Befehls ab: bei
unÑren  Operationen wird defaultmÑ·ig das  Ergebnis zurÅck ins Register
gelegt. Diese Befehle sind:

    COMF, DECF, DECFSZ, INCF, INCFSZ, RLF, RRF und SWAPF

Die  anderen Befehle betrachten W  defaultmÑ·ig als Akkumulator, zu dem
ein Register verknÅpft wird:

    ADDWF, ANDWF, IORWF, MOVF, SUBWF und XORWF


Die  von Microchip  vorgegebene Schreibweise  fÅr Literale ist ziemlich
abstrus  und erinnert an die  auf IBM 360/370-Systemen Åbliche Schreib-
weise  (GrÅ·e aus Neandertal...). Um nicht noch einen Zweig in den Par-
ser  einfÅgen zu mÅssen,  sind bei AS  Konstanten in Motorola-Syntax zu
schreiben (wahlweise auch Intel oder C im RELAXED-Modus).

Dem  Assembler  liegt  die  Include-Datei  STDDEF16.INC bei, in der die
Adressen  der Hardware-Register  und Statusbits  verewigt sind. Daneben
enthÑlt  sie eine  Liste von  ,,Befehlen'', die der Microchip-Assembler
als  Makro implementiert.  Bei der  Benutzung dieser  Befehlsmakros ist
gro·e  Vorsicht angebracht, da sie mehrere Worte lang sind und sich so-
mit nicht Åberspringen lassen!!


        4.30. PIC17C4x
        --------------

FÅr  diese  Prozessoren  gelten  im  wesentlichen die gleichen Hinweise
wie  fÅr ihre kleinen BrÅder, mit zwei Ausnahmen: Die zugehîrige Inclu-
de-Datei   enthÑlt  nur  Registerdefinitionen,  und  die  Probleme  bei
Sprungbefehlen  sind deutlich kleiner.  Aus der Reihe  fÑllt nur LCALL,
der  einen 16-Bit-Sprung  erlaubt. Dieser  wird mit folgendem ,,Makro''
Åbersetzt:

        MOVLW   <Adr15..8>
        MOWF    3
        LCALL   <Adr0..7>



        4.31. ST6
        ---------

Diese  Prozessoren kînnen das Code-ROM  seitenweise in den Datenbereich
einblenden.  Weil ich  nicht die  ganze Mimik  des ASSUME-Befehles hier
wiederkÑuen   mîchte,  verweise  ich   auf  das  entsprechende  Kapitel
(3.2.15),  in dem steht, wie man mit diesem Befehl einigerma·en unfall-
frei Konstanten aus dem ROM lesen kann.

Bei  nÑhererer Betrachtung  des Befehlssatzes  fallen einige eingebaute
,,Makros''  auf. Die  Befehle, die  mir aufgefallen  sind (es gibt aber
vielleicht noch mehr...), sind in Tabelle 4.3 aufgelistet.


                    +---------+-----------------+
                    | Befehl  | in Wirklichkeit |
                    +---------+-----------------+
                    +---------+-----------------+
                    | CLR A   | SUB A,A         |
                    | SLA A   | ADD A,A         |
                    | CLR adr | LDI adr,0       |
                    | NOP     | JRZ PC+1        |
                    +---------+-----------------+

Tabelle 4.3: versteckte Makros im ST6225-Befehlssatz

Insbesondere  der letztere  Fall verblÅfft  doch etwas... Leider fehlen
aber  einige  Anweisungen  wirklich.  So  gibt  es z.B. zwar einen AND-
Befehl,  aber kein OR...von XOR  gar nicht zu reden.  In der Datei STD-
DEF62.INC  finden sich deshalb neben den  Adressen der SFRs noch einige
Makros zur Abhilfe.

Der  Original-Assembler AST6 von  SGS-Thomson verwendet teilweise ande-
re  Pseudobefehle  als  AS.  Au·er  der  Tatsache, da· AS Pseudobefehle
nicht  mit einem vorangestellten Punkt  kennzeichnet, sind folgende Be-
fehle identisch:

  ASCII, ASCIZ, BLOCK, BYTE, END, ENDM, EQU, ERROR, MACRO,
  ORG, TITLE, WARNING

Tabelle  4.4 zeigt  die AST6-Befehle,  zu denen  analoge in AS existie-
ren.


      +----------+------------------+--------------------------+
      | AST6     | AS               | Bedeutung/Funktion       |
      +----------+------------------+--------------------------+
      +----------+------------------+--------------------------+
      | .DISPLAY | MESSAGE          | Meldung ausgeben         |
      +----------+------------------+--------------------------+
      | .EJECT   | NEWPAGE          | neue Seite im Listing    |
      +----------+------------------+--------------------------+
      | .ELSE    | ELSEIF           | bed. Assemblierung       |
      +----------+------------------+--------------------------+
      | .ENDC    | ENDIF            | bed. Assemblierung       |
      +----------+------------------+--------------------------+
      | .IFC     | IF...            | bed. Assemblierung       |
      +----------+------------------+--------------------------+
      | .INPUT   | INCLUDE          | Include-Datei einbinden  |
      +----------+------------------+--------------------------+
      | .LIST    | LISTING, MACEXP  | Listing-Einstellung      |
      +----------+------------------+--------------------------+
      | .PL      | PAGE             | SeitenlÑnge Listing      |
      +----------+------------------+--------------------------+
      | .ROMSIZE | CPU              | Zielprozessor einstellen |
      +----------+------------------+--------------------------+
      | .VERS    | VERSION (Symbol) | Version abfragen         |
      +----------+------------------+--------------------------+
      | .SET     | EVAL             | Variablen neu setzen     |
      +----------+------------------+--------------------------+

Tabelle 4.4: Ñquivalente Befehle AST6<->AS



        4.32. ST7
        ---------

In  [81] ist der '.w'-Postfix fÅr 16-Bit-Adressen nur fÅr speicherindi-
rekte  Operanden definiert,  um zu  vermerken, da·  auf einer Zeropage-
adresse  eine  16-bittige  Adresse  liegt;  AS  unterstÅtzt  ihn jedoch
zusÑtzlich  auch fÅr absolute Adressen  oder Displacements in indizier-
ter  Adressierung, um trotz eines nur  8 Bit langen Wertes (0..255) ein
16-bittiges Displacement zu erzeugen.


        4.33. ST9
        ---------

Die  Bitadressierungsmîglichkeiten des ST9  sind relativ eingeschrÑnkt:
Mit  Ausnahme des BTSET-Befehls ist es  nur mîglich, auf Bits innerhalb
des   aktuellen  Arbeitsregistersatzes  zuzugreifen.  Eine  Bit-Adresse
sieht also folgenderma·en aus:

  rn.[!]b

wobei  !  eine  optionale  Invertierung  eines Quelloperanden bedeutet.
Wird  ein Bit  symbolisch mittels  des BIT-Befehles  definiert, so wird
die  Registernummer im  Symbolwert in  Bit 7..4,  die Bitnummer  in Bit
3..1  und eine optionale Invertierung in Bit 0 vermerkt. AS unterschei-
det  direkte und  symbolische Bitangaben  am Fehlen  eines Punktes, der
Name  eines Bitsymboles  darf also  keinen Punkt  enthalten, obwohl sie
an  sich zulÑssig wÑren.  Es ist auch  zulÑssig, bei der Referenzierung
von Bitsymbolen diese zu nachtrÑglich zu invertieren:

bit2    bit     r5.3
        .
        .
        bld	r0.0,!bit2

Auf   diese  Weise  ist  es   auch  mîglich,  eine  inverse  Definition
nachtrÑglich wieder aufzuheben.

Bitdefinitionen  finden  sich  in  gro·er  Zahl  in  der  Include-Datei
REGST9.INC,   in  der   die  Register-   und  Bitnamen  aller  On-Chip-
Peripherie  beschrieben sind.  Beachten Sie  jedoch, da·  deren Nutzung
nur  mîglich ist,  wenn die  Arbeitsregisterbank vorher  auch auf diese
Register ausgerichtet wurde!

Im  Gegensatz zu der zum AST9 von SGS-Thomson gehîrenden Definitionsda-
tei  sind fÅr  AS die  Namen der  Peripherieregister nur als allgemeine
Registernamen  definiert  (R...),  nicht  auch noch als Arbeitsregister
(r...).  Dies ist so, weil  AS GeschwindigkeitsgrÅnden keine Aliasnamen
fÅr Register definieren kann.


        4.34. 6804
        ----------

Eigentlich  habe ich  diesen Prozessor  ja nur  eingebaut, um mich Åber
das  seltsame Gebaren  von SGS-Thomson  zu beklagen:  Als ich das 6804-
Datenbuch  zum ersten Mal in die Hand bekam, fÅhlte ich mich ob des et-
was  ,,unvollstÑndigen'' Befehlssatzes und der eingebauten Makros spon-
tan  an die ST62-Serie vom  gleichen Hersteller erinnert. Ein genauerer
Vergleich  der Opcodes fîrderte erstaunliches  zu Tage: Ein 6804-Opcode
ergibt  sich  durch  Spiegelung  aller  Bits  im  entsprechenden  ST62-
OpCode!  Thomson  hat  hier  also  offensichtlich  etwas Prozessorkern-
Recycling  betrieben...wogegen  ja  auch  nichts einzuwenden wÑre, wenn
nicht  so eine Verschleierungstaktik betrieben werden wÅrde: andere Pe-
ripherie,  Motorola- anstelle  Zilog-Syntax sowie  das hÑ·liche Detail,
in  Opcodes  enthaltene  Argumente  (z.B.  Bitfelder mit Displacements)
nicht   zu  drehen.  Letzterer  Punkt   hat  mich  auch  nach  lÑngerem
öberlegen  dazu  bewogen,  den  6804  doch  in AS aufzunehmen. Ich wage
Åbrigens  keine Spekulationen,  welche Abteilung  bei Thomson  von wel-
cher abgekupfert hat...

Im  Gegensatz zur ST62-Version  enthÑlt die Include-Datei  fÅr den 6804
keine  Makros, die die LÅcken im Befehlssatz etwas ,,auspolstern'' sol-
len. Dies Åberlasse ich dem geneigten Leser als FingerÅbung!


        4.35. TMS3201x
        --------------

Offensichtlich  ist es Ehrgeiz  jedes Prozessorherstellers, seine eige-
ne  Notation fÅr  Hexadezimalkonstanten zu  erfinden. Texas Instruments
war  bei diesen Prozessoren besonders originell: ein vorangestelltes >-
Zeichen!  Die öbernahme  dieses Formates  in AS  hÑtte zu schweren Kon-
flikten  mit den Vergleichs-und Schiebeoperatoren  von AS im Formelpar-
ser  gefÅhrt. Ich  habe mich  deshalb fÅr  die Intel-Notation entschie-
den,  zu der sich  TI bei der  340x0-Serie und den 3201x-Nachfolgern ja
dann auch durchgerungen hat...

Leider  hat  das  Instruktionswort  dieser  Prozessoren  nicht genÅgend
Bits,  um bei direkter  Adressierung alle 8  Bits zu enthalten, weshalb
der  Datenadre·raum logisch  in 2  BÑnke zu  128 Wîrtern gespalten ist.
AS  verwaltet diesen als ein durchgehendes  Segment von 256 Wîrtern und
lîscht  bei direkten Zugriffen automatisch  das Bit 7 (Ausnahme: Befehl
SST,  der nur in die obere  Bank schreiben kann). Der Programmierer ist
dafÅr erforderlich, da· das Bank-Bit stets den richtigen Wert hat!

Ein  weiterer, nur sehr  versteckt im Datenbuch  stehender Hinweis: Die
SUBC-Anweisung  benîtigt  zur  AusfÅhrung  intern  mehr als einen Takt,
das  Steuerwerk arbeitet  jedoch schon  an dem  nÑchsten Befehl weiter.
Im  auf ein SUBC folgenden Befehl  darf deshalb nicht auf den Akkumula-
tor zugegriffen werden. AS nimmt hier keine PrÅfung vor!


        4.36. TMS320C2x
        ---------------

Da  ich nicht selber diesen  Codegenerator geschrieben habe (was nichts
an  seiner QualitÑt  mindert), kann  ich nur  kurz hier umrei·en, wieso
es  Befehle gibt, bei denen  ein vorangestelltes Label als untypisiert,
d.h.  keinem Adre·raum zugeordnet, gespeichert  wird: Der 20er der TMS-
Reihe  kennt sowohl  ein 64  Kbyte gro·es  Code- als auch Datensegment.
Je  nach externer  Beschaltung kann  man dabei  Code- und Datenbereiche
Åberlappen,  um  z.B.  Konstanten  im  Codebereich zu abzulegen und auf
diese  als  Daten  zuzugreifen  (Ablage  im  Code  ist  notwendig, weil
Ñltere  AS-Versionen davon ausgehen,  da· ein Datensegment  aus RAM be-
steht,  das in einem Standalone-System  nach dem Einschalten keinen de-
finierten  Inhalt hat  und verweigern  in Segmenten  au·er Code deshalb
die  Ablage von Daten). Ohne dieses  Feature wÅrde AS nun jeden Zugriff
auf  die abgelegten Daten mit einer Warnung (,,Symbol aus falschem Seg-
ment'')  quittieren. Im einzelnen erzeugen folgende Pseudobefehle unty-
pisierte Labels:

    BSS, STRING, RSTRING, BYTE, WORD , LONG, FLOAT
    DOUBLE, EFLOAT, BFLOAT und TFLOAT

Sollten  doch  einmal  typisierte  Labels  gewÅnscht  sein, so kann man
sich  behelfen, indem  man das  Label in  eine getrennte  Zeile vor dem
Pseudobefehl  schreibt. Umgekehrt kann man  einen der anderen Pseudobe-
fehle  mit einem  typenlosen Label  versehen, indem  man vor dem Befehl
das Label mit

<Name>  EQU     $

definiert.


        4.37. TMS320C3x
        ---------------

Die  grî·ten  Magenschmerzen  bei  diesem  Prozessor hat mir die Syntax
paralleler  Befehle bereitet, die auf  zwei Zeilen verteilt werden, wo-
bei  beide Befehle an  sich auch sequentiell  ausgefÅhrt werden kînnen.
Deshalb  erzeugt AS zuerst  den Code fÅr  die einzelne erste Operation,
wenn  er dann  in der  zweiten Zeile  erkennt, da· eine parallele Awei-
sung  vorliegt, wird der zuerst erzeugte  Code durch den neuen ersetzt.
Im  Listing kann man dies daran  erkennen, da· der ProgrammzÑhler nicht
weiterlÑuft  und in der zweiten  Zeile anstelle eines Doppelpunktes ein
R vor dem erzeugten Code steht.

BezÅglich  der doppelten senkrechten Striche  und ihrer Position in der
Zeile  ist man nicht  ganz so flexibel  wie beim TI-Assembler: Entweder
man  schreibt  sie  anstelle  eines  Labels  (d.h. in der ersten Spalte
oder  mit einem  angehÑngten Doppelpunkt,  das ist  aber nicht mehr TI-
kompatibel...)  oder direkt  vor den  zweiten Befehl  ohne Leerzeichen,
sonst  bekommt der  Zeilenparser von  AS Probleme  und hÑlt die Striche
fÅr das Mnemonic.


        4.38. TMS9900
        -------------

Wie  bei den meisten  Ñlteren Prozessorfamilien auch,  hatte TI seiner-
zeit   ein  eigenes  Format  zur   Schreibweise  von  Hexadezimal-  und
BinÑrkonstanten  verwendet, anstelle  deren AS  die normale, heute auch
bei TI gebrÑuchliche Intel-Notation verwendet.

Die  TI-Syntax fÅr Register  erlaubt es, da·  anstelle eines echten Na-
mens  (entweder Rx oder  WRx) auch eine  einfache Integer-Zahl zwischen
0 und 15 benutzt werden kann. Dies hat zwei Folgen:

  - R0...R15  bzw. WR0..WR15 sind einfache, vordefinierte Integersymbo-
    le  mit den  Werten 0..15,  und die  Definition von Registeraliasen
    funktioniert Åber schlichte EQUs.
  - Im  Gegensatz  zu  einigen  anderen  Prozessoren kann ich nicht das
    zusÑtzliche  AS-Feature anbieten, da·  das Kennzeichen fÅr absolute
    Adressierung  (hier  ein  Klammeraffe)  weggelassen werden darf. Da
    ein  fehlendes Kennzeichen hier aber  Registernummern (im Bereich 0
    bis 15) bedeuten wÅrde, war das hier nicht mîglich.

Weiterhin  wechselt  TI  mit  der  Registerbezeichnung  zwischen Rx und
WRx...vorerst ist beides zugelassen.


        4.39. TMS70Cxx
        --------------

Diese  Prozessorreihe gehîrt noch  zu den Ñlteren,  von TI entwickelten
Reihen,  und deswegen benutzt  TI in ihren  eigenen Assemblern noch die
herstellereigene   Syntax  fÅr   hexadezimale  und   binÑre  Konstanten
(vorangestelltes  < bzw. ?).  Da das in  AS aber so  nicht machbar ist,
wird  defaultmÑ·ig die Intel-Syntax verwendet.  Auf diese ist Texas bei
den  Nachfolgern dieser  Familie, nÑmlich  den 370ern auch umgestiegen.
Beim  genaueren Betrachten des  Maschinenbefehlssatzes stellt man fest,
da·  ca.  80%  der  7000er-Befehle  binÑr  aufwÑrtskompatibel sind, und
auch  die Assemblersyntax  ist fast  gleich -  aber eben  nur fast. Bei
der  Erweiterung des  7000er-Befehlssatzes hat  TI nÑmlich  auch gleich
die  Chance genutzt, die  Syntax etwas zu  vereinheitlichen und zu ver-
einfachen.  Ich habe mich bemÅht, einen  Teil dieser Ñnderungen auch in
die 7000er Syntax einflie·en zu lassen:

  - Anstelle  eines Prozentzeichens  zur Kennzeichnung  von unmittelba-
    rer  Adressierung  darf  auch  das allgemein bekanntere Doppelkreuz
    verwendet werden.
  - Wenn  bei den Befehlen AND, BTJO, BTJZ,  MOV, OR und XOR eine Port-
    Adresse  (P...) als  Quelle oder  Ziel benutzt  wird, ist  es nicht
    notwendig,  die Mnemonic-Form mit explizit  angehÑngtem P zu benut-
    zen - die allgemeine Form reicht genauso aus.
  - Der   vorangestelle  Klammeraffe  fÅr  absolute  oder  B-indizierte
    Adressierung darf weggelassen werden.
  - Anstelle  des CMPA-Befehls darf auch einfach CMP mit A als Ziel be-
    nutzt werden.
  - Anstelle  LDA oder STA  darf auch einfach  der MOV-Befehl mit A als
    Ziel bzw. Quelle benutzt werden.
  - Anstelle des MOVD-Befehls darf auch MOVW benutzt werden.
  - Anstelle  von RETS  oder RETI  darf auch  verkÅrzt RTS bzw. RTI ge-
    schrieben werden.
  - TSTA  bzw. TSTB  dÅrfen auch  als TST  A bzw.TST B geschrieben wer-
    den.
  - XCHB B ist als Alias fÅr TSTB zugelassen.

Wichtig  - diese Varianten sind nur beim TMS70Cxx zugelassen - entspre-
chende 7000er-Varianten sind bei den 370ern nicht erlaubt!


        4.40. TMS370xxx
        ---------------

Obwohl  diese Prozessoren keine  speziellen Befehle zur Bitmanipulation
besitzen,  wird mit Hilfe  des Assemblers und  des DBIT-Befehles (siehe
dort)  die  Illusion  erzeugt,  als  ob  man einzelne Bits manipulieren
wÅrde.  Dazu wird beim  DBIT-Befehl eine Adresse  mit einer Bitposition
zusammengefa·t  und in  einem Symbol  abgelegt, das  man dann als Argu-
ment  fÅr die Pseudobefehle SBIT0, SBIT1,  CMPBIT, JBIT0 und JBIT1 ver-
wenden  kann. Diese werden in  die Befehle OR, AND,  XOR, BTJZ und BTJO
mit einer passenden Bitmaske Åbersetzt.

An  diesen Bit-Symbolen  ist Åberhaupt  nichts geheimnisvolles, es han-
delt  sich um schlichte Integerwerte, in deren unterer HÑlfte die Spei-
cheradresse  und  in  deren  oberer  HÑlfte  die  Bitstelle gespeichert
wird.  Man kînnte sich seine Symbole also auch ohne weiteres selber ba-
steln:

defbit  macro   name,bit,adr
name    equ     adr+(bit<<16)
        endm

aber  mit dieser Schreibweise erreicht  man nicht den EQU-artigen Stil,
den  Texas vorgegeben  hat (d.h.  das zu  definierende Symbol steht an-
stelle  eines  Labels).  ACHTUNG!  Obwohl  DBIT  eine beliebige Adresse
zulÑ·t,  kînnen  fÅr  die  Pseudobefehle  nur  die  Adressen 0..255 und
1000h..10ffh  verwendet  werden,  eine  absolute Adressierungsart kennt
der Prozessor an dieser Stelle nicht...


        4.41. MSP430
        ------------

Der  MSP430 wurde als RISC-Prozessor  mit minimalem Stromverbrauch kon-
zipiert.  Aus diesem Grund  ist der Satz  von Befehlen, die der Prozes-
sor  in Hardware versteht, auf  das absolut notwendige reduziert worden
(da  RISC-Prozessoren keinen  Mikrocode besitzen,  mu· jeder Befehl mit
zusÑtzlichem  Silizium implementiert werden und erhîht so den Stromver-
brauch).  Eine Reihe von Befehlen, die bei anderen Prozessoren in Hard-
ware  gegossen wurden, werden  beim MSP durch  eine Emulation mit ande-
ren  Befehlen realisiert. Bei  AS finden sich  diese Befehle mit in der
Datei  REGMSP.INC. Wer diese  Datei nicht einbindet,  wird bei Åber der
HÑlfte  der insgesamt von TI definierten Befehle Fehlermeldungen bekom-
men!!


        4.42. COP8 & SC/MP
        ------------------

Leider  Gottes hat sich auch National dazu entschieden, als Schreibwei-
se  fÅr nichtdezimale  Integer-Konstanten die  von IBM-Gro·rechnern be-
kannte  (und  von  mir  vielgeha·te)  Variante   X'... zu benutzen. Das
geht  natÅrlich (wie  immer) nicht.  Zum GlÅck  scheint der ASMCOP aber
auch  die C-Variante  zuzulassen, und  diese wurde  deshalb der Default
fÅr die COPs...


        4.43. SC144xxx
        --------------

Original  gab es fÅr diese Reihe  von DECT-Controllern mit relativ ein-
fachem  Befehlssatz nur  einen sehr  schlichten Assembler  von National
selber.  Ein  Assembler  von  IAR  Systems  ist  angekÅndigt, aber noch
nicht  erhÑltlich.  Da  die  Entwicklungstools  von IAR allerdings auch
nach   Mîglichkeit  CPU-unabhÑngig  angelegt   sind,  kann  man  anhand
erhÑltlicher  Zielplattformen in ungefÑhr abschÑtzen, wie dessen Pseud-
obefehle  aussehen  werden,  und  damit  im  Blick  sind  die (wenigen)
SC144xx-spezifisch  realisierten Befehle DC, DC8,  DW16, DS, DS8, DS16,
DW  angelegt. Bei Befehlen, die bereits im AS-Kern angelegt sind, woll-
te  ich natÅrlich nicht das Rad  neu erfinden, deshalb hier eine Tabel-
le mit équivalenzen:

Die  Befehle ALIGN, END,  ENDM, EXITM, MACRO,  ORG, RADIX, SET und REPT
exisieren  sowohl bei IAR als auch  AS und haben gleiche Bedeutung. Bei
folgenden Befehlen mu· man umstellen:


+---------------------+------------------+---------------------------------+
| IAR                 | AS               | Funktion                        |
+---------------------+------------------+---------------------------------+
+---------------------+------------------+---------------------------------+
| #include            | include          | Include-Datei einbinden         |
| #define             | SET, EQU         | Symbole definieren              |
| #elif, ELIF, ELSEIF | ELSEIF           | Weiterer Zweig einer IF-Kette   |
| #else, ELSE         | ELSE             | Letzter Zweig einer IF-Kette    |
| #endif, ENDIF       | ENDIF            | Beendet eine IF-Kette           |
| #error              | ERROR, FATAL     | Fehlermeldung erzeugen          |
| #if, IF             | IF               | Beginn einer IF-Kette           |
| #ifdef              | IFDEF            | Symbol definiert ?              |
| #ifndef             | IFNDEF           | Symbol nicht definiert ?        |
| #message            | MESSAGE          | Nachricht ausgeben              |
| =, DEFINE, EQU      | =, EQU           | Feste Wertzuweisung             |
| EVEN                | ALIGN 2          | ProgrammzÑhler gerade machen    |
| COL, PAGSIZ         | PAGE             | Seitengrî·e fÅr Listing setzen  |
| ENDR                | ENDM             | Ende einer REPT-Struktur        |
| LSTCND, LSTOUT      | LISTING          | Umfang des Listings steuern     |
| LSTEXP, LSTREP      | MACEXP           | Expandierte Makros anzeigen?    |
| LSTXRF              |  <Kommandozeile> | Querverweisliste erzeugen       |
| PAGE                | NEWPAGE          | Neue Seite im Listing           |
| REPTC               | IRPC             | Repetition mit Zeichenersetzung |
+---------------------+------------------+---------------------------------+


Keine  direkte Entsprechung  gibt es  fÅr die  Befehle CASEON, CASEOFF,
LOCAL, LSTPAG, #undef und REPTI.

Ein  direktes  équivalent  der  PrÑprozessorbefehle ist natÅrlich nicht
mîglich,  solange  AS  keinen  C-artigen PrÑprozessor besitzt. C-artige
Kommentare  sind im Moment leider auch nicht mîglich. Achtung: Wer IAR-
Codes  fÅr AS umsetzt, mu·  die PrÑprozessorstatements nicht nur umwan-
deln,  sondern auch aus Spalte  1 herausbewegen, da bei  AS in Spalte 1
nur Labels stehen dÅrfen!


        4.44. 75K0
        ----------

Wie  bei einigen  anderen Prozessoren  auch, kennt die Assemblersprache
der  75er von NEC Pseudo-Bitoperanden, d.h.  man kann einem Symbol eine
Kombination  aus Adresse und Bitnummer zuweisen, die dann bei bitorien-
tierten  Befehlen  anstelle  direkter  AusdrÅcke verwendet werden kann.
Die drei folgenden Befehle erzeugen daher z.B. identischen Code:

ADM     sfr     0fd8h
SOC     bit     ADM.3

        skt     0fd8h.3
        skt     ADM.3
        skt     SOC

AS  unterscheidet direkte und symbolische Bitzugriffe an einem bei Sym-
bolen  fehlenden Punkt; Punkte in Symbolnamen darf man daher nicht ver-
wenden, da es sonst zu Mi·verstÑndnissen bei der Auflîsung kommt.

Die  Ablage  von  Bitsymbolen  orientiert  sich dabei weitgehend an der
binÑren  Kodierung, die die Prozessorhardware selber verwendet: Es wer-
den   16  Bit  belegt,  und  es   existieren  ein  ,,kurzes''  und  ein
,,langes''  Format. Das  kurze Format  kann folgende  Varianten aufneh-
men:

  - direkte Zugriffe auf die Bereiche 0FBxH und 0FFxH
  - indirekte Zugriffe der Form Adr.@L (0FC0H <= Adr <= 0FFFH)
  - indirekte Zugriffe der Form @H+d4.bit

Das  obere Byte ist  auf 0 gesetzt,  das untere Byte  enthÑlt den gemÑ·
[73]  kodierten Bitausdruck. Das  lange Format kennt  im Gegensatz dazu
nur  direkte Adressierung, kann dafÅr  aber (korrekte Einstellungen von
MBS  und MBE vorausgesetzt)  den ganzen Adre·raum  abdecken. Bei langen
AusdrÅcken  stehen im unteren Byte  Bit 7..0 der Adresse,  in Bit 8 und
9  die  Bitstelle  sowie  in  Bit  10  und  11  konstant  01.  Letztere
ermîglichen  es,  langes  und  kurzes  Format  einfach durch einen Ver-
gleich  des oberen Bytes  gegen Null zu  unterscheiden. Die Bits 12..15
enthalten  Bit 8..11  der Adresse;  sie werden  zwar nicht zur Generie-
rung  des  Kodes  benîtigt,  mÅssen  jedoch gespeichert werden, da eine
PrÅfung  auf ein korrektes  Banking erst bei  der Verwendung des Symbo-
les erfolgen kann.


        4.45. 78K0
        ----------

NEC  benutzt in seinen DatenbÅchern  zur Kennzeichnung der Zugriffswei-
se auf absolute Adressen verschiedene Schreibweisen:

  - absolut kurz: kein PrÑfix
  - absolut lang: vorangestelltes !
  - PC-relativ: vorangestelltes $

Bei  AS  sind  diese  PrÑfixe  nur  notwendig, falls man eine bestimmte
Adressierung  erzwingen  will  und  der  Befehl  verschiedene Varianten
zulÑ·t.  Setzt man keinen PrÑfix, so  wÑhlt AS automatisch die kÅrzeste
Variante.  Es dÅrfte  daher in  der Praxis  sehr selten notwendig sein,
einen PrÑfix zu verwenden.


        4.46. 78K2
        ----------

Analog  wie beim 78K0 benutzt NEC auch hier wieder Dollar- und Ausrufe-
zeichen  fÅr verschiedene LÑngen  von Adre·sausdrÅcken. Zwischen langen
und  kurzen Adressen (sowohl im RAM-  als auch SFR-Bereich) wird wieder
automatisch  entschieden,  nur  relative  Adressierung  mu· man manuell
anwÑhlen, wenn ein Befehl beides unterstÅtzt (z.B. BR).

Noch  eine Anmerkung (die im Åbrigens auch fÅr den 78K0 gilt): Wer mit-
tels  RELAXED mit  Motorola-Syntax arbeitet,  mu· Hexadezimalkonstanten
klammern,  weil das fÅhrende Dollarzeichen  u.U. als relative Adressie-
rung mi·verstanden wird...


        4.47. uPD772x
        -------------

Sowohl  7720 als auch 7725 werden von dem gleichen Codegenerator behan-
delt  und sind sich in ihren Befehlssatz extrem Ñhnlich. Trotzdem soll-
te  man sich  nicht zu  der Annahme  verleiten lassen,  sie seien binÑr
kompatibel:  Um die  lÑngeren Adre·felder  und zusÑtzlichen Befehle un-
terbringen  zu kînnen, haben  sich die Bitpositionen  einiger Felder im
Instruktionswort  verschoben, die InstruktionslÑnge  hat sich auch ins-
gesamt  von 23  auf 24  Bit geÑndert.  Im Code-Format sind deshalb auch
unterschiedliche Header-Ids fÅr beide reserviert.

Gemeinsam  ist beiden, da·  sie neben Code-  und Datensegment auch noch
ein  ROM zur Ablage von Konstanten besitzen.  Dieses ist bei AS auf das
ROMDATA-Segment abgebildet!


        4.48. F2MC16L
        -------------

Darauf,  da· man bei Anwendungen mit mehr als 64K ROM oder 64K RAM dar-
auf  achten  sollte,  AS  die  korrekte  momentane  Belegung  der Bank-
Register  mitzuteilen, wurde  bereits in  Zusammenhang mit  dem ASSUME-
Befehl  erwÑhnt. AS ÅberprÅft  bei jedem absoluten  Zugriff anhand die-
ser  Annahmen, ob  evtl. ein  Zugriff auf  eine Speicherstelle erfolgt,
die  momentan Åberhaupt  nicht greifbar  ist. StandardmÑ·ig  sind dafÅr
natÅrlich  nur DTB  und DPR  wichtig, denn  ADB bzw. SSB/USB werden nur
bei  indirekten Zugriffen  Åber RW2/RW6  bzw. RW3/RW7  benutzt, und bei
indirekten  Zugriffen greift diese PrÅfmimik  ohnehin nicht. Nun ist es
aber  so, da· man - Ñhnlich wie  beim 8086 - einem Befehl eine Segment-
prÑfix  voranstellen kann, mit  dem DTB fÅr  den folgenden Befehl durch
ein  beliebiges anderes Register  ersetzt werden kann.  AS fÅhrt deswe-
gen  Åber  die  verwendeten  PrÑfixbefehle  Buch  und  schaltet bei der
PrÅfung  fÅr den nÑchsten  Prozessorbefehl um -  eine zwischen dem Seg-
mentprÑfix  und  Prozessorbefehl  eingestreute  Pseudoanweisung  lîscht
den  Merker also nicht. Dies gilt auch fÅr Pseudobefehle zur Datenabla-
ge  oder  VerÑnderung  des  ProgrammzÑhlers  -  aber wer macht so etwas
schon ;-)


        5. Dateiformate
        ===============

In  diesem Kapitel sollen die Formate  von von AS erzeugten Dateien be-
schrieben werden, deren Format sich nicht direkt erschlie·t.


        5.1. Code-Dateien
        -----------------

Das  vom Assembler  ausgegebene Codedatenformat  mu· in  der Lage sein,
die  Codeteile  fÅr  unterschiedliche  Prozessoren voneinander zu tren-
nen,  und sieht daher etwas anders  aus als gÑngige Formate. Obwohl dem
Assembler  Tools zur  Bearbeitung der  Codedateien beiliegen, halte ich
es fÅr guten Stil, das Format hier kurz offenzulegen:

Sofern  in der Datei Mehrbyte-Integers  gespeichert sind, werden sie im
Intelformat  abgelegt, d.h.  mit dem  LSB zuerst.  Diese Regel gilt be-
reits  fÅr das 16-Bit-Kennungswort mit dem  Wert $1489, d.h. jede Code-
datei beginnt mit den Bytes $89/$14.

Danach  folgt eine Reihe beliebig  vieler ,,Records'', wobei ein Record
entweder  ein zusammenhÑngendes  Teilfeld des  Codes darstellt oder be-
stimmte  Zusatzinformationen  enthÑlt.  Eine  Datei  kann auch ohne Um-
schaltung  des  Prozessortyps  mehrere  Records  enthalten,  wenn Code-
oder  Konstantenbereiche durch  reservierte (und  nicht zu initialisie-
rende)  Speicherbereiche  unterbrochen  werden.  Der Assembler versucht
auf diese Weise, die Datei nicht lÑnger als nîtig werden zu lassen.

Allen  Records ist gemein ist ein  Header-Byte, das den Typ des Records
und  die  damit  folgenden  Datenstrukturen  festlegt. In einer Pascal-
artigen  Form  lÑ·t  sich  die Record-Struktur folgenderma·en beschrei-
ben:

FileRecord = RECORD CASE Header:Byte OF
              $00:(Creator:ARRAY[] OF Char);
              $01..
              $7f:(StartAdr : LongInt;
                   Length   : Word;
                   Data     : ARRAY[0..Length-1] OF Byte);
              $80:(EntryPoint:LongInt);
              $81:(Header   : Byte;
                   Segment  : Byte;
                   Gran     : Byte;
                   StartAdr : LongInt;
                   Length   : Word;
                   Data     : ARRAY[0..Length-1] OF Byte);
             END

Was  in dieser  Schreibweise nicht  ganz zum  Ausdruck kommt,  ist, da·
die LÑnge von Datenfeldern variabel ist und von Length abhÑngt.

Ein  Record  mit  einem  Header-Byte  von  $81 ist ein Record, der Code
oder  Daten aus  beliebigen Segmenten  beinhalten kann.  Das erste Byte
(Header)  gibt  an,  fÅr  welche  Prozessorfamilie  die folgenden Daten
bzw. der folgende Code bestimmt ist (siehe Tabellen 5.1 und 5.2).


      +--------+------------------++--------+------------------+
      | Header | Familie          || Header | Familie          |
      +--------+------------------++--------+------------------+
      +--------+------------------++--------+------------------+
      |   $01  | 680x0, 6833x     ||   $03  | M*Core           |
      |   $04  | XGATE            ||   $05  | PowerPC          |
      |   $09  | DSP56xxx         ||   $11  | 65xx/MELPS-740   |
      |   $12  | MELPS-4500       ||   $13  | M16              |
      |   $14  | M16C             ||   $15  | F^2MC8L          |
      |   $16  | F^2MC16L         ||   $19  | 65816/MELPS-7700 |
      |   $21  | MCS-48           ||   $25  | SYM53C8xx        |
      |   $29  | 29xxx            ||   $2a  | i960             |
      |   $31  | MCS-51           ||   $32  | ST9              |
      |   $33  | ST7              ||   $37  | 2650             |
      |   $38  | 1802/1805        ||   $39  | MCS-96/196/296   |
      |   $3a  | 8X30x            ||   $3b  | AVR              |
      |   $3c  | XA               ||   $3f  | 4004/4040        |
      |   $41  | 8080/8085        ||   $42  | 8086..V35        |
      |   $47  | TMS320C6x        ||   $48  | TMS9900          |
      |   $49  | TMS370xxx        ||   $4a  | MSP430           |
      |   $4b  | TMS320C54x       ||   $4c  | 80C166/167       |
      |   $51  | Z80/180/380      ||   $52  | TLCS-900         |
      |   $53  | TLCS-90          ||   $54  | TLCS-870         |
      |   $55  | TLCS-47          ||   $56  | TLCS-9000        |
      |   $59  | eZ8              ||   $5b  | KCPSM3           |
      |   $5c  | LatticeMico8     ||   $5e  | 68RS08           |
      |   $5f  | COP4             ||   $60  | 78K2             |
      |   $61  | 6800, 6301, 6811 ||   $62  | 6805/HC08        |
      |   $63  | 6809             ||   $64  | 6804             |
      |   $65  | 68HC16           ||   $66  | 68HC12           |
      |   $67  | ACE              ||   $68  | H8/300(H)        |
      |   $69  | H8/500           ||   $6a  | 807x             |
      |   $6b  | KCPSM            ||   $6c  | SH7000           |
      |   $6d  | SC14xxx          ||   $6e  | SC/MP            |
      |   $6f  | COP8             ||   $70  | PIC16C8x         |
      |   $71  | PIC16C5x         ||   $72  | PIC17C4x         |
      |   $73  | TMS-7000         ||   $74  | TMS3201x         |
      |   $75  | TMS320C2x        ||   $76  | TMS320C3x        |
      +--------+------------------++--------+------------------+

Tabelle 5.1: Headerbytes fÅr die verschiedenen Prozessorfamilien



       +--------+----------------------++--------+------------+
       | Header | Familie              || Header | Familie    |
       +--------+----------------------++--------+------------+
       +--------+----------------------++--------+------------+
       |   $77  | TMS320C20x/TMS320C5x ||   $78  | ST6        |
       |   $79  | Z8                   ||   $7a  | ÊPD78(C)10 |
       |   $7b  | 75K0                 ||   $7c  | 78K0       |
       |   $7d  | ÊPD7720              ||   $7e  | ÊPD7725    |
       |   $7f  | ÊPD77230             ||        |            |
       +--------+----------------------++--------+------------+

Tabelle 5.2: Headerbytes fÅr die verschiedenen Prozessorfamilien


Das  Segment-Feld gibt an, in welchen Adre·raum des Prozessors der fol-
gende Code gehîrt. Dabei gilt die in Tabelle 5.3 angegeben Zuordnung.

            +--------+---------------++--------+---------+
            | Nummer | Segment       || Nummer | Segment |
            +--------+---------------++--------+---------+
            +--------+---------------++--------+---------+
            |   $00  | <undefiniert> ||   $01  | CODE    |
            |   $02  | DATA          ||   $03  | IDATA   |
            |   $04  | XDATA         ||   $05  | YDATA   |
            |   $06  | BDATA         ||   $07  | IO      |
            |   $08  | REG           ||   $09  | ROMDATA |
            +--------+---------------++--------+---------+

Tabelle 5.3: Kodierungen des Segment-Feldes

Das  Gran-Feld gibt die  ,,GranularitÑt'' des Codes  an, d.h. die Grî·e
der  kleinsten, adressierbaren  Einheit im  folgenden Datensatz. Dieser
Wert  ist eine Funktion von Prozessortyp  und Segment und ein wichtiges
Detail  fÅr die Interpretation der  beiden folgenden Felder, die Start-
adresse  und LÑnge angeben: WÑhrend die  Startadresse sich auf die Gra-
nularitÑt  bezieht, erfolgt die  LÑngenangabe immer in  Bytes! WÑre die
Startadresse  z.B. $300  und die  LÑnge 12,  so wÑre die sich ergebende
Endadresse  bei einer GranularitÑt  von 1 $30b,  bei einer GranularitÑt
von  z.B. 4  jedoch $303!  Andere GranularitÑten  als eins  sind selten
und  treten in  erster Linie  bei Signalprozessoren  auf, die nicht auf
Einzelbyteverarbeitung  ausgelegt  sind  deren  Datenspeicher  z.B. aus
64kWorten  zu  16  Bit  besteht  (DSP56K). Der sich ergebende Speicher-
platz  betrÑgt dann zwar 128 KByte, er ist aber in 2 ^16 Worten organi-
siert, die mit Adressen von 0,1,2,...65535 adressiert werden!

Die  Startadresse ist 32-bittig, unabhÑngig von der Adre·breite der je-
weiligen  Prozessorfamilie. Im Gegensatz dazu  ist die LÑngenangabe nur
16  Bit  lang,  ein  Record  kann  also maximal (4+4+2+(64K-1)) = 65545
Byte lang werden.

Daten-Records  mit den Header-Bytes  $01..$7f stellen eine Kurzschreib-
weise  dar und  stellen die  AbwÑrtskompatibilitÑt mit frÅheren Defini-
tionen  des Dateiformats her:  Das Header-Byte gibt  direkt den Prozes-
sortyp  gemÑ· der ersten Tabelle an, das Zielsegment ist auf CODE fest-
gelegt  und die GranularitÑt  ergibt sich aus  dem Prozessortyp, aufge-
rundet  auf eine  Zweierpotenz von  Bytes. AS  bevorzugt diese Records,
wenn Daten bzw. Code fÅr das CODE-Segment anstehen.

Der  Record mit  dem Typ-Byte  $80 legt  den Einsprungpunkt  fest, d.h.
die  Adresse, an der mit der  AusfÅhrung des Programmes begonnen werden
soll.  Ein solcher Record ist das  Ergebnis einer END-Anweisung mit ei-
ner entsprechenden Adresse als Argument.

Der  letzte Record in  der Datei trÑgt  das Header-Byte $00 und besitzt
als  einziges Datenfeld einen  String, dessen Ende  durch das Dateiende
definiert  ist. Dieser String spezifiziert,  von welchem Programm diese
Datei erzeugt wurde und hat keine weitere Bedeutung.


        5.2. Debug-Dateien
        ------------------

Debug-Dateien  kînnen optional von AS  erzeugt werden und liefern nach-
geschalteten  Werkzeugen  wie  Disassemblern  oder  Debuggern fÅr diese
wichtige  Informationen. AS  kann Debug-Informationen  in drei Formaten
ausgeben:  Zum einen im Objekt-Format der AVR-Tools von Atmel sowie ei-
ne  zu NoICE kompatible Kommandodatei und  zum anderen in einem eigenen
Format.  Die ersten beiden werden in [4] bzw. der Dokumentation zu NoI-
CE  ausfÅhrlich beschrieben,  deshalb beschrÑnkt  sich die folgende Be-
schreibung auf das AS-eigene MAP-Format:

Diese Informationen in einer MAP-Datei teilen sich in drei Gruppen:

  - Symboltabelle
  - Speicherberlegung, auf Sektionen verteilt
  - Maschinenadressen von Quellzeilen

Letzterer  Teil findet sich zuerst in  der Datei. Ein einzelner Eintrag
in  dieser  Liste  besteht  aus  zwei, von einem Doppelpunkt getrennten
Zahlen:

 <Zeilennummer>:<Adresse>

Ein  solcher Eintrag besagt, da· der aus einer bestimmten Quellcodezei-
le  erzeugte  Maschinencode  auf  der angegebenen Adresse (hexadezimal)
zu  liegen kam.  Mit einer  solchen Information  kann ein Debugger beim
Durchsteppen  des Programmes die  entsprechenden Quellcodezeilen anzei-
gen.  Da ein Programm  aber auch aus  mehreren Include-Dateien bestehen
kann,  und  viele  Prozessoren  mehr  als  nur einen Adre·raum besitzen
(von  dem zugegebenerma·en  nur in  einem Code  liegt), mÅssen die oben
beschriebenen  EintrÑge sortiert  werden. AS  tut dies  in zwei Stufen:
Das  primÑre  Sortierkriterium  ist  das  Zielsegment, innerhalb dieser
Segmente  wird noch  einmal nach  Dateien sortiert. Einzelne Abschnitte
werden dabei durch durch spezielle Zeilen der Form

Segment <Segmentname>

bzw.

File <Dateiname>

getrennt.

Die  Symboltabelle  folgt  der  Quellzeileninformation  und  ist wieder
primÑr  nach den Segmenten geordnet, aus  denen die Symbole stammen. Im
Gegensatz  zur  Zeileninformation  kommt  hier  allerdings auch der Ab-
schnitt  NOTHING hinzu, der die Symbole beinhaltet, die keinem speziel-
len  Adre·raum zugeordnet sind (z.B. Symbole, die einfach mit EQU defi-
niert  wurden). Die  Einleitung eines  Abschnittes in der Symboltabelle
erfolgt mit einer Zeile der Form

Symbols in Segment <Segmentname>   .

Innerhalb  eines Abschnittes sind die  Symbole nach Namen sortiert, und
ein  Symboleintrag belegt genau  eine Zeile. Eine  solche Zeile besteht
wiederum  aus 5 Feldern,  die durch jeweils  mindestens ein Leerzeichen
getrennt sind:

Das  erste Feld  ist der  Name des  Symbols selber, eventuell erweitert
um  eine in  eckigen Klammern  eingeschlossene Sektionsnummer,  die den
GÅltigkeitsbereich  des Symbols einschrÑnkt. Die zweite Spalte bezeich-
net  den Typ des Symbols: Int  fÅr Integerzahlen, Float fÅr Gleitkomma-
zahlen  und  String  fÅr  Zeichenketten.  Die  dritte Zeile schlie·lich
beinhaltet  den  eigentliche  Wert  des  Symbols. Falls das Symbol eine
Zeichenkette  beinhaltet,  ist  es  notwendig,  Steuer- und Leerzeichen
mit  einer gesonderten  Notation zu  kennzeichnen, damit  ein im String
enthaltenes  Leerzeichen nicht eventuell  als Trennzeichen zur nÑchsten
Spalte  interpretiert  werden  kann.  AS  bedient sich dazu der bereits
der  in  Assemblerquellen  Åblichen  Schreibweise, den ASCII-Zahlenwert
mit einem fÅhrenden Backslash (\) einzusetzen. Aus dem String

 Dies ist ein Test

wird also z.B.

 Dies\032ist\032ein\032Test

Die  Zahlenangabe ist immer dezimal  und dreistellig, und der Backslash
selber wird ebenfalls in dieser Schreibweise kodiert.

Das  vierte Feld gibt  - falls vorhanden  - die Grî·e der Datenstruktur
an,  die  an  der  durch  das  Symbol gekennzeichneten Adresse abgelegt
ist.  Ein Debugger kann eine solche  Information z.B. nutzen, um symbo-
lisch  angesprochene Variablen  direkt in  der korrekten LÑnge aufzuli-
sten.  Hat AS  keine Informationen  Åber die  Symbolgrî·e, so  steht in
diesem Feld eine schlichte -1.

Das  fÅnfte und letzte Feld gibt schlu·endlich  durch eine 0 oder 1 an,
ob  das  Symbol  wÑhrend  der  Assemblierung jemals referenziert wurde.
Ein  Programm, da· die  Symboltabelle liest, kann  auf diese Weise z.B.
nicht  benutzte Symbole  automatisch verwerfen,  da sie  beim folgenden
Debugging  oder der Disassemblierung  mit hoher Wahrscheinlichkeit auch
nicht benîtigt werden.

Der  dritte Abschnitt in  einer Debug-Datei beschreibt  die im Programm
benutzten  Sektionen nÑher. Eine  solche Beschreibung ist erforderlich,
da  Sektionen den GÅltigkeitsbereich  von Symbolen einschrÑnken kînnen.
Je  nach momentanem  Stand des  ProgrammzÑhlers kann  z.B. ein symboli-
scher  Debugger  einzelne  Symboldefinitionen  fÅr eine RÅckÅbersetzung
nicht  nutzen oder mu· PrioritÑten  bei der Symbolnutzung beachten. Die
Definition einer Sektion beginnt mit einer Zeile der Form

Info for Section nn ssss pp     ,

wobei  nn die  Nummer der  Sektion angibt  (die Nummer, die als Postfix
fÅr  Symbolnamen in der Symboltabelle genutzt  wird), ssss der Name der
Sektion  ist und pp die Nummer der Vatersektion darstellt. Letztere In-
formation  benîtigt ein RÅckÅbersetzer, um  sich bei der Auffindung ei-
nes  Symbols fÅr einen  Zahlenwert ausgehend von  der aktuellen Sektion
im  Baum bis zur  Wurzel ,,durchhangeln'' kann,  bis ein passendes Sym-
bol  gefunden wird. Auf  diese Zeile folgt  eine Reihe weiterer Zeilen,
die  den von  dieser Sektion  belegten Code-Bereich  beschreiben. Jeder
einzelne  Eintrag (genau einer pro Zeile) beschreibt entweder eine ein-
zelne  Adresse oder  einen durch  zwei Grenzwerte beschriebenen Bereich
(Trennung  von Anfangs-und  Endwert durch  ein Minuszeichen). Die Gren-
zen  sind dabei ,,inklusive'', d.h. die Grenzen gehîren auch zu dem Be-
reich.  Wichtig ist,  da· ein  einer Sektion  zugehîriger Bereich nicht
nochmals  fÅr ihre  Vatersektionen aufgefÅhrt  wird (eine  Ausnahme ist
natÅrlich,  wenn Bereiche  absichtlich mehrfach  belegt werden, aber so
etwas  macht man ja  auch nicht, gelle?).  Dies dient einer Optimierung
der  Bereichsspeicherung wÑhrend der Assemblierung  und sollte auch fÅr
eine  SymbolrÅckÅbersetzung  keine  Probleme  darstellen,  da durch die
einfache  Kennzeichnung bereits der Einstiegspunkt  und damit der Such-
pfad  im Sektionsbaum gegeben ist.  Die Beschreibung einer Sektion wird
durch eine Leerzeile oder das Dateiende gekennzeichnet.

Programmteile,  die au·erhalb aller Sektionen  liegen, werden nicht ge-
sondert  ausgewiesen. Diese ,,implizite  Wurzelsektion'' trÑgt die Num-
mer  -1 und wird auch als  Vatersektion fÅr Sektionen benutzt, die kei-
ne eigentliche Vatersektion besitzen.

Es   ist  mîglich,  da·  die   Datei  Leerzeilen  oder  Kommentarzeilen
(Semikolon  am Zeilenanfang) beinhaltet. Diese  sind von einem Lesepro-
gramm zu ignorieren.


        6. Hilfsprogramme
        =================

Um  die Arbeit mit dem Codeformat  des Assemblers etwas zu erleichtern,
lege  ich einige Progamme zu deren  Bearbeitung bei. FÅr diese Program-
me  gilt sinngemÑ· das  gleiche wie in  1.1! Allen Programmen gemeinsam
sind die Returncodes, die sie liefern (Tabelle 6.1).


            +------------+-------------------------------+
            | Returncode | tritt auf bei...              |
            +------------+-------------------------------+
            +------------+-------------------------------+
            |      0     | kein Fehler                   |
            |      1     | Kommandozeilenparameterfehler |
            |      2     | I/O-Fehler                    |
            |      3     | Dateiformatfehler             |
            +------------+-------------------------------+

Tabelle 6.1: Returncodes der Dienstprogramme

Ebenso  eintrÑchtig  wie  AS  lesen  sie  ihre  Eingaben  von STDIN und
schreiben  Meldungen auf STDOUT (bzw. Fehlermeldungen auf STDERR). Ein-
und Ausgaben sollten sich daher problemlos umleiten lassen.

Sofern  Programme im folgenden Zahlen-oder Adre·angaben von der Komman-
dozeile  lesen, dÅrfen  diese auch  hexadezimal geschrieben werden, in-
dem  man sie  mit einem  voranstehenden Dollarzeichen  oder 0x wie in C
versieht (z.B. $10 oder 0x10 anstelle von 16).

Unix-Shells  ordnen dem Dollarzeichen  allerdings eine spezielle Bedeu-   UNIX
tung  zu (Parameterexpansion),  weshalb es  nîtig ist, einem Dollarzei-
chen  direkt einen  Backslash voranzustellen.  Die 0x-Variante ist hier
sicherlich angenehmer.

Ansonsten  folgen  die  Aufrufkonventionen  und  -variationen  (bis auf
PLIST  und  AS2MSG)  denen  von  AS,  d.h.  man kann dauernd gebrauchte
Schalter  in einer  Environmentvariablen ablegen  (deren Name  sich aus
dem  AnhÑngen von  CMD an  den Programmnamen  ergibt, z.B.  BINDCMD fÅr
BIND),   Optionen  negieren  und  Gro·-bzw.  Kleinschreibung  erzwingen
(nÑheres zu dem Wie in Abschnitt 2.4).

Sofern  Adre·angaben benutzt  werden, beziehen  sie sich  immer auf die
GranularitÑt  des Adre·raumes  des jeweiligen  Prozessors; beim PIC be-
deutet  z.B.  eine  Adre·differenz  von  1  nicht ein Byte, sondern ein
Wort.


        6.1. PLIST
        ----------

PLIST  ist das  einfachste Programm  der vier  mitgelieferten; es dient
einfach  nur dazu, die in  einer Codedatei gespeicherten Records aufzu-
listen.  Da das Programm nicht allzuviel  bewirkt, ist der Aufruf ziem-
lich simpel:

    PLIST $<$Dateiname$>$

Der  Dateiname wird automatisch um die  Endung P erweitert, falls keine
Endung vorhanden ist.

ACHTUNG!  An dieser Stelle  sind keine Jokerzeichen  erlaubt! Falls mit
einem  Befehl trotzdem mehrere  Programmdateien gelistet werden sollen,
kann man sich mit folgendem ''Minibatch'' behelfen:

    for %n in (*.p) do plist %n

PLIST  gibt den Inhalt der Codedatei in Tabellenform aus, wobei fÅr je-
den  Record genau eine  Zeile ausgegeben wird.  Die Spalten haben dabei
folgende Bedeutung:

  - Codetyp: die Prozessorfamilie, fÅr die der Code erzeugt wurde.
  - Startadresse:  absolute Speicheradresse,  an die  der Code zu laden
    ist.
  - LÑnge: LÑnge des CodestÅcks in Byte.
  - Endadresse:  letzte absolute Adresse  des CodestÅcks. Diese berech-
    net sich als Startadresse+LÑnge-1.

Alle Angaben sind als hexadezimal zu verstehen.

Zuletzt  gibt PLIST  noch einen  Copyrightvermerk aus,  sofern er einen
solchen in der Datei findet, und die Summe aller CodelÑngen.

PLIST  ist praktisch ein DIR fÅr  Codedateien. Man kann es benutzen, um
sich  den Inhalt einer Datei auflisten zu lassen, bevor man sie weiter-
bearbeitet.


        6.2. BIND
        ---------

BIND  ist ein  Programm, mit  dem man  die Records mehrerer Codedateien
in  eine Datei zusammenkopieren kann.  Die dabei vorhandene Filterfunk-
tion  erlaubt  es  aber  auch,  nur  Records  eines  bestimmten Typs zu
Åbernehmen.  Auf diese Weise  kann BIND auch  dazu verwendet werden, um
eine Codedatei in mehrere aufzuspalten.

Die allgemeine Syntax von BIND lautet

   BIND <Quelldatei(en)> <Zieldatei> [Optionen]

Wie  auch AS betrachtet BIND alle nicht mit einem +, - oder / eingelei-
teten  Parameter als Dateiangaben,  von denen die  letzte die Zieldatei
angeben  mu·. Alle anderen Dateiangaben bezeichnen Quellen, diese Anga-
ben dÅrfen auch wieder Jokerzeichen enthalten.

An Optionen definiert BIND momentan nur eine:

  - f  <Header[,Header...]>: gibt eine Liste von Header-IDs an, die ko-
    piert  werden sollen.  Alle anderen  Records werden  nicht kopiert.
    Ohne  diese Angabe  werden alle  Records kopiert.  Die in der Liste
    angegebenen  entsprechen  dem  Header-Feld  in  der Recordstruktur,
    wie  es in Abschnitt 5.1  beschrieben wurden. Die einzelnen Header-
    Nummern in der Liste werden durch Kommas getrennt.

Um  z.B. alle MCS-51-Codeteile aus einer Programmdatei auszusieben, be-
nutzt man BIND folgenderma·en:

   BIND <Quellname> <Zielname> -f $31

Fehlt  bei einer Dateiangabe  eine Endung, so  wird automatisch die En-
dung P angefÅgt.


        6.3. P2HEX
        ----------

P2HEX  ist eine Erweiterung von BIND. Es besitzt alle Kommandozeilenop-
tionen  von BIND  und hat  die gleichen  Konventionen bzgl. Dateinamen.
Im  Gegensatz zu BIND  wird die Zieldatei  aber als Hexfile ausgegeben,
d.h.  als eine Folge von Zeilen,  die den Code als ASCII-Hexzahlen ent-
halten.

P2HEX  kennt 8 verschiedene Zielformate, die Åber den Kommandozeilenpa-
rameter F ausgewÑhlt werden kînnen:

  - Motorola S-Record (-F Moto)
  - MOS Hex (-F MOS)
  - Intel-Hex (Intellec-8, -F Intel)
  - 16-Bit Intel-Hex (MCS-86, -F Intel16)
  - 32-Bit Intel-Hex (-F Intel32)
  - Tektronix Hex (-F Tek)
  - Texas Instruments DSK (-F DSK)
  - Atmel AVR Generic (-F Atmel, siehe [4])

Wird  kein  Zielformat  explizit  angegeben,  so wÑhlt P2HEX anhand des
Prozessortyps  automatisch eines aus, und  zwar S-Records fÅr Motorola-
Prozessoren,  Hitachi und TLCS-900(0), MOS  fÅr 65xx/MELPS, DSK fÅr die
16-Bit-Texas-Signalprozessoren,  Atmel Generic fÅr  die AVRs und Intel-
Hex  fÅr den Rest. Je nach  Breite der Startadresse kommen bei S-Record
Records  der Typen 1,2 oder  3 zum Einsatz, jedoch  nie in einer Gruppe
gemischt. Diese Automatik lÑ·t sich mit der Kommandozeilenoption

  -M <1|2|3>

teilweise  unterdrÅcken:  Ein  Wert  von  2  bzw. 3 sorgt dafÅr, da· S-
Records  mit einem Mindesttyp von 2  bzw. 3 benutzt werden, wÑhrend ein
Wert von 0 der vollen Automatik entspricht.

Normalerweise  benutzt das AVR-Format  immer eine Adre·lÑnge  von 3 By-
tes.  Manche Programme  mîgen das  leider nicht...deshalb  kann man mit
dem Schalter

  -avrlen <2|3>

die LÑnge zur Not auf 2 Bytes reduzieren.

Die  Intel-, Tektronix-  und MOS-Formate  sind auf  16 Bit-Adressen be-
schrÑnkt,  das 16-Bit Intel-Format reicht  4 Bit weiter. LÑngere Adres-
sen  werden von P2HEX mit  einer Warnung gemeldet und abgeschnitten(!).
FÅr  die PICs  kînnen die  drei von  Microchip spezifizierten Varianten
des Intel-Hex-Formates erzeugt werden, und zwar mit dem Schalter

  -m <0..3>

Das  Format 0 ist INHX8M, in  dem alle Bytes in Lo-Hi-Ordnung enthalten
sind.  Die Adre·angaben verdoppeln sich, weil  bei den PICs die Adresse
sich  nur um 1 pro Wort erhîht. Dieses Format ist gleichzeitig die Vor-
gabe.  Im Format  1 (INHX16M)  werden alle  Worte in  ihrer natÅrlichen
Ordnung  abgelegt. Dieses Format verwendet  Microchip fÅr seine eigenen
ProgramiergerÑte.  Format 2 (INHX8L)  und 3 (INHX8H)  trennen die Worte
in  ihre oberen und unteren Bytes  auf. Um die komplette Information zu
erhalten, mu· P2HEX zweimal aufgerufen werden, z.B. so:

  p2hex test -m 2
  rename test.hex test.obl
  p2hex test -m 3
  rename test.hex test.obh

FÅr  das Motorola-Format  verwendet P2HEX  zusÑtzlich einen  in [8] ge-
nannten  Recordtyp mit der Nummer 5,  der die Zahl der folgenden Daten-
Records  (S1/S2/S3) bezeichnet.  Da dieser  Typ vielleicht  nicht jedem
Programm bekannt ist, kann man ihn mit der Option

 +5

unterdrÅcken.

Finden  sich Code-Records  verschiedener Prozessoren  in einer Quellda-
tei,  so erscheinen die  verschiedenen Hexformate auch  gemischt in der
Zieldatei  --- es empfiehlt sich  also dringend, von der Filterfunktion
Gebrauch zu machen.

Neben  dem  Codetypenfilter  kennt  P2HEX  noch  ein  Adre·filter,  das
nÅtzlich ist, falls der Code auf mehrere EPROMs verteilt werden mu·:

  -r <Startadresse>-<Endadresse>

Die  Startadresse  ist  dabei  die  erste Speicherzelle, die im Fenster
liegen  soll, die Endadresse die  der letzten Speicherzelle im Fenster,
nicht  die der ersten  au·erhalb. Um z.B.  ein 8051-Programm in 4 2764-
EPROMs aufzuteilen, geht man folgenderma·en vor:

p2hex <Quelldatei> eprom1 -f $31 -r $0000-$1fff
p2hex <Quelldatei> eprom2 -f $31 -r $2000-$3fff
p2hex <Quelldatei> eprom3 -f $31 -r $4000-$5fff
p2hex <Quelldatei> eprom4 -f $31 -r $6000-$7fff

DefaultmÑ·ig ist das Fenster 32 KByte gro· und beginnt bei Adresse 0.

ACHTUNG!  Die Splittung  Ñndert nichts  an den  absoluten Adressen, die
in  den Hexfiles  stehen! Sollen  die Adressen  im Hexfile bei 0 begin-
nen, so kann man dies durch den zusÑtzlichen Schalter

 -a

erreichen.  Um im Gegenteil die Adre·lage  auf einen bestimmten Wert zu
verschieben, kann man den Schalter

 -R <Wert>

verwenden.  Der dabei angegebene Wert ist  ein Offset, d.h. er wird auf
die in der Code-Datei angegebenen Adressen aufaddiert.

Als  Sonderwerte  fÅr  Start-und  Endadresse  beim  r-Parameter ist ein
schlichtes  Dollar-Zeichen  ($)  erlaubt.  Diese kennzeichnet die erste
bzw.  letzte  in  der  Programmdatei  belegte  Adresse. Wer also sicher
sein  will,  da·  immer  das  ganze  Programm in der Hex-Datei abgelegt
wird, braucht sich mit dem Schalter

 -r $-$

keine  Gedanken mehr zu  machen. Dollarzeichen und  feste Adressen las-
sen sich selbstverstÑndlich auch gemischt verwenden, z.B. kann mit

 -r $-$7fff

das obere Ende auf die ersten 32K begrenzt werden.

Den  Inhalt einer  Datei kann  man mit  einem Offset auf eine beliebige
Position  verschieben; diesen Offset  hÑngt man einfach  in Klammern an
den  Dateinamen an. Ist der  Code in einer Datei  z.B. auf Adresse 0 in
der  P-Datei abgelegt,  man mîchte  ihn jedoch  auf Adresse  1000h ver-
schieben,  so hÑngt  man an  ($1000) an  den Dateinamen  (ohne Leerzei-
chen!) an.

Da  das TI-DSK-Format Daten und Code  unterscheiden kann, lÑ·t sich mit
dem Schalter

 -d <Start>-<Ende>

festlegen,  welche  Adre·bereiche  als  Daten ausgegeben werden sollen.
Dollarzeichen  sind hier  nicht zugelassen.  Diese Option  sollte nicht
mehr  in neuen Projekten  verwendet werden, da  P2HEX inzwischen direkt
Daten aus dem Datensegment korrekt umsetzen kann.

FÅr  das  DSK-  sowie  Intel-  und Motorola-Format relevant ist dagegen
die Option

 -e <Adresse> ,

mit  der man die in  die Hex-Datei einzutragende Startadresse festlegen
kann.  Fehlt diese  Angabe, so  wird nach  einen entsprechenden Eintrag
in  der Code-Datei gesucht.  Ist auch dort  kein Hinweis auf einen Ein-
sprungpunkt  zu finden, so wird kein Eintrag in die HEX-Datei geschrie-
ben  (DSK/Intel)  bzw.  das  entsprechende  Feld  wird  auf  0  gesetzt
(Motorola).

Leider  ist sich die Literatur nicht ganz Åber die Endezeile fÅr Intel-
Hexfiles  einig. P2HEX  kennt daher  3 Varianten,  einstellbar Åber den
Parameter i mit einer nachfolgenden Ziffer:

  0  :00000001FF
  1  :00000001
  2  :0000000000


DefaultmÑ·ig  wird die Variante  0 benutzt, die  die gebrÑuchlichste zu
sein scheint.

Fehlt  der Zieldateiangabe eine Endung, so wird HEX als Endung angenom-
men.

DefaultmÑ·ig  gibt P2HEX  pro Zeile  maximal 16  Datenbytes aus, wie es
auch  die  meisten  anderen  Tools  tun, die Hex-Files erzeugen. Wollen
Sie dies Ñndern, so kînnen Sie dies mit dem Schalter

-l <Anzahl>

tun.  Der erlaubte Wertebereich liegt dabei zwischen 2 und 254 Datenby-
tes; ungerade Werte werden implizit auf gerade Anzahlen aufgerundet.

Meist  werden die temporÑren, von  AS erzeugten Code-Dateien nach einer
Umwandlung  nicht mehr unbedingt gebraucht. Mit der Kommandozeilen- op-
tion

-k

kann  man  P2HEX  anweisen,  diese  automatisch  nach der Konversion zu
lîschen.

Anders  als BIND erzeugt P2HEX keine  Leerdatei, wenn nur ein Dateiname
(=Zieldatei)  angegeben wurde, sondern  bearbeitet die dazugehîrige Co-
dedatei. Es ist also ein Minimalaufruf Ö la

 P2HEX <Name>

mîglich, um <Name: >.HEX aus <Name: >.P zu erzeugen.


        6.4. P2BIN
        ----------

P2BIN  funktioniert  wie  P2HEX  und  bietet die gleichen Optionen (bis
auf  die a-  und i-  Optionen, die  bei BinÑrdateien  keinen Sinn erge-
ben),  nur wird das  Ergebnis nicht als  Hexdatei, sondern als einfache
BinÑrdatei  abgelegt. Dies kann dann z.B.  direkt in ein EPROM gebrannt
werden.

Zur  Beeinflussung  der  BinÑrdatei  kennt  P2BIN  gegenÅber P2HEX noch
drei weitere Optionen:

  - l  <8-Bit-Zahl>: gibt den Wert an, mit dem unbenutzte Speicherstel-
    len  in der Datei gefÅllt werden  sollen. DefaultmÑ·ig ist der Wert
    $ff,   so   da·   ein   halbwegs  intelligenter  EPROM-Brenner  sie
    Åberspringt.  Man kann  aber hiermit  auch andere Werte einstellen,
    z.B.  enthalten  die  gelîschten  Speicherzellen  der MCS-48-EPROM-
    Versionen  Nullen.  In  einem  solchen  Falle  wÑre  0 der richtige
    Wert.
  - s:  weist das  Programm an,  eine PrÅfsumme  Åber die BinÑrdatei zu
    berechnen.  Die PrÅfsumme  wird einmal  als 32-Bit-Wert ausgegeben,
    zum  anderen wird das  Zweierkomplement der Bits  0..7 in der letz-
    ten  Speicherstelle  abgelegt,  so  da·  die  Modulo-256-Summe zu 0
    wird.
  - m:  fÅr den  Fall, da·  ein Prozessor  mit 16- oder 32-Bit-Datenbus
    eingesetzt  wird und die BinÑrdatei  fÅr mehrere EPROMs aufgesplit-
    tet werden mu·. Das Argument kann folgende Werte annnehmen:
      - ALL: alles kopieren
      - ODD: alle Bytes mit ungerader Adresse kopieren
      - EVEN: alle Bytes mit gerader Adresse kopieren
      - BYTE0..BYTE3:  nur alle Bytes kopieren,  deren Adresse die Form
        4n+0...4n+3 hat.
      - WORD0,WORD1:  nur das untere bzw. obere 16-Bit-Wort der 32-Bit-
        Worte kopieren.


Nicht  wundern: Bei letzteren  Optionen ist die  BinÑrdatei um den Fak-
tor  2  oder  4  kleiner  als  bei  ALL.  Dies  ist  bei konstantem Ad-
re·fenster logisch!

Falls  die Code-Datei keine  Startadresse enthÑlt, kann  man diese ana-
log  zu P2HEX  Åber die  -e-Kommandozeilenoption vorgeben. Auf Anforde-
rung  teilt P2BIN ihren Wert der Ergebnisdatei voran. Mit der Kommando-
zeilenoption

-S

wird  diese Funktion aktiviert. Sie  erwartet als Argument eine Zahlen-
angabe  zwischen 1 und 4,  die die LÑnge des  Adressfeldes in Bytes be-
stimmt.  Optional kann dieser  Angabe auch noch  der Buchstabe L oder B
vorangestellt  werden,  um  die  Byte-Order dieser Adresse festzulegen.
So  erzeugt  z.B.  die  Angabe  B4  eine  4-Byte-Adresse in Big-Endian-
Anordnung,  L2  oder  nur  '2'  eine  2-Byte-Adresse  in Little-Endian-
Anordnung.


        6.5. AS2MSG
        -----------

Bei  AS2MSG handelt es  sich eigentlich um  kein Hilfsprogramm, sondern
um  ein Filter, das (glÅcklichen)  Besitzern von Borland-Pascal 7.0 das
Arbeiten   mit   dem   Assembler   erleichtern   soll.   In   den  DOS-
Arbeitsumgebungen  existiert ein ,,Tools''-MenÅ, das man um eigene Pro-
gramme,  z.B. AS erweitern kann. Das  Filter erlaubt, die von AS gelie-
ferten  Fehlermeldungen mit Zeilenangabe  direkt im Editorfenster anzu-
zeigen.  Dazu  mu·  im  Tools-MenÅ  ein  neuer  Eintrag angelegt werden
(Options/Tools/New).  Tragen Sie in die  einzelnen Felder folgende Wer-
te ein :

  - Title: ~M~akroassembler
  - Program path: AS
  - Command line: -E !1 $EDNAME $CAP MSG(AS2MSG) $NOSWAP $SAVE ALL
  - bei Bedarf einen Hotkey zuordnen (z.B. Shift-F7)

Die  Option  -E  sorgt  dafÅr,  da·  Turbo-Pascal  nicht mit STDOUT und
STDERR durcheinander kommt.

Ich  setze dabei voraus,  da· sowohl AS  als auch AS2MSG  sich in einem
Verzeichnis  befinden, welches  in der  Pfadliste aufgefÅhrt  ist. Nach
einem  Druck  auf  dem  passenden  Hotkey  (oder Auswahl aus dem Tools-
MenÅ)  wird AS  mit dem  Namen der  Textdatei im  aktiven Editorfenster
aufgerufen.  Die  dabei  aufgetretenen  Fehler  werden in ein separates
Fenster  geleitet, durch das  man nun ,,browsen''  kann. Mit Ctrl-Enter
springt  man eine fehlerhafte Zeile  an. ZusÑtzlich enthÑlt das Fenster
die  Statistik, die AS am Ende  der Assemblierung ausgibt. Diese erhal-
ten als Dummy-Zeilennummer 1.

FÅr  diese  Arbeitsweise  sind  sowohl  TURBO.EXE  (Real Mode) als auch
BP.EXE  (Protected Mode) geeignet. Ich empfehle  BP, da in dieser Vari-
ante  beim Aufruf  nicht erst  der halbe  DOS-Speicher ,,freigeswappt''
werden mu·.




        A. Fehlermeldungen von AS
        =========================

Im  folgenden findet sich eine  halb-tabellarische Auflistung der in AS
definierten  Fehlermeldungen. Zu  jeder Fehlermeldung  finden sich fol-
gende Angaben:

  - interne  Fehlernummer (fÅr den Anwender nur mit der n-Option sicht-
    bar);
  - Fehlermeldung im Klartext;
  - Typ:
      - Warnung:  zeigt mîgliche Fehler oder ineffizienten Code an. As-
        semblierung geht weiter.
      - Fehler:  echte  Fehler.  Assemblierung  geht weiter, aber keine
        Code-Datei wird geschrieben.
      - Fatal: schwerwiegende Fehler. Assemblierung wird abgebrochen.
  - Ursache: die Situation(en), in denen der Fehler ausgegeben wird;
  - Argument:  Die Ausgabe,  die auf  Wunsch als  erweiterte Fehlermel-
    dung erfolgt.






  0 Displacement=0, ÅberflÅssig
    Typ: 
        Warnung
    Ursache: 
        bei  680x0-,6809- und COP8-Prozessoren: Das Displacement in ei-
        nem  Adre·ausdruck  hat  den  Wert  0  ergeben. Es wird ein Ad-
        re·ausdruck  ohne Displacement  erzeugt. Um  keine Phasenfehler
        zu erzeugen, werden NOP-Befehle eingefÅgt.
    Argument: 
        keines
         
 10 Kurzadressierung mîglich
    Typ: 
        Warnung
    Ursache: 
        bei   680x0-,  6502-  und   68xx-Prozessoren  kînnen  bestimmte
        Speicherbereiche  mit kurzen Adressen  erreicht werden. Um kei-
        ne  Phasefehler zu erzeugen, wird zwar der kÅrzere Ausdruck er-
        zeugt, der freie Platz wird aber mit NOPs aufgefÅllt.
    Argument: 
        keines
         
 20 kurzer Sprung mîglich
    Typ: 
        Warnung
    Ursache: 
        Bei  680x0 und 8086-Prozessoren kann der Sprung sowohl mit lan-
        gem  als auch  kurzem Displacement  ausgefÅhrt werden.  Da kein
        kurzer  Sprung angefordert  wurde, wurde  im ersten  Pass Platz
        fÅr  den langen Sprung freigehalten.  Es wird ein kurzer Sprung
        erzeugt,  der freie Platz wird  mit NOPs aufgefÅllt, um Phasen-
        fehler zu vermeiden.
    Argument: 
        keines
         
 30 kein Sharefile angelegt, SHARED ignoriert
    Typ: 
        Warnung
    Ursache: 
        Es  wurde eine  SHARED-Anweisung gefunden,  es wurde aber keine
        Kommandozeilenoption  angegeben, um eine Shared-Datei zu erzeu-
        gen.
    Argument: 
        keines
         
 40 FPU liest Wert evtl. nicht korrekt ein (>=1E1000)
    Typ: 
        Warnung
    Ursache: 
        Das  BCD-Gleitkommaformat der  680x0-Koprozessoren erlaubt zwar
        vierstellige  Exponenten,  lt.  Datenbuch  kînnen  solche Werte
        aber  nicht  korrekt  eingelesen  werden. Der vierstellige Wert
        wird zwar erzeugt, eine Funktion ist aber nicht gewÑhleistet.
    Argument: 
        keines
         
 50 Privilegierte Anweisung
    Typ: 
        Warnung
    Ursache: 
        Es  wurde eine  Anweisung benutzt,  die nur  im Supervisor-Mode
        zulÑssig  ist, obwohl  dieser nicht  mittels SUPMODE  ON vorher
        explizit angezeigt wurde.
    Argument: 
        keines
         
 60 Distanz 0 nicht bei Kurzsprung erlaubt (NOP erzeugt)
    Typ: 
        Warnung
    Ursache: 
        Ein  kurzer Sprung mit der Distanz  0 ist bei 680x0- bzw. COP8-
        Prozessoren  nicht  erlaubt,  da  dieser  Sonderwert  fÅr lange
        SprÅnge  benîtigt wird.  Stattdessen wurde  ein NOP-Befehl ein-
        gefÅgt.
    Argument: 
        keines
         
 70 Symbol aus falschem Segment
    Typ: 
        Warnung
    Ursache: 
        Das  in dem Operanden benutzte  Symbol ist aus einem Adre·raum,
        der nicht mit dem benutzten Befehl bearbeitet werden kann.
    Argument: 
        keines
         
 75 Segment nicht adressierbar
    Typ: 
        Warnung
    Ursache: 
        Das  in dem Operanden benutzte  Symbol ist aus einem Adre·raum,
        der  mit keinem der Segmentregister  des 8086 adressiert werden
        kann.
    Argument: 
        Name des nicht adressierbaren Segments
         
 80 énderung des Symbolwertes erzwingt zusÑtzlichen Pass
    Typ: 
        Warnung
    Ursache: 
        Ein  Symbol hat einen  anderen Wert zugewiesen  bekommen als im
        vorhergehenden  Pass. Diese Warnung  wird nur ausgegeben, falls
        die r-Option angegeben wurde.
    Argument: 
        Der Name des fraglichen Symbols
         
 90 öberlappende Speicherbelegung
    Typ: 
        Warnung
    Ursache: 
        Bei  der  Bildung  der  Belegungsliste  wurde festgestellt, da·
        ein  Speicherbereich im Codesegment mehrfach benutzt wurde. Ur-
        sache kînnen unÅberlegte ORG-Anweisungen sein.
    Argument: 
        keines
         
100 keine CASE-Bedingung zugetroffen
    Typ: 
        Warnung
    Ursache: 
        bei  einem SWITCH..CASE-Konstrukt ohne ELSECASE-Zweig traf kei-
        ner der CASE-Zweige zu.
    Argument: 
        keines
         
110 Seite mîglicherweise nicht adressierbar
    Typ: 
        Warnung
    Ursache: 
        Das  in dem Operanden benutzte Symbol liegt nicht in der momen-
        tan mit ASSUME eingestellten Fenster (ST6,78(C)10).
    Argument: 
        keines
         
120 Registernummer mu· gerade sein
    Typ: 
        Warnung
    Ursache: 
        Die  Hardware erlaubt  nur ein  Registerpaar zu verketten, des-
        sen Startadresse gerade ist (RR0, RR2..., nur Z8).
    Argument: 
        keines
         
130 veralteter Befehl
    Typ: 
        Warnung
    Ursache: 
        Der  verwendete Befehl ist  zwar noch definiert,  ist in seiner
        Funktion  aber durch  andere, neue  Befehle ersetzbar und daher
        in  zukÅnftigen Prozessorversionen eventuell nicht mehr vorhan-
        den.
    Argument: 
        keines
         
140 Nicht vorhersagbare AusfÅhrung dieser Anweisung
    Typ: 
        Warnung
    Ursache: 
        Die  verwendete  Adressierungsart  ist  bei  diesem Befehl zwar
        prinzipiell  erlaubt, ein  Register wird  jedoch in einer Weise
        doppelt  verwendet, da· je  nach AusÅhrungsreihenfolge sich un-
        terschiedliche Ergebnisse einstellen kînnen.
    Argument: 
        keines
         
150 Lokaloperator au·erhalb einer Sektion ÅberflÅssig
    Typ: 
        Warnung
    Ursache: 
        Ein  vorangestellter Klammeraffe dient  dazu, sich explizit auf
        zu  der  Sektion  lokale  Symbole  zu  beziehen.  Wenn man sich
        au·erhalb  einer Sektion befindet, gibt es keine lokalen Symbo-
        le, weshalb dieser Operator ÅberflÅssig ist.
    Argument: 
        keines
         
160 sinnlose Operation
    Typ: 
        Warnung
    Ursache: 
        Die  Anweisung ergibt entweder Åberhaupt  keinen Sinn oder kann
        auf andere Weise schneller und kÅrzer ausgefÅhrt werden.
    Argument: 
        keines
         
170 unbekannter Symbolwert erzwingt zusÑtzlichen Pass
    Typ: 
        Warnung
    Ursache: 
        AS  vermutet eine VorwÑrtsreferenz eines Symbols, d.h. das Sym-
        bol  wird  benutzt,  bevor  es  definiert wurde, und hÑlt einen
        weiteren  Pass fÅr unumgÑnglich. Diese  Warnung wird nur ausge-
        geben, falls die r-Option angegeben wurde.
    Argument: 
        Der Name des fraglichen Symbols
         
180 Adresse nicht ausgerichtet
    Typ: 
        Warnung
    Ursache: 
        Eine  Adresse ist nicht ein  mehrfaches der Operandengrî·e. Das
        Datenbuch  verbietet zwar solche  Zugriffe, im Instruktionswort
        ist  aber Platz fÅr diese Adresse, so  da· AS es bei einer War-
        nung belassen hat.
    Argument: 
        keines
         
190 I/O-Adresse darf nicht verwendet werden
    Typ: 
        Warnung
    Ursache: 
        Der   verwendete  Adressierungsmodus   oder  die  angesprochene
        Adresse  sind zwar prinzipiell erlaubt,  die Adresse liegt aber
        im  Bereich der Peripherieregister,  die in diesem Zusammenhang
        nicht verwendet werden dÅrfen.
    Argument: 
        keines
         
200 mîgliche Pipeline-Effekte
    Typ: 
        Warnung
    Ursache: 
        Ein  Register wird in einer  Befehlsfolge so verwendet, da· die
        BefehlsausfÅhrung  mîglicherweise  nicht  in der hingeschriebe-
        nen  Form ablaufen  wird. öblicherweise  wird ein  Register be-
        nutzt, bevor der neue Wert zur VerfÅgung steht.
    Argument: 
        das die Verklemmung verursachende Register
         
210 mehrfache Adre·registerbenutzung in einer Anweisung
    Typ: 
        Warnung
    Ursache: 
        Ein  Adre·register wird  in mehreren  Adre·ausdrÅcken eines Be-
        fehls  benutzt. Sofern einer der  beiden AusdrÅcke das Register
        modifiziert,  sind die Ergebnisadressen nicht eindeutig festge-
        legt.
    Argument: 
        das mehrfach verwendete Register
         
220 Speicherstelle ist nicht bitadressierbar
    Typ: 
        Warnung
    Ursache: 
        Mit  einer SFRB-Anweisung  wurde versucht,  eine Speicherstelle
        als  bitadressierbar zu deklarieren, die aufgrund der Architek-
        tur des 8051 nicht bitadressierbar ist.
    Argument: 
        keines
         
230 Stack ist nicht leer
    Typ: 
        Warnung
    Ursache: 
        Am  Ende  eines  Durchlaufes  ist  ein vom Programm definierter
        Stack nicht leer.
    Argument: 
        der Name des Stacks sowie seine Resttiefe
         
240 NUL-Zeichen in Strings, Ergebnis undefiniert
    Typ: 
        Warnung
    Ursache: 
        Eine  String-Konstante enthÑlt  ein NUL-Zeichen.  Dies funktio-
        niert  zwar  mit  der  Pascal-Version,  in  Hinblick auf die C-
        Version  von AS ist dies aber ein Problem, da C Strings mit ei-
        nem  NUL-Zeichen terminiert, d.h. der String wÑre fÅr C an die-
        ser Stelle zu Ende...
    Argument: 
        keines
         
250 Befehl Åberschreitet Seitengrenze
    Typ: 
        Warnung
    Ursache: 
        Ein  Befehl steht  zu Teilen  auf verschiedenen  Seiten. Da der
        ProgrammzÑhler  des  Prozessors  aber  nicht Åber Seitengrenzen
        hinweg  inkrementiert wird, wÅrde zur Laufzeit anstelle des In-
        struktionsbytes  von der  Folgeseite wieder  das erste Byte der
        alten Seite geholt; das Programm wÅrde fehlerhaft ablaufen.
    Argument: 
        keines
         
260 BereichsÅberschreitung
    Typ: 
        Warnung
    Ursache: 
        Ein  Zahlenwert lag  au·erhalb des  erlaubten Bereichs.  AS hat
        den  Wert durch  ein Abschneiden  der oberen  Bitstellen in den
        erlaubten  Bereich  gebracht,  es  ist jedoch nicht garantiert,
        da·  sich durch  diese Operation  sinnvoller und korrekter Code
        ergibt.
    Argument: 
        keines
         
270 negatives Argument fÅr DUP
    Typ: 
        Warnung
    Ursache: 
        Das  Wiederholungsargument einer DUP-Direktive  war kleiner als
        0.  Es werden (analog zu einem  Argument von genau 0) keine Da-
        ten abgelegt.
    Argument: 
        keines
         
280 einzelner  X-Operand wird  als indizierte  und nicht  als implizite
    Adressierung interpretiert
    Typ: 
        Warnung
    Ursache: 
        Ein  einzelner X-Operand kann sowohl als Register X als auch X-
        inidizierte  Adressierung  mit  Null-Displacement interpretiert
        werden,  da sich Morola hier nicht festlegt. AS wÑhlt die letz-
        tere Variante, was mîglicherweise nicht das erwartete ist.
    Argument: 
        keines
         
300 Bit-Nummer wird abgeschnitten werden
    Typ: 
        Warnung
    Ursache: 
        Die   Instruktion  arbeitet   nur  auf   Byte-  bzw.  Langwort-
        Operanden,  Bitnummern jenseits  7 bzw.  31 werden  von der CPU
        modulo-8 bzw. modulo-32 behandelt werden.
    Argument: 
        keines
         
1000 Symbol doppelt definiert
    Typ: 
        Fehler
    Ursache: 
        Einem  Symbol wurde  durch ein  Label oder  EQU, PORT, SFR, LA-
        BEL,  SFRB oder  BIT ein  neuer Wert  zugewiesen, dies ist aber
        nur bei SET/EVAL erlaubt.
    Argument: 
        Name  des fraglichen Symbols,  bei eingeschalteter Querverweis-
        liste zusÑtzlich die Zeile der ersten Definition
         
1010 Symbol nicht definiert
    Typ: 
        Fehler
    Ursache: 
        Ein  benutztes Symbol ist auch im 2.Pass noch nicht in der Sym-
        boltabelle enthalten.
    Argument: 
        Name des nicht gefundenen Symbols
         
1020 UngÅltiger Symbolname
    Typ: 
        Fehler
    Ursache: 
        Ein  Symbolname  entspricht  nicht  den  Bedingungen  fÅr einen
        gÅltigen  Symbolnamen. Beachten Sie,  da· fÅr Makro-und Funkti-
        onsparameter strengere Regeln gelten!
    Argument: 
        der fehlerhafte Symbolname
         
1090 UngÅltiges Format
    Typ: 
        Fehler
    Ursache: 
        Das benutzte Befehlsformat existiert bei diesem Befehl nicht.
    Argument: 
        Der Kennbuchstabe des verwendeten Formates
         
1100 öberflÅssiges Attribut
    Typ: 
        Fehler
    Ursache: 
        Der  benutzte Befehl (Prozessor oder  Pseudo) darf kein mit ei-
        nem Punkt angehÑngtes Attribut haben.
    Argument: 
        keines
         
1105 Attribut darf nur 1 Zeichen lang sein
    Typ: 
        Fehler
    Ursache: 
        Das  mit einem  Punkt an  einen Befehl  angehÑngte Attribut mu·
        genau  ein Zeichen lang  sein; weder mehr  noch weniger ist er-
        laubt.
    Argument: 
        keines
         
1107 undefiniertes Attribut
    Typ: 
        Fehler
    Ursache: 
        Das an einem Befehl angefÅgte Attribut ist ungÅltig.
    Argument: 
        keines
         
1110 Unpassende Operandenzahl
    Typ: 
        Fehler
    Ursache: 
        Die  bei einem  Befehl (Prozessor  oder Pseudo) angegebene Ope-
        randenzahl  liegt nicht in dem  fÅr diesen Befehl erlaubten Be-
        reich.
    Argument: 
        keines
         
1115 Unpassende Optionenzahl
    Typ: 
        Fehler
    Ursache: 
        Die  bei  diesem  Befehl  angegebene  Zahl  von  Optionen liegt
        nicht in dem fÅr diesen Befehl erlaubten Bereich.
    Argument: 
        keines
         
1120 nur immediate-Adressierung erlaubt
    Typ: 
        Fehler
    Ursache: 
        Der  benutzte Befehl lÑ·t nur immediate-Operanden (mit vorange-
        stelltem #) zu.
    Argument: 
        keines
         
1130 Unpassende Operandengrî·e
    Typ: 
        Fehler
    Ursache: 
        Der  Operand hat  zwar einen  fÅr den  Befehl zugelassenen Typ,
        jedoch nicht die richtige LÑnge (in Bits).
    Argument: 
        keines
         
1131 Widersprechende Operandengrî·en
    Typ: 
        Fehler
    Ursache: 
        Die  angegebenen  Operanden  haben  unterschiedliche LÑngen (in
        Bit).
    Argument: 
        keines
         
1132 Undefinierte Operandengrî·e
    Typ: 
        Fehler
    Ursache: 
        Aus  Opcode und  Operanden lÑ·t  sich die  Operandengrî·e nicht
        eindeutig  bestimmen  (ein  Problem  des  8086-Assemblers). Sie
        mÅssen  die Operandengrî·e  durch einen  BYTE, WORD,  usw. PTR-
        PrÑfix festlegen.
    Argument: 
        keines
         
1135 UngÅltiger Operandentyp
    Typ: 
        Fehler
    Ursache: 
        Ein  Ausdruck hat einen  an dieser Stelle  nicht zulÑssigen Typ
        (Integer/Gleitkomma/String).
    Argument: 
        Die an dieser Stelle zulÑssigen Datentypen
         
1140 Zuviele Argumente
    Typ: 
        Fehler
    Ursache: 
        Einem  Befehl wurden mehr als die  unter AS zulÑssigen 20 Para-
        meter Åbergeben.
    Argument: 
        keines
         
1200 Unbekannter Befehl
    Typ: 
        Fehler
    Ursache: 
        Der  benutzte  Befehl  ist  weder  ein Pseudobefehl von AS noch
        ein Befehl des momentan eingestellten Prozessors.
    Argument: 
        keines
         
1300 Klammerfehler
    Typ: 
        Fehler
    Ursache: 
        Der  Formelparser  ist  auf  einen (Teil-)Ausdruck gesto·en, in
        dem   die  Summe  îffnender  und  schlie·ender  Klammern  nicht
        Åbereinstimmt.
    Argument: 
        der beanstandete (Teil-)Ausdruck
         
1310 Division durch 0
    Typ: 
        Fehler
    Ursache: 
        Bei  einer Division  oder Modulooperation  ergab die Auswertung
        des rechten Teilausdruckes 0.
    Argument: 
        keines
         
1315 Bereichsunterschreitung
    Typ: 
        Fehler
    Ursache: 
        Der  angegebene Integer-Wert unterschreitet  den zulÑssigen Be-
        reich.
    Argument: 
        aktueller  Wert  und  zulÑssiges  Minimum (manchmal, ich stelle
        das gerade um...)
         
1320 BereichsÅberschreitung
    Typ: 
        Fehler
    Ursache: 
        Der  angegebene Integer-Wert  Åberschreitet den  zulÑssigen Be-
        reich.
    Argument: 
        aktueller  Wert  und  zulÑssiges  Maximum  (manchmal,ich stelle
        das gerade um...)
         
1325 Adresse nicht ausgerichtet
    Typ: 
        Fehler
    Ursache: 
        Die  angegebene  direkte  Speicheradresse  entspricht nicht den
        AnsprÅchen  des Datentransfers,  d.h. ist  nicht ein mehrfaches
        der  Operandengrî·e. Nicht  alle Prozessoren  erlauben unausge-
        richtete Datenzugriffe.
    Argument: 
        keines
         
1330 Distanz zu gro·
    Typ: 
        Fehler
    Ursache: 
        Der  in  einem  Adre·ausdruck  enthaltene Displacement-Wert ist
        zu gro·.
    Argument: 
        keines
         
1340 Kurzadressierung nicht mîglich
    Typ: 
        Fehler
    Ursache: 
        Die  Adresse des  Operanden liegt  au·erhalb des Speicherberei-
        ches, in dem Kurzadressierung mîglich ist.
    Argument: 
        keines
         
1350 Unerlaubter Adressierungsmodus
    Typ: 
        Fehler
    Ursache: 
        Der  benutzte Adressierungsmodus  existiert generell  zwar, ist
        an dieser Stelle aber nicht erlaubt.
    Argument: 
        keines
         
1351 Nummer mu· ausgerichtet sein
    Typ: 
        Fehler
    Ursache: 
        An  dieser  Stelle  sind  nur  ausgerichtete  (d.h z.B. gerade)
        Adressen  erlaubt, da die untersten Bits fÅr andere Zwecke ver-
        wendet werden oder reserviert sind.
    Argument: 
        keines
         
1355 Adressierungsmodus im Parallelbetrieb nicht erlaubt
    Typ: 
        Fehler
    Ursache: 
        Die  verwendeten Adressierungsmodi  sind zwar  im sequentiellen
        Modus zulÑssig, jedoch nicht bei parallelen Instruktionen.
    Argument: 
        keines
         
1360 Undefinierte Bedingung
    Typ: 
        Fehler
    Ursache: 
        Die benutzte Bedingung fÅr bedingte SprÅnge existiert nicht.
    Argument: 
        keines
         
1365 inkompatible Bedingungen
    Typ: 
        Fehler
    Ursache: 
        Die  benutzte Kombination  von Bedingungen  kann nicht in einem
        Befehl verwendet werden.
    Argument: 
        die Bedingung, bei der die UnvertrÑglichkeit entdeckt wurde.
         
1370 Sprungdistanz zu gro·
    Typ: 
        Fehler
    Ursache: 
        Sprungbefehl  und  Sprungziel  liegen  zu  weit auseinander, um
        mit  einem  Sprung  der  benutzten  LÑnge  ÅberbrÅckt werden zu
        kînnen.
    Argument: 
        keines
         
1375 Sprungdistanz ist ungerade
    Typ: 
        Fehler
    Ursache: 
        Da  Befehle nur  auf geraden  Adressen liegen  dÅrfen, mu· eine
        Sprungdistanz  zwischen zwei  Befehlen auch  immer gerade sein,
        das  Bit 0 der Distanz wird anderweitig verwendet. Diese Bedin-
        gung  ist verletzt  worden. Grund  ist Åblicherweise die Ablage
        einer  ungeraden Anzahl  von Daten  in Bytes  oder ein falsches
        ORG.
    Argument: 
        keines
         
1380 ungÅltiges Schiebeargument
    Typ: 
        Fehler
    Ursache: 
        als  Argument fÅr die Schiebeamplitude  darf nur eine Konstante
        oder ein Datenregister verwendet werden. (nur 680x0)
    Argument: 
        keines
         
1390 Nur Bereich 1..8 erlaubt
    Typ: 
        Fehler
    Ursache: 
        Konstanten  fÅr  Schiebeamplituden  oder  ADDQ-Argumente dÅrfen
        nur im Bereich 1..8 liegen. (nur 680x0)
    Argument: 
        keines
         
1400 Schiebezahl zu gro·
    Typ: 
        Fehler
    Ursache: 
        (nicht mehr verwendet)
    Argument: 
        keines
         
1410 UngÅltige Registerliste
    Typ: 
        Fehler
    Ursache: 
        Das  Registerlisten-Argument  von  MOVEM  oder  FMOVEM  hat ein
        falsches Format. (nur 680x0)
    Argument: 
        keines
         
1420 UngÅltiger Modus mit CMP
    Typ: 
        Fehler
    Ursache: 
        Die  verwendete  Operandenkombination  von  CMP  ist  nicht er-
        laubt. (nur 680x0)
    Argument: 
        keines
         
1430 UngÅltiger Prozessortyp
    Typ: 
        Fehler
    Ursache: 
        Den mit CPU angeforderten Zielprozessor kennt AS nicht.
    Argument: 
        der unbekannte Prozessortyp
         
1440 UngÅltiges Kontrollregister
    Typ: 
        Fehler
    Ursache: 
        Das  bei  z.B.  MOVEC  benutzte  Kontrollregister kennt der mit
        CPU gesetzte Prozessor (noch) nicht.
    Argument: 
        keines
         
1445 UngÅltiges Register
    Typ: 
        Fehler
    Ursache: 
        Das  benutzte  Register  ist  zwar  prinzipiell vorhanden, hier
        aber nicht erlaubt.
    Argument: 
        keines
         
1450 RESTORE ohne SAVE
    Typ: 
        Fehler
    Ursache: 
        Es  wurde ein RESTORE-Befehl gefunden, obwohl kein mit SAVE ge-
        speicherter Zustand (mehr) auf dem Stapel vorhanden ist.
    Argument: 
        keines
         
1460 fehlendes RESTORE
    Typ: 
        Fehler
    Ursache: 
        Nach  der  Assemblierung  sind  nicht  alle SAVE-Befehle wieder
        aufgelîst worden.
    Argument: 
        keines
         
1465 unbekannte Makro-Steueranweisung
    Typ: 
        Fehler
    Ursache: 
        Eine  beim  MACRO-Befehl  zusÑtzlich angegebene Steueranweisung
        ist AS unbekannt.
    Argument: 
        die fragliche Anweisung
         
1470 fehlendes ENDIF/ENDCASE
    Typ: 
        Fehler
    Ursache: 
        Nach  der Assemblierung sind nicht  alle Konstrukte zur beding-
        ten Assemblierung aufgelîst worden.
    Argument: 
        keines
         
1480 ungÅltiges IF-Konstrukt
    Typ: 
        Fehler
    Ursache: 
        Die   Reihenfolge  der  Befehle  in   einem  IF-  oder  SWITCH-
        Konstrukt stimmt nicht.
    Argument: 
        keines
         
1483 doppelter Sektionsname
    Typ: 
        Fehler
    Ursache: 
        Es  existiert bereits  eine Sektion  gleichen Namens auf dieser
        Ebene.
    Argument: 
        der doppelte Name
         
1484 unbekannte Sektion
    Typ: 
        Fehler
    Ursache: 
        Im  momentanen  Sichtbarkeitsbereich  existiert  keine  Sektion
        dieses Namens.
    Argument: 
        der unbekannte Name
         
1485 fehlendes ENDSECTION
    Typ: 
        Fehler
    Ursache: 
        Nach  Ende eines  Durchganges sind  nicht alle Sektionen wieder
        geschlossen worden.
    Argument: 
        keines
         
1486 falsches ENDSECTION
    Typ: 
        Fehler
    Ursache: 
        die  bei ENDSECTION  angegebene Sektion  ist nicht die innerste
        offene.
    Argument: 
        keines
         
1487 ENDSECTION ohne SECTION
    Typ: 
        Fehler
    Ursache: 
        Es  wurde ein ENDSECTION-Befehl gegeben,  obwohl gar keine Sek-
        tion offen war.
    Argument: 
        keines
         
1488 nicht aufgelîste VorwÑrtsdeklaration
    Typ: 
        Fehler
    Ursache: 
        ein  mit FORWARD  oder PUBLIC  angekÅndigtes Symbol wurde nicht
        in der Sektion definiert.
    Argument: 
        der Name des fraglichen Symbols
         
1489 widersprechende FORWARD <->PUBLIC-Deklaration
    Typ: 
        Fehler
    Ursache: 
        Ein Symbol wurde sowohl als privat als auch global definiert.
    Argument: 
        der Name des Symbols
         
1490 falsche Argumentzahl fÅr Funktion
    Typ: 
        Fehler
    Ursache: 
        Die  Anzahl  der  Argumente  fÅr eine selbstdefinierte Funktion
        stimmt nicht mit der geforderten Anzahl Åberein.
    Argument: 
        keines
         
1495 unaufgelîste Literale (LTORG fehlt)
    Typ: 
        Fehler
    Ursache: 
        Am  Programmende oder beim Umachalten zu einem anderen Zielpro-
        zessor blieben noch nicht abgelegte Literale Åbrig.
    Argument: 
        keines
         
1500 Befehl auf dem ... nicht vorhanden
    Typ: 
        Fehler
    Ursache: 
        Der  benutzte Befehl  existiert zwar  grundsÑtzlich, das einge-
        stellte  Mitglied  der  Prozessorfamilie  beherrscht  ihn  aber
        noch nicht.
    Argument: 
        keines
         
1505 Adressierungsart auf dem ... nicht vorhanden
    Typ: 
        Fehler
    Ursache: 
        Der  benutzte Adressierungsmodus  existiert zwar grundsÑtzlich,
        das  eingestellte Mitglied der  Prozessorfamilie beherrscht ihn
        aber noch nicht.
    Argument: 
        keines
         
1510 UngÅltige Bitstelle
    Typ: 
        Fehler
    Ursache: 
        Die  angegebene Bitnummer  ist nicht  erlaubt oder  eine Angabe
        fehlt komplett.
    Argument: 
        keines
         
1520 nur ON/OFF erlaubt
    Typ: 
        Fehler
    Ursache: 
        Dieser Pseudobefehl darf als Argument nur ON oder OFF haben.
    Argument: 
        keines
         
1530 Stack ist leer oder nicht definiert
    Typ: 
        Fehler
    Ursache: 
        Es  wurde bei einem  POPV einen Stack  anzusprechen, der entwe-
        der nie definiert oder bereits leergerÑumt wurde.
    Argument: 
        der Name des fraglichen Stacks
         
1540 Nicht genau ein Bit gesetzt
    Typ: 
        Fehler
    Ursache: 
        In  einer Bitmaske,  die der  BITPOS- Funktion Åbergeben wurde,
        war nicht genau ein Bit gesetzt.
    Argument: 
        keines
         
1550 ENDSTRUCT ohne STRUCT
    Typ: 
        Fehler
    Ursache: 
        Eine  ENDSTRUCT-Anweisung wurde gegeben,  obwohl momentan keine
        Strukturdefinition in Gange war.
    Argument: 
        keines
         
1551 offene Strukturdefinition
    Typ: 
        Fehler
    Ursache: 
        Nach  Ende  der  Assemblierung  waren  noch  nicht alle STRUCT-
        Anweisungen durch passende ENDSTRUCTs abgeschlossen.
    Argument: 
        die innerste, noch nicht abgeschlossene Strukturdefinition
         
1552 falsches ENDSTRUCT
    Typ: 
        Fehler
    Ursache: 
        Der   Namensparameter   einer   ENDSTRUCT-Anweisung  entspricht
        nicht der innersten, offenen Strukturdefinition.
    Argument: 
        keines
         
1553 Phasendefinition nicht in Strukturen erlaubt
    Typ: 
        Fehler
    Ursache: 
        Was  gibt es dazu  zu sagen? PHASE  in einem Record ergibt ein-
        fach keinen Sinn und nur Verwirrung...
    Argument: 
        keines
         
1554 ungÅltige STRUCT-Direktive
    Typ: 
        Fehler
    Ursache: 
        Als  Direktive fÅr STRUCT ist  nur EXTNAMES oder NOEXTNAMES zu-
        gelassen.
    Argument: 
        die unbekannte Direktive
         
1560 Anweisung nicht wiederholbar
    Typ: 
        Fehler
    Ursache: 
        Diese  Maschinenanweisung  kann  nicht  mit  Hilfe  eines  RPT-
        Konstruktes wiederholt werden.
    Argument: 
        keines
         
1600 vorzeitiges Dateiende
    Typ: 
        Fehler
    Ursache: 
        Es  wurde mit einem BINCLUDE-Befehl versucht, Åber das Ende ei-
        ner Datei hinauszulesen.
    Argument: 
        keines
         
1700 ROM-Offset geht nur von 0..63
    Typ: 
        Fehler
    Ursache: 
        Das  Konstanten-ROM  der  680x0-Koprozessoren  hat  nur max. 63
        EintrÑge.
    Argument: 
        keines
         
1710 UngÅltiger Funktionscode
    Typ: 
        Fehler
    Ursache: 
        Als  Funktionscodeargument  darf  nur  SFC, DFC, ein Datenregi-
        ster  oder  eine  Konstante  von  0..15  verwendet werden. (nur
        680x0-MMU)
    Argument: 
        keines
         
1720 UngÅltige Funktionscodemaske
    Typ: 
        Fehler
    Ursache: 
        Als  Funktionscodemaske darf  nur ein  Wert von 0..15 verwendet
        werden. (nur 680x0-MMU)
    Argument: 
        keines
         
1730 UngÅltiges MMU-Register
    Typ: 
        Fehler
    Ursache: 
        Die  MMU  hat  kein  Register  mit  dem angegebenen Namen. (nur
        680x0-MMU)
    Argument: 
        keines
         
1740 Level nur von 0..7
    Typ: 
        Fehler
    Ursache: 
        Die  Ebene fÅr  PTESTW und  PTESTR mu·  eine Konstante von 0..7
        sein. (nur 680x0-MMU)
    Argument: 
        keines
         
1750 ungÅltige Bitmaske
    Typ: 
        Fehler
    Ursache: 
        Die  bei  den  Bit-Feld-Befehlen  angegebene  Bitmaske  hat ein
        falsches Format. (nur 680x0)
    Argument: 
        keines
         
1760 ungÅltiges Registerpaar
    Typ: 
        Fehler
    Ursache: 
        Das  angegebene  Registerpaar  ist  hier  nicht verwendbar oder
        syntaktisch falsch. (nur 680x0)
    Argument: 
        keines
         
1800 offene Makrodefinition
    Typ: 
        Fehler
    Ursache: 
        Eine  Makrodefinition  war  am  Dateiende nicht zuende. Vermut-
        lich fehlt ein ENDM.
    Argument: 
        keines
         
1805 EXITM au·erhalb eines Makrorumpfes
    Typ: 
        Fehler
    Ursache: 
        EXITM  bricht  die  Expansion  von Makro-Konstrukten ab. Dieser
        Befehl  macht nur innerhalb  von Makros Sinn  und es wurde ver-
        sucht, ihn au·erhalb aufzurufen.
    Argument: 
        keines
         
1810 mehr als 10 Makroparameter
    Typ: 
        Fehler
    Ursache: 
        Ein Makro darf hîchstens 10 Parameter haben.
    Argument: 
        keines
         
1815 doppelte Makrodefinition
    Typ: 
        Fehler
    Ursache: 
        Ein Makronamne wurde in einer Sektion doppelt vergeben.
    Argument: 
        der doppelt verwendete Name
         
1820 Ausdruck mu· im ersten Pass berechenbar sein
    Typ: 
        Fehler
    Ursache: 
        Der  benutzte  Befehl  beeinflu·t  die  CodelÑnge,  daher  sind
        VorwÑrtsreferenzen hier nicht erlaubt.
    Argument: 
        keines
         
1830 zu viele verschachtelte IFs
    Typ: 
        Fehler
    Ursache: 
        (nicht mehr verwendet)
    Argument: 
        keines
         
1840 ELSEIF/ENDIF ohne ENDIF
    Typ: 
        Fehler
    Ursache: 
        es  wurde ein  ELSEIF- oder  ENDIF-Befehl gefunden, obwohl kein
        offener IF-Befehl vorhanden ist.
    Argument: 
        keines
         
1850 verschachtelter/rekursiver Makroaufruf
    Typ: 
        Fehler
    Ursache: 
        (nicht mehr verwendet)
    Argument: 
        keines
         
1860 unbekannte Funktion
    Typ: 
        Fehler
    Ursache: 
        Die   angesprochene   Funktion   ist   weder   eingebaut   noch
        nachtrÑglich definiert worden.
    Argument: 
        der Funktionsname
         
1870 Funktionsargument au·erhalb Definitionsbereich
    Typ: 
        Fehler
    Ursache: 
        Das  Argument liegt  nicht im  Bereich der angesprochenen tran-
        szendenten Funktion.
    Argument: 
        keines
         
1880 GleitkommaÅberlauf
    Typ: 
        Fehler
    Ursache: 
        Das  Argument liegt  zwar im  Bereich der  angesprochenen tran-
        szendenten  Funktion, das  Ergebnis wÑre  aber nicht  mehr dar-
        stellbar.
    Argument: 
        keines
         
1890 ungÅltiges Wertepaar
    Typ: 
        Fehler
    Ursache: 
        Das  benutzte PÑrchen aus Basis und Exponent kann nicht berech-
        net werden.
    Argument: 
        keines
         
1900 Befehl darf nicht auf dieser Adresse liegen
    Typ: 
        Fehler
    Ursache: 
        Die  Prozessorhardware erlaubt keine  SprÅnge von dieser Adres-
        se.
    Argument: 
        keines
         
1905 ungÅltiges Sprungziel
    Typ: 
        Fehler
    Ursache: 
        Die  Prozessorhardware erlaubt  keine SprÅnge  zu dieser Adres-
        se.
    Argument: 
        keines
         
1910 Sprungziel nicht auf gleicher Seite
    Typ: 
        Fehler
    Ursache: 
        Sprungbefehl  und Sprungziel  mÅssen bei  diesem Befehl auf der
        gleichen Seite liegen.
    Argument: 
        keines
         
1920 CodeÅberlauf
    Typ: 
        Fehler
    Ursache: 
        Es  wurde versucht, mehr als 1024  Bytes Code oder Daten in ei-
        ner Zeile zu erzeugen.
    Argument: 
        keines
         
1925 Adre·Åberlauf
    Typ: 
        Fehler
    Ursache: 
        Der Adre·raum dieses Prozessors wurde Åberschritten.
    Argument: 
        keines
         
1930 Konstanten und Platzhalter nicht mischbar
    Typ: 
        Fehler
    Ursache: 
        Anweisungen,  die Speicher reservieren und  solche, die ihn mit
        Konstanten  belegen, dÅrfen nicht  in einer Pseudoanweisung ge-
        mischt werden.
    Argument: 
        keines
         
1940 Codeerzeugung in Strukturdefinition nicht zulÑssig
    Typ: 
        Fehler
    Ursache: 
        Ein  STRUCT-Konstrukt dient  nur der  Beschreibung einer Daten-
        struktur  und nicht  dem Anlegen  einer solchen,  es sind daher
        keine Befehle zugelassen, die Code erzeugen.
    Argument: 
        keines
         
1950 Paralleles Konstrukt nicht mîglich
    Typ: 
        Fehler
    Ursache: 
        Entweder  sind die beiden  Instruktionen prinzipiell nicht par-
        allel  ausfÅhrbar, oder sie  stehen nicht unmittelbar unterein-
        ander.
    Argument: 
        keines
         
1960 ungÅltiges Segment
    Typ: 
        Fehler
    Ursache: 
        Das angegebene Segment ist an dieser Stelle nicht anwendbar.
    Argument: 
        der benutzte Segmentname
         
1961 unbekanntes Segment
    Typ: 
        Fehler
    Ursache: 
        Das angegebene Segment existiert bei diesem Prozessor nicht.
    Argument: 
        der benutzte Segmentname
         
1962 unbekanntes Segmentregister
    Typ: 
        Fehler
    Ursache: 
        Das angegebene Segmentregister existiert nicht (nur 8086).
    Argument: 
        keines
         
1970 ungÅltiger String
    Typ: 
        Fehler
    Ursache: 
        Der angegebene String hat ein ungÅltiges Format.
    Argument: 
        keines
         
1980 ungÅltiger Registername
    Typ: 
        Fehler
    Ursache: 
        Das  angegebene Register  existiert nicht  oder darf hier nicht
        verwendet werden.
    Argument: 
        keines
         
1985 ungÅltiges Argument
    Typ: 
        Fehler
    Ursache: 
        Der  angegebene Befehl  darf nicht  mit einem REP-PrÑfix verse-
        hen werden.
    Argument: 
        keines
         
1990 keine Indirektion erlaubt
    Typ: 
        Fehler
    Ursache: 
        in  dieser  Kombination  ist  keine  indirekte Adressierung er-
        laubt.
    Argument: 
        keines
         
1995 nicht im aktuellen Segment erlaubt
    Typ: 
        Fehler
    Ursache: 
        (nicht mehr verwendet)
    Argument: 
        keines
         
1996 nicht im Maximum-Modus zulÑssig
    Typ: 
        Fehler
    Ursache: 
        Dieses Register ist nur im Minimum-Modus definiert.
    Argument: 
        keines
         
1997 nicht im Minimum-Modus zulÑssig
    Typ: 
        Fehler
    Ursache: 
        Dieses Register ist nur im Maximum-Modus definiert.
    Argument: 
        keines
         
2000 Anweisungspaket Åberschreitet Adre·grenze
    Typ: 
        Fehler
    Ursache: 
        Ein  Anweisungspaket dard  nicht Åber  eine 32-Byte-Adre·grenze
        reichen.
    Argument: 
        keines
         
2001 AusfÅhrungseinheit mehrfach benutzt
    Typ: 
        Fehler
    Ursache: 
        Eine  der  AusfÅhrungseinheiten  des  Prozessors wurde in einem
        Anweisungspaket mehrfach benutzt.
    Argument: 
        der Name der Funktionseinheit
         
2002 mehrfache Lang-Leseoperation
    Typ: 
        Fehler
    Ursache: 
        Ein    AusfÅhrungspaket   enthÑlt    mehr   als    eine   Lang-
        Leseoperation, was nicht erlaubt ist.
    Argument: 
        eine    der   Funktionseinheiten,   auf    denen   eine   Lang-
        Leseoperation ausgefÅhrt wird
         
2003 mehrfache Lang-Schreiboperation
    Typ: 
        Fehler
    Ursache: 
        Ein    AusfÅhrungspaket   enthÑlt    mehr   als    eine   Lang-
        Schreiboperation, was nicht erlaubt ist.
    Argument: 
        eine    der   Funktionseinheiten,   auf    denen   eine   Lang-
        Schreiboperation ausgefÅhrt wird
         
2004 Lang-Lese- mit Schreiboperation
    Typ: 
        Fehler
    Ursache: 
        Ein  AusfÅhrungspaket  enthÑlt  sowohl  eine Lang-Leseoperation
        als auch eine Schreiboperation, was nicht erlaubt ist.
    Argument: 
        eine  der  Funktionseinheiten,  deren  Operationen  im Konflikt
        stehen.
         
2005 zu viele Lesezugriffe auf ein Register
    Typ: 
        Fehler
    Ursache: 
        Auf  das gleiche  Register wurde  mehr als  viermal im gleichen
        Anweisungspaket Bezug genommen.
    Argument: 
        der Name des Registers, das zu oft referenziert wurde
         
2006 Åberlappende Ziele
    Typ: 
        Fehler
    Ursache: 
        Auf   das   gleiche   Register   wurde   mehrfach  im  gleichen
        AusfÅhrungspaket geschrieben, was nicht erlaubt ist.
    Argument: 
        der Name der fraglichen Registers
         
2008 zu viele absolute SprÅnge in einem Anweisungspaket
    Typ: 
        Fehler
    Ursache: 
        Ein   Anweisungspaket  beinhaltet   mehr  als   einen  direkten
        Sprung, was nicht erlaubt ist.
    Argument: 
        keines
         
2009 Anweisung nicht auf diese Funktionseinheit ausfÅhrbar
    Typ: 
        Fehler
    Ursache: 
        Diese  Anweisung  kann  nicht  auf dieser Funktionseinheit aus-
        gefÅhrt werden.
    Argument: 
        none
         
2010 UngÅltige Escape-Sequenz
    Typ: 
        Fehler
    Ursache: 
        Das  mit einem  Backslash eingeleitete  Sonderzeichen ist nicht
        definiert.
    Argument: 
        keines
         
2020 ungÅltige PrÑfix-Kombination
    Typ: 
        Fehler
    Ursache: 
        Die  angegebene  Kombination  von  PrÑfixen  ist nicht zulÑssig
        oder nicht im Maschinenkode darstellbar.
    Argument: 
        keines
         
2030 Konstante kann nicht als Variable redefiniert werden
    Typ: 
        Fehler
    Ursache: 
        Ein einmal mit EQU als Konstante
        definiertes Symbol kann nicht nachtrÑglich mit
        SET verÑndert werden.
    Argument: 
        der Name des fraglichen Symbols
         
2035 Variable kann nicht als Konstante redefiniert werden
    Typ: 
        Fehler
    Ursache: 
        Ein einmal mit SET als Variable
        definiertes Symbol kann nicht nachtrÑglich als
        Konstante deklariert werden (z.B. mit EQU.
    Argument: 
        der Name des fraglichen Symbols
         
2040 Strukturname fehlt
    Typ: 
        Fehler
    Ursache: 
        Bei  einer  Strukturdefinition  fehlt  der zugehîrende Name fÅr
        die Struktur.
    Argument: 
        keines
         
2050 leeres Argument
    Typ: 
        Fehler
    Ursache: 
        In  der  Argumentenliste  dieser  Anweisung  dÅrfen keine Leer-
        strings benutzt werden.
    Argument: 
        keines
         
10001 Fehler bein ôffnen der Datei
    Typ: 
        fatal
    Ursache: 
        Beim  Versuch, eine Datei  zu îffnen, ist  ein Fehler aufgetre-
        ten.
    Argument: 
        Beschreibung des E/A-Fehlers
         
10002 Listingschreibfehler
    Typ: 
        fatal
    Ursache: 
        Beim  Schreiben des Assemblerlistings  ist ein Fehler aufgetre-
        ten.
    Argument: 
        Beschreibung des E/A-Fehlers
         
10003 Dateilesefehler
    Typ: 
        fatal
    Ursache: 
        Beim Lesen aus einer Quelldatei ist ein Fehler aufgetreten.
    Argument: 
        Beschreibung des E/A-Fehlers
         
10004 Dateischreibfehler
    Typ: 
        fatal
    Ursache: 
        Beim  Schreiben von Code- oder  Share-Datei ist ein Fehler auf-
        getreten.
    Argument: 
        Beschreibung des E/A-Fehlers
         
10006 SpeicherÅberlauf
    Typ: 
        fatal
    Ursache: 
        Der  verfÅgbare Speicher reicht  nicht mehr, alle Datenstruktu-
        ren  aufzunehmen. Weichen  Sie auf  die DPMI- oder OS/2-Version
        von AS aus.
    Argument: 
        keines
         
10007 StapelÅberlauf
    Typ: 
        fatal
    Ursache: 
        Der  Programmstapel ist wegen  zu komplizierter FormelausdrÅcke
        oder  einer  ungÅnstigen  Anlage  der Symbol- oder Makrotabelle
        Åbergelaufen. Versuchen Sie es noch einmal mit der -A-Option.
    Argument: 
        keines
         



        B. E/A-Fehlermeldungen
        ======================

Die  hier aufgelisteten Fehlermeldungen werden nicht  nur von AS bei E/
A-  Fehlern  ausgegeben,  sondern  auch  von den Hilfsprogrammen PLIST,
BIND,  P2HEX und P2BIN. Es sind nur  die Fehler nÑher erklÑrt, die m.E.
bei   der  Arbeit  auftreten  kînnen.  Sollte  doch  einmal  ein  nicht
erlÑuterter  E/A-Fehler auftreten,  so dÅrfte  der Grund  in einem Pro-
grammfehler liegen. Melden Sie dies unbedingt!!


  2 Datei nicht gefunden
    Die  angegebene Datei existiert nicht  oder liegt auf einem anderen
    Laufwerk.
  3 Pfad nicht gefunden
    Der  Pfad eines  Dateinamens existiert  nicht oder  liegt auf einem
    anderen Laufwerk.
  4 zu viele offene Dateien
    DOS  sind  die  Dateihandles  ausgegangen.  Erhîhen Sie die FILES=-
    Angabe in der CONFIG.SYS.
  5 Dateizugriff verweigert
    Entweder  reichen die Netzwerkrechte  fÅr einen Dateizugriff nicht,
    oder   es   wurde   versucht,   eine   schreibgeschÅtzte  Datei  zu
    Åberschreiben  oder zu  verÑndern. Bei  Benutzung in  DOS- Fenstern
    von  Multitasking- Systemen ist es  Åberdies mîglich, da· ein ande-
    re Proze· die Datei in exklusivem Zugriff hat.
  6 ungÅltiger Dateihandle
 12 ungÅltiger Zugriffsmodus
 15 ungÅltiger Laufwerksbuchstabe
    Das angesprochene Laufwerk existiert nicht.
 16 aktuelles Verzeichnis kann nicht gelîscht werden
 17 RENAME geht nicht Åber Laufwerke
100 vorzeitiges Dateiende
    Eine  Datei war zuende, obwohl sie  es aufgrund ihrer Struktur noch
    nicht sein dÅrfte. Vermutlich ist sie beschÑdigt.
101 Diskette/Platte voll
    Das spricht wohl fÅr sich! AufrÑumen!!
102 ASSIGN fehlt
103 Datei nicht offen
104 Datei nicht fÅr Einlesen offen
105 Datei nicht fÅr Ausgaben offen
106 UngÅltiges numerisches Format
150 Diskette ist schreibgeschÅtzt
    Wenn  Sie schon  keine Festplatte  als Arbeitsmedium  verwenden, so
    sollten Sie wenigstens den Schreibschutz entfernen!
151 Unbekanntes GerÑt
    Sie  haben versucht, ein  PeripheriegerÑt anzusprechen, welches DOS
    unbekannt  ist. Dies  sollte normalerweise  nicht auftreten, da der
    Name dann automatisch als Datei interpretiert wird.
152 Laufwerk nicht bereit
    Schlie·en Sie die Klappe des Diskettenlaufwerks.
153 unbekannte DOS-Funktion
154 PrÅfsummenfehler auf Diskette/Platte
    Ein  harter Lesefehler  auf der  Diskette. Nochmal  versuchen; wenn
    immer  noch vorhanden, Diskette neu  formatieren bzw. ernste Sorgen
    um Festplatte machen!
155 ungÅltiger DPB
156 Positionierfehler
    Der  Platten/Disketten-Controller hat eine bestimmte Spur nicht ge-
    funden. Siehe Nr. 154!
157 unbekanntes Sektorformat
    DOS kann mit dem Format der Diskette nichts anfangen.
158 Sektor nicht gefunden
    Analog  zu Nr.  158, nur  da· hier  der angeforderte Sektor auf der
    Spur nicht gefunden werden konnte.
159 Papierende
    Offensichtlich  haben  Sie  die  Ausgaben  von  AS direkt auf einen
    Drucker umgeleitet. Assemblerlistings kînnen seeehr lang sein...
160 GerÑtelesefehler
    Nicht nÑher vom GerÑtetreiber klassifizierter Lesefehler.
161 GerÑteschreibfehler
    Nicht nÑher vom GerÑtetreiber klassifizierter Schreibfehler.
162 allgemeiner GerÑtefehler
    Hier  ist  der  GerÑtetreiber  vîllig  ratlos,  was  passiert  sein
    kînnte.



        C. HÑufig gestellte Fragen
        ==========================

In  diesem Kapitel habe ich  versucht, einige besonders hÑufig gestell-
te  Fragen mit  den passenden  Antworten zu  sammeln. Die Antworten auf
die  hier auftauchenden Probleme finden sich zwar auch an anderer Stel-
le  in der  Anleitung, jedoch  findet man  sie vielleicht nicht auf den
ersten Blick...


 F: Ich bin DOS leid. FÅr welche Plattformen gibt es AS sonst ?
 A: Neben  der Protected-Mode-Version,  die AS  unter DOS mehr Speicher
    zur  VerfÅgung stellt,  existieren Portierungen  fÅr OS/2 und Unix-
    Systeme  wie z.B. Linux  (im Teststadium). An  Versionen, die Soft-
    wareherstellern  in Redmond  beim Geldscheffeln  zuarbeiten wÅrden,
    ist  momentan nicht  gedacht. Sofern  jemand anders  in dieser Hin-
    sicht  aktiv werden will, stelle ich  ihm aber gerne die AS-Quellen
    zur  VerfÅgung, von  denen sich  die C-Variante insbesondere eignen
    dÅrfte.  öber Fragen zu  diesen Quellen hinaus  sollte er sich aber
    nicht viel von mir erwarten...
 F: Ist eine UnterstÅtzung des XYZ-Prozessors fÅr AS geplant?
 A: Es  kommen immer neue Prozessoren heraus,  und ich bemÅhe mich, bei
    Erweiterung  von  AS  Schritt  zu  halten.  Der Stapel mit der Auf-
    schrift   ,,Unerledigt''  auf  meinem  Schreibtisch  unterschreitet
    aber  selten die 10cm-Grenze... Bei  der Planung, welche Kandidaten
    zuerst   abgearbeitet   werden,   spielen   WÅnsche  von  Anwendern
    natÅrlich  eine gro·e  Rolle. Das  Internet und  die steigende Zahl
    elektronisch  publizierter  Dokumentation  erleichtern die Beschaf-
    fung  von Unterlagen,  speziell bei  ausgefallenen oder Ñlteren Ar-
    chitekturen  wird  es  aber  immer  wieder schwierig. Wenn sich die
    fragliche  Prozessorfamilie nicht in der Liste in Planung befindli-
    cher  Prozessoren befindet  (siehe Kapitel  1), macht  es sich sehr
    gut,  der  Anfrage  auch  gleich  ein  passendes Datenbuch hinzuzu-
    packen (zur Not auch leihweise!).
 F: Ein  freier  Assembler  ist  ja  eine  feine Sache, aber eigentlich
    brÑuchte  ich jetzt auch noch einen Disassembler...und einen Debug-
    ger...ein Simulator wÑre auch ganz nett..
 A: AS  ist ein  Freizeitprojekt von  mir, d.h.  etwas, was  ich in der
    Zeit  tue, wenn  ich mich  nicht gerade  um den Broterwerb kÅmmere.
    Von  dieser Zeit  nimmt AS  schon einen  ganz erheblichen Teil ein,
    und  ab und  zu genehmige  ich mir  auch mal  eine Auszeit,  um den
    Lîtkolben  zu schwingen, mal wieder eine Tangerine Dream-Platte be-
    wu·t  zu hîren, mich  vor den Fernseher  zu hocken oder einfach nur
    dringenden  menschlichen BedÅrfnissen nachzugehen.  Ich habe einmal
    angefangen,  einen Disassembler zu konzipieren, der wieder voll re-
    assemblierbaren  Code  erzeugt  und  automatisch  Daten-  und Code-
    Bereiche  trennt, habe das Projekt aber relativ schnell wieder ein-
    gestellt,  weil die restliche Zeit fÅr  so etwas einfach nicht mehr
    reicht.  Ich mache  lieber eine  Sache gut  als ein  halbes Dutzend
    mÑ·ig. Von daher mu· die Antwort also wohl ,,nein'' hei·en...
 F: In  den  Bildschirmausgaben  von  AS  tauchen seltsame Zeichen auf,
    z.B. Pfeile und eckige Klammern. Warum?
 A: AS  verwendet  zur  Bildschirmsteuerung  defaultmÑ·ig  einige ANSI-
    Terminal-Steuersequenzen.  Haben  Sie  keinen  ANSI-Treiber instal-
    liert,  so kommen  diese Steuerzeichen  ungefiltert auf Ihrem Bild-
    schirm  heraus. Installieren  Sie entweder  einen ANSI-Treiber oder
    schalten  Sie die Steuersequenzen mit  dem DOS-Befehl SET USEANSI=N
    ab.
 F: WÑhrend  der Assemblierung bricht AS  plîtzlich mit der Meldung ei-
    nes StapelÅberlaufes ab. Ist mein Programm zu kompliziert?
 A: Ja  und Nein. Die Symboltabelle fÅr  Ihr Programm ist nur etwas un-
    regelmÑ·ig  gewachsen, was zu zu  hohen Rekursionstiefen im Zugriff
    auf  die Tabelle gefÅhrt hat.  Diese Fehler treten insbesondere bei
    der  16-Bit-OS/2-Version  von  AS  auf,  die nur Åber einen relativ
    kleinen  Stack  verfÅgt.  Starten  Sie  AS  noch einmal mit dem -A-
    Kommandozeilenschalter.  Hilft  dies  auch  nicht,  so  kommen  als
    mîgliche  Problemstellen  noch  zu  komplizierte FormelausdrÅcke in
    Frage.  Versuchen Sie  in einem  solchen Fall,  die Formel  in Zwi-
    schenschritte aufzuspalten.
 F: AS  scheint mein Programm  nicht bis zum  Ende zu assemblieren. Mit
    einer Ñlteren Version von AS (1.39) hat es dagegen funktioniert.
 A: Neuere  Versionen von  AS ignorieren  das END-Statement nicht mehr,
    sondern  beenden  danach  wirklich  die Assemblierung. Insbesondere
    bei  Include-Dateien ist  es frÅher  vorgekommen, da· Anwender jede
    Datei  mit  einem  END-Statement  beendet  haben. Entfernen Sie die
    ÅberflÅssigen ENDs.
 F: Weil  ich  noch  ein  paar  kompliziertere Assemblierfehler im Pro-
    gramm  hatte, habe ich mir ein Listing gemacht und es einmal genau-
    er  angeschaut.  Dabei  ist  mir  aufgefallen,  da·  einige SprÅnge
    nicht auf das gewÅnschte Ziel, sondern auf sich selbst zeigen!
 A: Dieser  Effekt tritt bei  VorwÑrtssprÅngen auf, bei  denen der For-
    melparser  von AS im ersten Pass  die Zieladresse noch nicht kennen
    kann.  Da der Formelparser ein unabhÑngiges  Modul ist, mu· er sich
    in  einem  solchen  Fall  einen  Wert ausdenken, der auch relativen
    SprÅngen  mit kurzer Reichweite nicht wehtut, und dies ist nun ein-
    mal  die  aktuelle  ProgrammzÑhleradresse  selber...im zweiten Pass
    wÑren  die korrekten Werte erschienen, aber  zu diesem ist es nicht
    gekommen,  da schon  im ersten  Pass Fehler  auftraten. Korrigieren
    Sie  die anderen Fehler  zuerst, so da·  AS zum zweiten Pass kommt,
    und das Listing sollte wieder vernÅnftiger aussehen.
 F: Mein  Programm wird  zwar korrekt  assembliert, bei  der Umwandlung
    mit P2BIN oder P2HEX erhalte ich aber nur eine leere Datei.
 A: Dann  haben Sie wahrscheinlich das Adre·filter nicht korrekt einge-
    stellt.  DefaultmÑ·ig reicht der  Filter von 0  bis 32 Kbyte, falls
    Ihr  Programm  Teile  au·erhalb  dieses  Bereiches besitzen sollte,
    werden  diese nicht  Åbernommen. Sollte  Ihr Code komplett jenseits
    32  Kbyte  liegen  (wie  es  bei  65er  und 68er-Prozessoren Åblich
    ist),  dann erhalten Sie das  von Ihnen geschilderte Ergebnis. Set-
    zen  Sie das  Adre·filter einfach  auf einen  passenden Bereich (s.
    das Kapitel zu P2BIN/P2HEX).
 F: Ich  bekomme unter Unix bei der  Benutzung von P2BIN oder P2HEX das
    Dollarzeichen  nicht  eingegeben.  Die automatische Bereichsfestle-
    gung  funktioniert nicht,  stattdessen gibt  es eigenartige Fehler-
    meldungen.
 A: Unix-Shells  benutzen  das  Dollarzeichen  zur Expansion von Shell-
    Variablen.  Wollen Sie  ein Dollarzeichen  an eine Anwendung durch-
    reichen,  stellen Sie einen  Backslash (\) voran.  Im Falle der Ad-
    re·angabe  bei P2BIN und P2HEX darf  aber auch 0x anstelle des Dol-
    larzeichens  benutzt werden, was dieses Problem von vornherein ver-
    meidet.
 F: Ich  nutze  AS  auf  einem  Linux-System, das Ladeprogramm fÅr mein
    Zielsystem  lÑuft aber auf einem Windows-Rechner. Um das zu verein-
    fachen,  greifen beide System auf  das gleiche Netzwerklaufwerk zu.
    Leider  will die Windows-Seite aber die von der Linux-Seite erzeug-
    ten Hex-Dateien nicht lesen :-(
 A: Windows-  und Linux-Systeme benutzen  ein etwas abweichendes Format
    fÅr  Textdateien, unter  die auch  Hex-Dateien fallen. WÑhrend Win-
    dows  jede  Zeile  mit  den  Zeichen  CR  (Carriage  Return) und LF
    (Linefeed)  abschlie·t, verwendet Linux nur  ein Linefeed. Es hÑngt
    nun  von der  ''GutmÅtigkeit'' eines  Windows-Programmes ab,  ob es
    die  Dateien im Linux-Format akzeptiert.  Falls nicht, kann man die
    Dateien  anstelle  Åber  ein  Netzwerklaufwerk  Åber  FTP im ASCII-
    Modus  Åbertragen, oder man konvertiert  die Dateien unter ins Win-
    dows-Format.  Das Programm  unix2dos kann  dazu z.B. verwendet wer-
    den, oder unter Linux ein kleines Script:

          awk '{print $0"\r"}' test.hex >test_cr.hex




        D. Pseudobefehle gesammelt
        ==========================

In  diesem Anhang  finden sich  noch einmal  als schnelle Referenz alle
von  AS zur VerfÅgung  gestellten Pseudobefehle. Die  Liste ist in zwei
Teile  gegliedert: Im ersten  Teil finden sich  Befehle, die unabhÑngig
vom  eingestellten Zielprozessor vorhanden sind,  danach folgen fÅr je-
de Prozessorfamilie die zusÑtzlich vorhandenen Befehle:


        Immer vorhandene Befehle
        ........................

=             :=           ALIGN        BINCLUDE     CASE
CHARSET       CPU          DEPHASE      DOTTEDSTRUCTS ELSE
ELSECASE      ELSEIF       END          ENDCASE      ENDIF
ENDM          ENDS         ENDSECTION   ENDSTRUCT    ENUM
ERROR         EQU          EXITM        FATAL        FORWARD
FUNCTION      GLOBAL       IF           IFB          IFDEF
IFEXIST       IFNB         IFNDEF       IFNEXIST     IFNUSED
IFUSED        INCLUDE      IRP          LABEL        LISTING
MACEXP        MACRO        MESSAGE      NEWPAGE      ORG
PAGE          PHASE        POPV         PUSHV        PRTEXIT
PRTINIT       PUBLIC       READ         RELAXED      REPT
RESTORE       SAVE         SECTION      SEGMENT      SHARED
STRUC         STRUCT       SWITCH       TITLE        UNION
WARNING       WHILE

ZusÑtzlich  existiert SET bzw. EVAL, falls SET bereits ein Prozessorbe-
fehl ist.


        Motorola 680x0
        ..............

DC[.<size>]   DS[.<size>]  FULLPMMU     FPU          PADDING
PMMU          SUPMODE



        Motorola 56xxx
        ..............

DC            DS           XSFR         YSFR



        PowerPC
        .......

BIGENDIAN     DB           DD           DQ           DS
DT            DW           REG          SUPMODE



        Motorola M-Core
        ...............

DC[.<size>]   DS[.<size>]  REG          SUPMODE



        Motorola XGATE
        ..............

ADR           BYT          DC[.<size>]  DFS          DS[.<size>]
FCB           FCC          FDB          PADDING      RMB



        Motorola 68xx/Hitachi 6309
        ..........................

ADR           BYT          DC[.<size>]  DFS          DS[.<size>]
FCB           FCC          FDB          PADDING      RMB



        Motorola/Freescale 6805/68HC(S)08
        .................................

ADR           BYT          DFS          FCB          FCC
FDB           RMB



        Motorola 6809/Hitachi 6309
        ..........................

ADR           ASSUME       BYT          DFS          FCB
FCC           FDB          RMB



        Motorola 68HC12
        ...............

ADR           BYT          DC[.<size>]  DFS          DS[.<size>]
FCB           FCC          FDB          PADDING      RMB



        Motorola 68HC16
        ...............

ADR           ASSUME       BYT          DC[.<size>]  DFS
DS[.<size>] FCB FCC        FDB          PADDING
RMB



        Freescale 68RS08
        ................

ADR           BYT          DFS          FCB          FCC
FDB           RMB



        Hitachi H8/300(L/H)
        ...................

DC[.<size>]   DS[.<size>]  MAXMODE      PADDING



        Hitachi H8/500
        ..............

ASSUME        DC[.<size>]  DS[.<size>]  MAXMODE      PADDING



        Hitachi SH7x00
        ..............

COMPLITERALS  DC[.<size>]  DS[.<size>]  LTORG        PADDING
SUPMODE



        65xx/MELPS-740
        ..............

ADR           ASSUME       BYT          DFS          FCB
FCC           FDB          RMB



        65816/MELPS-7700
        ................

ADR           ASSUME       BYT          DB           DD
DQ            DS           DT           DW           DFS
FCB           FCC          FDB          RMB



        Mitsubishi MELPS-4500
        .....................

DATA          RES          SFR



        Mitsubishi M16
        ..............

DB            DD           DQ           DS           DT
DW



        Mitsubishi M16C
        ...............

DB            DD           DQ           DS           DT
DW



        Intel 4004
        ..........

DATA          DS           REG



        Intel 8008
        ..........

DB            DD           DQ           DS           DT
DW



        Intel MCS-48
        ............

DB            DD           DQ           DS           DT
DW



        Intel MCS-(2)51
        ...............

BIGENDIAN     BIT          DB           DD           DQ
DS            DT           DW           PORT         SFR
SFRB          SRCMODE



        Intel MCS-96
        ............

ASSUME        DB           DD           DQ           DS
DT            DW


        Intel 8080/8085
        ...............

DATA          DS



        Intel 8080/8085
        ...............

DB            DD           DQ           DS           DT
DW            PORT



        Intel i960
        ..........

DB            DD           DQ           DS           DT
DW                         FPU          SPACE        SUPMODE
WORD



        Signetics 8X30x
        ...............

LIV           RIV



        Philips XA
        ..........

ASSUME        BIT          DB           DC[.<size>]  DD
DQ            DS[.<size>]  DT           DW           PADDING
PORT          SUPMODE



        Atmel AVR
        .........

DATA          PACKING      PORT         REG          RES



        AMD 29K
        .......

ASSUME        DB           DD           DQ           DS
DT            DW           EMULATED     SUPMODE



        Siemens 80C166/167
        ..................

ASSUME        BIT          DB           DD           DQ
DS            DT           DW           REG



        Zilog Zx80
        ..........

DB            DD           DEFB         DEFW         DQ
DS            DT           DW           EXTMODE      LWORDMODE



        Zilog Z8
        ........

DB            DD           DQ           DS           DT
DW            SFR



        Xilinx KCPSM
        ............

CONSTANT      NAMEREG      REG



        Xilinx KCPSM3
        .............

CONSTANT      DB           DD           DQ           DS
DT            DW           NAMEREG      PORT         REG



        LatticeMico8
        ............

DB            DD           DQ           DS           DT
DW            PORT         REG



        Toshiba TLCS-900
        ................

DB            DD           DQ           DS           DT
DW            MAXIMUM      SUPMODE



        Toshiba TLCS-90
        ...............

DB            DD           DQ           DS           DT
DW



        Toshiba TLCS-870
        ................

DB            DD           DQ           DS           DT
DW



        Toshiba TLCS-47(0(A))
        .....................

ASSUME        DB           DD           DQ           DS
DT            DW           PORT



        Toshiba TLCS-9000
        .................

DB            DD           DQ           DS           DT
DW



        Microchip PIC16C5x
        ..................

DATA          RES          SFR          ZERO



        Microchip PIC16C8x
        ..................

DATA          RES          SFR          ZERO



        Microchip PIC17C42
        ..................

DATA          RES          SFR          ZERO



        SGS-Thomson ST6
        ...............

ASCII         ASCIZ        ASSUME       BYTE         BLOCK
SFR           WORD



        SGS-Thomson ST7
        ...............

DC[.<size>]   DS[.<size>]  PADDING



        SGS-Thomson ST9
        ...............

ASSUME        BIT          DB           DD           DQ
DS            DT           DW           REG



        6804
        ....

ADR           BYT          DFS          FCB          FCC
FDB           RMB          SFR



        Texas TM3201x
        .............

DATA          PORT         RES



        Texas TM32C02x
        ..............

BFLOAT        BSS          BYTE         DATA         DOUBLE
EFLOAT        TFLOAT       LONG         LQxx         PORT
Qxx           RES          RSTRING      STRING       WORD



        Texas TMS320C3x
        ...............

ASSUME        BSS          DATA         EXTENDED     SINGLE
WORD



        Texas TM32C020x/TM32C05x/TM32C054x
        ..................................

BFLOAT        BSS          BYTE         DATA         DOUBLE
EFLOAT        TFLOAT       LONG         LQxx         PORT
Qxx           RES          RSTRING      STRING       WORD



        Texas TMS320C6x
        ...............

BSS           DATA         DOUBLE       SINGLE
WORD



        Texas TMS9900
        .............

BSS           BYTE         PADDING      WORD



        Texas TMS70Cxx
        ..............

DB            DD           DQ           DS           DT
DW



        Texas TMS370
        ............

DB            DBIT         DD           DQ           DS
DT            DW



        Texas MSP430
        ............

BSS           BYTE         PADDING      WORD



        National SC/MP
        ..............

DB            DD           DQ           DS           DT
DW


        National INS807x
        ................

DB            DD           DQ           DS           DT
DW


        National COP4
        .............

ADDR          ADDRW        BYTE         DB           DD
DQ            DS           DSB          DSW          DT
FB            FW           SFR          WORD



        National COP8
        .............

ADDR          ADDRW        BYTE         DB           DD
DQ            DS           DSB          DSW          DT
FB            FW           SFR          WORD



        National COP8
        .............

DC            DC8          DS           DS8          DS16
DW            DW16



        Fairchild ACE
        .............

DB            DD           DQ           DS           DT
DW



        NEC ÊPD78(C)1x
        ..............

ASSUME        DB           DD           DQ           DS
DT            DW



        NEC 75K0
        ........

ASSUME        BIT          DB           DD           DQ
DS            DT           DW           SFR



        NEC 78K0
        ........

DB            DD           DQ           DS           DT
DW



        NEC 78K2
        ........

BIT           DB           DD           DQ           DS
DT            DW



        NEC ÊPD772x
        ...........

DATA          RES



        NEC ÊPD772x
        ...........

DS            DW



        Symbios Logic SYM53C8xx
        .......................




        Fujitsu F^2MC8L
        ...............

DB            DD           DQ           DS           DT
DW



        Fujitsu F^2MC16L
        ................

DB            DD           DQ           DS           DT
DW



        Mitsubishi M16C
        ...............

DB            DD           DQ           DS           DT
DW



        E. Vordefinierte Symbole
        ========================


+---------------+------------+-------------+-------------------------------+
| Name          | Datentyp   | Definition  | Bedeutung                     |
+---------------+------------+-------------+-------------------------------+
+---------------+------------+-------------+-------------------------------+
| ARCHITECTURE  | String     | vordef.     | Zielplattform, fÅr die AS     |
|               |            |             | Åbersetzt wurde, in der Form  |
|               |            |             | Prozesor-Hersteller-Betriebs- |
|               |            |             | system                        |
+---------------+------------+-------------+-------------------------------+
| BIGENDIAN     | Boolean    | normal      | Konstantenablage mit MSB      |
|               |            |             | first ?                       |
+---------------+------------+-------------+-------------------------------+
| CASESENSITIVE | Boolean    | normal      | Unterscheidung von Gro·-      |
|               |            |             | und Kleinbuchstaben in        |
|               |            |             | Symbolnamen ?                 |
+---------------+------------+-------------+-------------------------------+
| CONSTPI       | Gleitkomma | normal      | Kreiszahl Pi (3.1415.....)    |
+---------------+------------+-------------+-------------------------------+
| DATE          | String     | vordef.     | Datum des Beginns der         |
|               |            |             | Assemblierung (1.Pass)        |
+---------------+------------+-------------+-------------------------------+
| FALSE         | Boolean    | vordef.     | 0 = logisch ,,falsch''        |
+---------------+------------+-------------+-------------------------------+
| HASFPU        | Boolean    | dynam.(0)   | Koprozessor-Befehle           |
|               |            |             | freigeschaltet ?              |
+---------------+------------+-------------+-------------------------------+
| HASPMMU       | Boolean    | dynam.(0)   | MMU-Befehle frei-             |
|               |            |             | geschaltet ?                  |
+---------------+------------+-------------+-------------------------------+
| INEXTMODE     | Boolean    | dynam.(0)   | XM-Flag fÅr 4 Gbyte           |
|               |            |             | Adre·raum gesetzt ?           |
+---------------+------------+-------------+-------------------------------+
| INLWORDMODE   | Boolean    | dynam.(0)   | LW-Flag fÅr 32-Bit-Befehle    |
|               |            |             | gesetzt ?                     |
+---------------+------------+-------------+-------------------------------+
| INMAXMODE     | Boolean    | dynam.(0)   | Prozessor im Maximum-         |
|               |            |             | Modus ?                       |
+---------------+------------+-------------+-------------------------------+
| INSUPMODE     | Boolean    | dynam.(0)   | Prozessor im Supervisor-      |
|               |            |             | Modus ?                       |
+---------------+------------+-------------+-------------------------------+
| INSRCMODE     | Boolean    | dynam.(0)   | Prozessor im Quellmodus ?     |
+---------------+------------+-------------+-------------------------------+
| FULLPMMU      | Boolean    | dynam.(0/1) | voller PMMU-Befehlssatz ?     |
+---------------+------------+-------------+-------------------------------+
| LISTON        | Boolean    | dynam.(1)   | Listing freigeschaltet ?      |
+---------------+------------+-------------+-------------------------------+
| MACEXP        | Boolean    | dynam.(1)   | Expansion von Makrokon-       |
|               |            |             | strukten im Listing           |
|               |            |             | freigeschaltet ?              |
+---------------+------------+-------------+-------------------------------+

Tabelle E.1: Vordefinierte Symbole - Teil 1



+------------+----------+-------------+--------------------------------+
| Name       | Datentyp | Definition  | Bedeutung                      |
+------------+----------+-------------+--------------------------------+
+------------+----------+-------------+--------------------------------+
| MOMCPU     | Integer  | dynam.      | Nummer der momentan            |
|            |          | (68008)     | gesetzten Ziel-CPU             |
+------------+----------+-------------+--------------------------------+
| MOMCPUNAME | String   | dynam.      | Name der momentan              |
|            |          | (68008)     | gesetzten Ziel-CPU             |
+------------+----------+-------------+--------------------------------+
| MOMFILE    | String   | Spezial     | augenblickliche Quelldatei     |
|            |          |             | (schlie·t Includes ein)        |
+------------+----------+-------------+--------------------------------+
| MOMLINE    | Integer  | Spezial     | aktuelle Zeilennummer in       |
|            |          |             | der Quelldatei                 |
+------------+----------+-------------+--------------------------------+
| MOMPASS    | Integer  | Spezial     | Nummer des laufenden           |
|            |          |             | Durchgangs                     |
+------------+----------+-------------+--------------------------------+
| MOMSECTION | String   | Spezial     | Name der aktuellen Sektion     |
|            |          |             | oder Leerstring, fall au·er-   |
|            |          |             | halb aller Sektionen           |
+------------+----------+-------------+--------------------------------+
| MOMSEGMENT | String   | Spezial     | Name des mit SEGMENT ein-      |
|            |          |             | gestellten Adre·raumes         |
+------------+----------+-------------+--------------------------------+
| NESTMAX    | Integer  | dynam.(256) | maximale Verschachtelungs-     |
|            |          |             | tiefe fÅr Makros               |
+------------+----------+-------------+--------------------------------+
| PADDING    | Boolean  | dynam.(1)   | AuffÅllen von Bytefeldern      |
|            |          |             | auf ganze Anzahl ?             |
+------------+----------+-------------+--------------------------------+
| RELAXED    | Boolean  | dynam.(0)   | Schreibweise von Integer-Kon-  |
|            |          |             | stanten in beliebiger Syntax   |
|            |          |             | erlaubt ?                      |
+------------+----------+-------------+--------------------------------+
| PC         | Integer  | Spezial     | mom. ProgrammzÑhler            |
|            |          |             | (Thomson)                      |
+------------+----------+-------------+--------------------------------+
| TIME       | String   | vordef.     | Zeit des Beginns der Assem-    |
|            |          |             | blierung (1. Pass)             |
+------------+----------+-------------+--------------------------------+
| TRUE       | Integer  | vordef.     | 1 = logisch ,,wahr''           |
+------------+----------+-------------+--------------------------------+
| VERSION    | Integer  | vordef.     | Version von AS in BCD-Kodie-   |
|            |          |             | rung, z.B. 1331 hex fÅr        |
|            |          |             | Version 1.33p1                 |
+------------+----------+-------------+--------------------------------+
| WRAPMODE   | Integer  | vordef.     | verkÅrzter ProgrammzÑhler      |
|            |          |             | angenommen?                    |
+------------+----------+-------------+--------------------------------+
|  *         | Integer  | Spezial     | mom. ProgrammzÑhler (Motorola, |
|            |          |             | Rockwell, Microchip, Hitachi)  |
+------------+----------+-------------+--------------------------------+
| $          | Integer  | Spezial     | mom. ProgrammzÑhler (Intel,    |
|            |          |             | Zilog, Texas, Toshiba, NEC,    |
|            |          |             | Siemens, AMD)                  |
+------------+----------+-------------+--------------------------------+

Tabelle E.2: Vordefinierte Symbole - Teil 2


Boolean-Symbole  sind eigentlich  normale normale  Integer-Symbole, mit
dem  Unterschied, da· ihnen von AS  nur zwei verschiedene Werte (0 oder
1,  entsprechend  FALSE  oder  TRUE)  zugewiesen werden. Spezialsymbole
werden  von AS  nicht in  der Symboltabelle  abgelegt, sondern  aus Ge-
schwindigkeitsgrÅnden  direkt  im  Parser  abgefragt. Sie tauchen daher
auch  nicht in der Symboltabelle des Listings auf. WÑhrend vordefinier-
te  Symbole nur  einmal am  Anfang eines  Passes besetzt werden, kînnen
sich  die Werte dynamischer Symbole  wÑhrend der Assemblierung mehrfach
Ñndern,  da sie mit anderen  Befehlen vorgenommene Einstellungen wider-
spiegeln.

Die  hier aufgelistete Schreibweise ist diejenige, mit der man die Sym-
bole auch im case-sensitiven Modus erreicht.

Die  hier aufgefÅhrten Namen sollte man fÅr eigene Symbole meiden; ent-
weder  kann man sie  zwar definieren, aber  nicht darauf zugreifen (bei
Spezialsymbolen),  oder man erhÑlt eine  Fehlermeldung wegen eines dop-
pelt  definierten Symboles.  Im gemeinsten  Fall fÅhrt  die Neubelegung
durch  AS zu Beginn  eines Passes zu  einem Phasenfehler und einer End-
losschleife...


        F. Mitgelieferte Includes
        =========================

Der  Distribution von AS liegen eine Reihe von Include-Dateien bei. Ne-
ben  Includes, die sich nur auf eine Prozessorfamilie beziehen (und de-
ren  Funktion sich  demjenigen unmittelbar  erschlie·t, der  mit dieser
Familie  arbeitet), existieren aber auch  ein paar Dateien, die prozes-
sorunabhÑngig  sind und die eine  Reihe nÅtzlicher Funktionen implemen-
tieren.  Die definierten  Funktionen sollen  hier kurz beschrieben wer-
den:


        F.1. BITFUNCS.INC
        -----------------

Diese  Datei definiert eine Reihe  bitorientierter Operationen, wie man
sie  bei anderen Assemblern vielleicht fest eingebaut sind. Bei AS wer-
den  sie  jedoch  mit  Hilfe  benutzerdefinierter  Funktionen implemen-
tiert:


  -  mask(start,bits)  liefert einen  Integer, in  dem ab  Stelle start
    bits Bits gesetzt sind;
  -  invmask(start,bits) liefert das Einerkomplement zu mask();
  -  cutout(x,start,bits)  liefert  ausmaskierte  bits  Bits  ab Stelle
    start aus x, ohne sie auf Stelle 0 zu verschieben;
  -  hi(x) liefert das zweitniedrigste Byte (Bit 8..15) aus x;
  -  lo(x) liefert das niederwertigste Byte (Bit 0..7) aus x;
  -  hiword(x) liefert das zweitniedrigste Wort (Bit 16..31) aus x;
  -  loword(x) liefert das niederwertigste Wort (Bit 0..15) aus x;
  -  odd(x) liefert TRUE, falls x ungerade ist;
  -  even(x) liefert TRUE, falls x gerade ist;
  -  getbit(x,n)  extrahiert das Bit n aus x  und liefert es als 0 oder
    1;
  -  shln(x,size,n)  schiebt ein Wort x der  LÑnge size Bits um n Stel-
    len nach links;
  -  shrn(x,size,n)  schiebt ein Wort x der  LÑnge size Bits um n Stel-
    len nach rechts;
  -  rotln(x,size,n)  rotiert die untersten size  Bits eines Integers x
    um n Stellen nach links;
  -  rotrn(x,size,n)  rotiert die untersten size  Bits eines Integers x
    um n Stellen nach rechts;



        F.2. CTYPE.INC
        --------------

Dieser  Include ist  das Pendant  zu dem  bei C vorhandenen Header cty-
pe.h,  der Makros zur Klassifizierung  von Zeichen anbietet. Alle Funk-
tionen liefern entweder TRUE oder FALSE:


  -  isdigit(ch) ist TRUE, falls ch eine Ziffer (0..9) ist;
  -  isxdigit(ch)  ist TRUE,  falls ch  eine gÅltige Hexadezimal-Ziffer
    (0..9, A..F, a..f) ist;
  -  isascii(ch)  ist TRUE,  falls ch  sich im  Bereich normaler ASCII-
    Zeichen ohne gesetztes Bit 7 bewegt;
  -  isupper(ch)   ist   TRUE,   falls   ch   ein   Gro·buchstabe   ist
    (Sonderzeichen ausgenommen);
  -  islower(ch)   ist   TRUE,   falls   ch   ein   Kleinbuchstabe  ist
    (Sonderzeichen ausgenommen);
  -  isalpha(ch)  ist TRUE,  falls ch  ein Buchstabe ist (Sonderzeichen
    ausgenommen);
  -  isalnum(ch)  ist  TRUE,  falls  ch  ein Buchstabe oder eine Ziffer
    ist);
  -  isspace(ch)  ist TRUE,  falls ch  ein 'Leerzeichen'  (Space, Form-
    feed, Zeilenvorschub, WagenrÅcklauf, Tabulator) ist);
  -  isprint(ch)  ist TRUE, falls  ch ein druckbares  Zeichen ist (also
    kein Steuerzeichen bis Code 31);
  -  iscntrl(ch) ist das Gegenteil zu isprint();
  -  isgraph(ch)  ist TRUE, falls ch ein druckbares und sichtbares Zei-
    chen ist;
  -  ispunct(ch)  ist TRUE,  falls ch  ein druckbares Sonderzeichen ist
    (d.h. weder Space, Buchstabe noch Ziffer);



        G. Danksagungen
        ===============


    ''If I have seen farther than other men,
    it is because I stood on the shoulders of giants.''
              --Sir Isaac Newton


    ''If I haven't seen farther than other men,
    it is because I stood in the footsteps of giants.''
              --unknown


Wenn  man sich entschlie·t, ein solches Kapitel neu zu schreiben, nach-
dem  es eigentlich  schon zwei  Jahre veraltet  ist, lÑuft  man automa-
tisch  Gefahr, da·  dabei der  eine oder  andere gute  Geist, der etwas
zum  bisherigen  Gelingen  dieses  Projektes beigetragen hat, vergessen
wird.  Der allererste  Dank gebÅhrt  daher allen  Personen, die  ich in
der folgenden AufzÑhlung unfreiwillig unterschlagen habe!

AS  als Universalassembler, wie er jetzt  besteht, ist auf Anregung von
Bernhard       (C.)      Zschocke       entstanden,      der      einen
,,studentenfreundlichen'',  d.h.  kostenlosen  8051-Assembler  fÅr sein
Mikroprozessorpraktikum  brauchte und  mich dazu  bewegt hat, einen be-
reits  bestehenden 68000-Assembler  zu erweitern.  Von dortan  nahm die
Sache  ihren  Lauf...  Das  Mikroprozessorpraktikum  an der RWTH Aachen
hat  auch immer die eifrigsten Nutzer der neuesten AS-Features (und da-
mit  Bug-Sucher) gestellt und  damit einiges zur  jetzigen QualitÑt von
AS beigetragen.

Das  Internet und FTP  haben sich als  gro·e Hilfe bei  der Meldung von
Bugs  und der Verbreitung von  AS erwiesen. Ein Dank  geht daher an die
FTP-Administratoren  (Bernd Casimir  in Stuttgart,  Norbert Breidohr in
Aachen  und JÅrgen  Mei·burger in  JÅlich). Insbesondere  letzterer hat
sich sehr engagiert, um eine praxisnahe Lîsung im ZAM zu finden.

Ach  ja, wo wir  schon im ZAM  sind: Wolfgang E.  Nagel hat zwar nichts
direkt  mit  AS  zu  tun,  immerhin  ist  er  aber  mein Chef und wirft
stÑndig  vier Augen auf das, was ich  tue. Bei AS scheint zumindest ein
lachendes dabei zu sein...

Ohne  DatenbÅcher und  Unterlagen zu  Prozessoren ist  ein Programm wie
AS  nicht zu machen. Ich  habe von einer enormen  Anzahl von Leuten In-
formationen  bekommen,  die  von  einem  kleinen  Tip bis zu ganzen Da-
tenbÅchern  reichen. Hier eine AufzÑhlung (wie oben gesagt, ohne Garan-
tie auf VollstÑndigkeit!):

Ernst  Ahlers,  Charles  Altmann,  Marco  Awater,  Len  Bayles, Andreas
Bolsch,  Rolf Buchholz,  Bernd Casimir,  Gunther Ewald, Stephan Hrusch-
ka,  Peter  Kliegelhîfer,  Ulf  Meinke,  Matthias  Paul, Norbert Rosch,
Steffen  Schmid, Leonhard  Schneider, Ernst  Schwab, Michael Schwingen,
Oliver  Sellke,  Christian  Stelter,  Patrik  Strîmdahl,  Oliver Thamm,
Thorsten Thiele, Andreas Wassatsch, John Weinrich.

...und  ein gehÑssiger Dank an  Rolf-Dieter-Klein und Tobias Thiel, die
mit  ihren ASM68K  demonstrierten, wie  man es  nicht machen sollte und
mich damit indirekt dazu angeregt haben, etwas besseres zu schreiben!

So  ganz allein  habe ich  AS nicht  verzapft. AS  enthÑlt die OverXMS-
Routinen  von Wilbert  van Leijen,  um die  Overlay-Module ins Extended
Memory  verlagern  zu  kînnen.  Eine  wirklich feine Sache, einfach und
problemlos anzuwenden!

Die  TMS320C2x/5x-Codegeneratoren sowie die  Datei STDDEF2x.INC stammen
von  Thomas Sailer,  ETH ZÅrich.  Erstaunlich, an  einem Wochenende hat
er  es geschafft, durch meinen Code  durchzusteigen und den neuen Gene-
rator  zu implementieren. Entweder  waren das reichliche Nachtschichten
oder ich werde langsam alt...


        H. énderungen seit Version 1.3
        ==============================


  - Version 1.31:
      - zusÑtzlicher  MCS-51-Prozessortyp 80515.  Die Nummer  wird wie-
        derum  nur vom Assembler verwaltet. Die Datei STDDEF51.INC wur-
        de  um die dazugehîrigen SFRs erweitert. ACHTUNG! Einige 80515-
        SFRs haben sich adre·mÑ·ig verschoben!
      - zusÑtzlich Prozessor Z80 unterstÅtzt;
      - schnellerer 680x0-Codegenerator.
  - Version 1.32:
      - Schreibweise  von  Zeropageadressen  fÅr  65xx  nicht  mehr als
        Adr.z, sondern wie beim 68xx als <Adr;
      - unterstÅtzt die Prozessoren 6800, 6805, 6301 und 6811;
      - der 8051-Teil versteht jetzt auch DJNZ, PUSH und POP (sorry);
      - im  Listing werden neben den  Symbolen jetzt auch die definier-
        ten Makros aufgelistet;
      - Befehle  IFDEF/IFNDEF  fÅr  bedingte  Assemblierung,  mit denen
        sich die Existenz eines Symboles abfragen lÑ·t;
      - Befehle  PHASE/DEPHASE  zur  UnterstÅtzung  von  Code,  der zur
        Laufzeit auf eine andere Adresse verschoben werden soll;
      - Befehle  WARNING/ERROR/FATAL, um anwenderspezifische Fehlermel-
        dungen ausgeben zu kînnen;
      - Die  Datei STDDEF51.INC enthÑlt zusÑtzlich  das Makro USING zur
        einfacheren Handhabung der RegisterbÑnke der MCS-51er;
      - Kommandozeilenoption u, um Segmentbelegung anzuzeigen.
  - Version 1.33:
      - unterstÅtzt den 6809;
      - zusÑtzlich Stringvariablen;
      - Die  Befehle TITLE, PRTINIT, PRTEXIT,  ERROR, WARNING und FATAL
        erwarten  jetzt einen Stringausdruck  als Parameter, Konstanten
        mÅssen   demzufolge  nicht  mehr   in  Hochkommas,  sondern  in
        GÑnsefÅ·chen  eingeschlossen  werden.  Analoges  gilt  fÅr  DB,
        DC.B und BYT;
      - Befehl  ALIGN  zur  Ausrichtung  des ProgrammzÑhlers bei Intel-
        Prozessoren;
      - Befehl  LISTING, um die Erzeugung  eines Listings ein- und aus-
        schalten zu kînnen;
      - Befehl CHARSET zur Definition eigener ZeichensÑtze.
  - Version 1.34:
      - Wenn  im ersten  Pass Fehler  auftreten, wird  gar kein zweiter
        Pass mehr durchgefÅhrt;
      - neues  vordefiniertes Symbol  VERSION, welches  die Version von
        AS enthÑlt;
      - Befehl  MESSAGE, um Durchsagen  und Meldungen programmgesteuert
        zu erzeugen;
      - Formelparser Åber Stringkonstanten zugÑnglich;
      - Bei  Fehler  in  Makroexpansionen  wird zusÑtzlich die laufende
        Zeile im Makro angezeigt;
      - Funktion  UPSTRING, um  einen String  in Gro·buchstaben zu wan-
        deln.
  - Version 1.35:
      - Funktion  TOUPPER, um  ein einzelnes  Zeichen in Gro·buchstaben
        zu wandeln;
      - Befehl FUNCTION, um eigene Funktionen definieren zu kînnen;
      - Kommandozeilenoption  D,  um  Symbole  von  au·en definieren zu
        kînnen;
      - Fragt  die Environment-Variable ASCMD fÅr hÑufig gebrauchte Op-
        tionen ab;
      - bei  gesetzter u-Option  wird das  Programm zusÑtzlich auf dop-
        pelt belegte Speicherbereiche abgeprÅft;
      - Kommandozeilenoption C, um eine Querverweisliste zu erzeugen.
  - Version 1.36:
      - unterstÅtzt zusÑtzlich die Familien PIC 16C5x und PIC17C4x;
      - im  Listing wird  zusÑtzlich die  Verschachtelungsebene bei In-
        clude-Dateien angezeigt;
      - in  der Querverweisliste wird  zusÑtzlich die Stelle angezeigt,
        an der ein Symbol definiert wurde;
      - Kommandozeilenoption  A, um eine  kompaktere Ablage der Symbol-
        tabelle zu erzwingen.
  - Version 1.37:
      - unterstÅtzt  zusÑtzlich die Prozessoren  8086, 80186, V30, V35,
        8087 und Z180;
      - Befehle SAVE und RESTORE zur besseren Umschaltung von Flags;
      - Operatoren zur logischen Verschiebung und Bitspiegelung;
      - Kommandozeilenoptionen  kînnen  mit  einem  Pluszeichen negiert
        werden;
      - Filter  AS2MSG zur  bequemen Arbeit  mit AS  unter Turbo-Pascal
        7.0;
      - ELSEIF  darf ein Argument  zur Bildung von IF-THEN-ELSE-Leitern
        haben;
      - Zur  bequemeren  bedingten  Assemblierung  zusÑtzlich ein CASE-
        Konstrukt;
      - Selbstdefinierte  Funktionen dÅrfen  mehr als  ein Argument ha-
        ben;
      - P2HEX kann nun auch Hexfiles fÅr 65er-Prozessoren erzeugen;
      - BIND,  P2HEX  und  P2BIN  haben  jetzt  die  gleichen  Variati-
        onsmîglichkeiten in der Kommandozeile wie AS;
      - Schalter  i bei P2HEX, um 3  Varianten fÅr den Ende-Record ein-
        zustellen;
      - Neue Funktionen ABS und SGN;
      - Neue Pseudovariablen MOMFILE und MOMLINE;
      - Ausgabemîglichkeit erweiterter Fehlermeldungen;
      - Befehle  IFUSED und IFNUSED, um  abzufragen, ob ein Symbol bis-
        her benutzt wurde;
      - Die  Environment-Variablen  ASCMD,  BINDCMD  usw.  kînnen  auch
        einen  Dateinamen  enthalten,  in  dem  fÅr  die  Optionen mehr
        Platz ist;
      - P2HEX  erzeugt nun  die von  Microchip vorgegebenen Hex-Formate
        (p4);
      - mit   der  SeitenlÑngenangabe  0  kînnen  automatische  Seiten-
        vorschÅbe im Listing vollstÑndig unterdrÅckt werden (p4);
      - neue  Kommandozeilenoption P,  um die  Ausgabe des Makroprozes-
        sors in eine Datei zu schreiben (p4);
      - in  der Kommandozeile  definierte Symbole  dÅrfen nun  auch mit
        einem frei wÑhlbaren Wert belegt werden (p5).
  - Version 1.38:
      - Umstellung   auf  Mehrpass-Betrieb.  Damit  kann  AS  auch  bei
        VorwÑrtsreferenzen immer den optimalen Code erzeugen;
      - Der 8051-Teil kennt nun auch die Befehle JMP und CALL;
      - unterstÅtzt zusÑtzlich die Toshiba TLCS-900-Reihe (p1);
      - Befehl  ASSUME, um dem Assembler  die Belegung der Segmentregi-
        ster des 8086 mitzuteilen (p2);
      - unterstÅtzt zusÑtzlich die ST6-Reihe von SGS-Thomson (p2);
      - ..sowie   die  3201x-Signalprozessoren  von  Texas  Instruments
        (p2);
      - Option   F   bei   P2HEX,   um   die   automatische  Formatwahl
        Åbersteuern zu kînnen (p2);
      - P2BIN  kann nun auch durch  Angabe von Dollarzeichen Anfang und
        Ende des Adre·fensters selbststÑndig festlegen (p2);
      - Der  8048-Codegenerator kennt nun  auch die 8041/42- Befehlser-
        weiterungen(p2);
      - unterstÅtzt zusÑtzlich die Zilog Z8-Mikrokontroller(p3).
  - Version 1.39:
      - Definitionsmîglichkeit von Sektionen und lokalen Labels;
      - Kommandozeilenschalter   h,  um   Hexadezimalzahlenausgabe  mit
        Kleinbuchstaben zu erzwingen;
      - Variable  MOMPASS, um die Nummer des augenblicklichen Durchgan-
        ges abfragen zu kînnen;
      - Kommandozeilenschalter  t, um  einzelne Teile  des Assemblerli-
        stings ausblenden zu kînnen;
      - kennt  zusÑtzlich die L-Variante  der TLCS-900-Reihe von Toshi-
        ba und die MELPS-7700-Reihe von Mitsubishi (p1);
      - P2HEX  akzeptiert  nun  auch  Dollarzeichen  fÅr Start-und End-
        adresse (p2);
      - unterstÅtzt zusÑtzlich die TLCS90-Familie von Toshiba (p2);
      - P2HEX  kann Daten  zusÑtzlich im  Tektronix- und  16-Bit Intel-
        Hex-Format ausgeben (p2);
      - bei Adre·Åberschreitungen gibt P2HEX Warnungen aus (p2);
      - Include-Datei  STDDEF96.INC mit Adre·definitionen fÅr die TLCS-
        900-Reihe (p3);
      - Befehl  READ,  um  Werte  wÑhrend  der Assemblierung interaktiv
        einlesen zu kînnen (p3);
      - Fehlermeldungen  werden nicht mehr einfach auf die Standardaus-
        gabe,   sondern  auf  den  von  DOS  dafÅr  vorgesehenen  Kanal
        (STDERR) geschrieben (p3);
      - Der  beim 6811-Teil fehlende STOP-Befehl ist nun da (scusi,p3);
      - unterstÅtzt zusÑtzlich die ÊPD78(C)1x-Familie von NEC (p3);
      - unterstÅtzt zusÑtzlich den PIC16C84 von Microchip (p3);
      - Kommandozeilenschalter  E, um  die Fehlermeldungen  in eine Da-
        tei umleiten zu kînnen (p3);
      - Die Unklarheiten im 78(C)1x-Teil sind beseitigt (p4);
      - neben  dem MELPS-7700 ist  nun auch das  ,,Vorbild'' 65816 vor-
        handen (p4);
      - Die  ST6-Pseudoanweisung ROMWIN  wurde entfernt  und mit in den
        ASSUME-Befehl eingegliedert (p4);
      - unterstÅtzt zusÑtzlich den 6804 von SGS-Thomson (p4);
      - durch  die NOEXPORT-Option in der  Makrodefinition kann nun fÅr
        jedes  Makro einzeln festgelegt werden,  ob es in der MAC-Datei
        erscheinen soll oder nicht (p4);
      - Die  Bedeutung von MACEXP  fÅr Expansionen von  Makros hat sich
        wegen  der zusÑtzlichen NOEXPAND-Option  in der Makrodefinition
        leicht geÑndert (p4);
      - Durch  die  GLOBAL-Option  in  der  Makrodefinition  kînnen nun
        zusÑtzlich  Makros definiert werden,  die durch ihren Sektions-
        namen eindeutig gekennzeichnet sind (p4).
  - Version 1.40:
      - unterstÅtzt zusÑtzlich den DSP56000 von Motorola;
      - P2BIN  kann nun  auch das  untere bzw.  obere Wort  aus 32-Bit-
        Wîrtern abtrennen;
      - unterstÅtzt  zusÑtzlich die  TLCS-870- und  TLCS-47-Familie von
        Toshiba(p1);
      - mit   einem   vorangestelltem   !   kann   man   durch   Makros
        ,,verdeckte'' Maschinenbefehle wieder erreichen(p1);
      - mit  der GLOBAL-Anweisung lassen sich Symbolnamen nun auch qua-
        lifiziert exportieren(p1);
      - mit  der r-Option kann man sich  nun eine Liste der Stellen er-
        zeugen lassen, die zusÑtzliche DurchlÑufe erzwangen(p1);
      - bei  der E-Option kann nun  die Dateiangabe weggelassen werden,
        so da· ein passender Default gewÑhlt wird(p1);
      - mit  der t-Option kann nun die Zeilennumerierung im Listing ab-
        geschaltet werden(p1);
      - Escapesequenzen  sind nun auch in  in ASCII geschriebenen Inte-
        gerkonstanten zulÑssig(p1);
      - Mit  dem Pseudobefehl  PADDING kann  das EinfÅgen von FÅllbytes
        im 680x0-Modus ein- und ausgeschaltet werden (p2);
      - ALIGN ist nun fÅr alle Zielplattformen erlaubt (p2);
      - kennt zusÑtzlich die PIC16C64-SFRs (p2);
      - unterstÅtzt zusÑtzlich den 8096 von Intel (p2);
      - Bei  DC kann zusÑtzlich  ein Wiederholungsfaktor angegeben wer-
        den (r3);
      - unterstÅtzt  zusÑtzlich die TMS320C2x-Familie von Texas Instru-
        ments  (Implementierung  von  Thomas  Sailer,  ETH ZÅrich, r3);
        P2HEX ist auch entsprechend erweitert;
      - statt  EQU  darf  nun  auch  einfach ein Gleichheitszeichen be-
        nutzt werden (r3);
      - zur  Definition  von  AufzÑhlungen  zusÑtzlich  ein ENUM-Befehl
        (r3);
      - END hat jetzt auch eine Wirkung (r3);
      - zusÑtzliche   Kommandozeilenoption  n,  um  zu  Fehlermeldungen
        zusÑtzlich die internen Fehlernummern zu erhalten (r3);
      - unterstÅtzt zusÑtzlich die TLCS-9000er von Toshiba (r4);
      - unterstÅtzt  zusÑtzlich  die  TMS370xxx-Reihe  von Texas Instu-
        ments, wobei als neuer Pseudobefehl DBIT hinzukam (r5);
      - kennt zusÑtzlich die DS80C320-SFRs (r5);
      - der  Makroprozessor kann  nun auch  Includes aus  Makros heraus
        einbinden,  wozu  das  Format  von  Fehlermeldungen aber leicht
        geÑndert  werden  mu·te.  Falls  Sie AS2MSG verwenden, ersetzen
        Sie es unbedingt durch die neue Version! (r5)
      - unterstÅtzt zusÑtzlich den 80C166 von Siemens (r5);
      - zusÑtzlich  eine VAL-Funktion, um  StringausdrÅcke auswerten zu
        kînnen (r5);
      - Mithilfe  von in geschweiften Klammern eingeschlossenen String-
        variablen lassen sich nun selber Symbole definieren (r5);
      - kennt zusÑtzlich die Eigenheiten des 80C167 von Siemens (r6);
      - jetzt  gibt es  fÅr die  MELPS740-Reihe auch  die special-page-
        Adressierung (r6);
      - mit  eckigen Klammern kann  man explizit Symbole  aus einer be-
        stimmten  Sektion  ansprechen.  Die  Hilfskonstruktion  mit dem
        Klammeraffen gibt es nicht mehr (r6)!
      - kennt zusÑtzlich die MELPS-4500-Reihe von Mitsubishi (r7);
      - kennt  zusÑtzlich die H8/300  und H8/300H-Prozessoren von Hita-
        chi (r7);
      - die  mit  LISTING  und  MACEXP  gemachten  Einstellungen lassen
        sich  nun auch wieder aus gleichnamigen Symbolen auslesen (r7);
      - kennt zusÑtzlich den TMS320C3x von Texas Instruments (r8);
      - kennt zusÑtzlich den SH7000 von Hitachi (r8);
      - der  Z80-Teil  wurde  um  die  UnterstÅtzung des Z380 erweitert
        (r9);
      - der  68K-Teil  wurde  um  die  feinen  Unterschiede  der 683xx-
        Mikrokontroller erweitert (r9);
      - ein  Label mu·  nun nicht  mehr in  der ersten Spalte beginnen,
        wenn man es mit einem Doppelpunkt versieht (r9);
      - kennt zusÑtzlich die 75K0-Reihe von NEC (r9);
      - mit  dem neuen Kommandozeilenschalter o kann der Name der Code-
        Datei neu festgelegt werden (r9);
      - der  ~~-Operator ist  in der  Rangfolge auf  einen sinnvolleren
        Platz gerutscht (r9);
      - ASSUME   berÅcksichtigt  fÅr  den  6809  jetzt  auch  das  DPR-
        Register und seine Auswirkungen (pardon, r9);
      - Der  6809-Teil  kennt  nun  auch  die versteckten Erweiterungen
        des 6309 (r9);
      - BinÑrkonstanten  kînnen  jetzt  auch  in C-artiger Notation ge-
        schrieben werden (r9).
  - Version 1.41:
      - Åber  das  Symbol  MOMSEGMENT  kann  der  momentan gesetzte Ad-
        re·raum abgefragt werden;
      - anstelle  von  SET  bzw.  EVAL  kann  jetzt auch einfach := ge-
        schrieben werden;
      - mit  der neuen Kommandozeilenoption q  kann ein ,,stiller'' As-
        semblerlauf erzwungen werden;
      - das  SchlÅsselwort PARENT zum  Ansprechen der Vatersektion wur-
        de um PARENT0...PARENT9 erweitert;
      - der   PowerPC-Teil   wurde   um  die  Mikrokontroller-Versionen
        MPC505 und PPC403 erweitert;
      - mit  SET oder EQU definierte  Symbole kînnen nun einem bestimm-
        ten Adre·raum zugeordnet werden;
      - mit  SET oder EQU definierte  Symbole kînnen nun einem bestimm-
        ten Adre·raum zugeordnet werden;
      - durch  das  Setzen  der  Environment-Variablen USEANSI kann die
        Verwendung  von  ANSI-Bildschirmsteuersequenzen  an-und  ausge-
        schaltet werden (r1);
      - der     SH7000-Teil    kennt    jetzt    auch    die    SH7600-
        Befehlserweiterungen  (und sollte  jetzt korrekte Displacements
        berechnen...) (r1).
      - im  65XX-Teil wird jetzt zwischen  65C02 und 65SC02 unterschie-
        den (r1);
      - neben  der Variablen MOMCPU gibt es jetzt auch den String MOMC-
        PUNAME, der den Prozessornamen im Volltext enthÑlt (r1).
      - P2HEX  kennt  jetzt  auch  die  32-Bit-Variante  des Intel-Hex-
        Formates (r1);
      - kennt jetzt auch die EinschrÑnkungen des 87C750 (r2);
      - die  Nummern fÅr fatale Fehlermeldungen  wurden auf den Bereich
        ab  10000 verschoben,  um Platz  fÅr normale Fehlermeldungen zu
        schaffen (r2);
      - unbenutzte  Symbole werden  in der  Symboltabelle jetzt mit ei-
        nem Stern gekennzeichnet (r2);
      - unterstÅtzt zusÑtzlich die 29K-Familie von AMD (r2);
      - unterstÅtzt zusÑtzlich die M16-Familie von Mitsubishi (r2);
      - unterstÅtzt zusÑtzlich die H8/500-Familie von Hitachi (r3);
      - die  Anzahl von  Datenbytes, die  P2HEX pro  Zeile ausgibt, ist
        jetzt variierbar (r3);
      - der  Pass, ab dem durch die -r-Option erzeugte Warnungen ausge-
        geben werden, ist einstellbar (r3);
      - der  Makroprozessor  kennt  jetzt  ein WHILE-Statement, mit dem
        ein  Code-StÅck  eine  variable  Anzahl  wiederholt werden kann
        (r3);
      - der  PAGE-Befehl erlaubt es nun auch, die Breite des Ausgabeme-
        diums fÅrs Listing anzugeben (r3);
      - Um  neue  Pseudo-Prozessortypen  einfÅhren  zu  kînnen,  lassen
        sich jetzt CPU-Aliasse definieren (r3);
      - unterstÅtzt zusÑtzlich die MCS/251-Familie von Intel (r3);
      - bei  eingeschalteter  Querverweisliste  wird  bei doppelt defi-
        nierten  Symbolen  die  Stelle  der ersten Definition angezeigt
        (r3);
      - unterstÅtzt  zusÑtzlich die TMS320C5x-Familie von Texas Instru-
        ments (Implementierung von Thomas Sailer, ETH ZÅrich, r3);
      - die  OS/2-Version sollte jetzt auch mit langen Dateinamen klar-
        kommen. Wenn man nicht jeden Mist selber kontrolliert... (r3)
      - Åber  den  Befehl  BIGENDIAN  kann  im  MCS-51/251-Modus  jetzt
        gewÑhlt  werden,  ob  die  Ablage  von  Konstanten im Big- oder
        Little-Endian-Format erfolgen soll (r3);
      - es  wird  beim  680x0  jetzt  zwischen  dem  vollen  und einge-
        schrÑnkten  MMU-Befehlssatz  unterschieden;  eine  manuelle Um-
        schaltung ist mit dem FULLPMMU-Befehl mîglich (r3);
      - Åber  die  neue  Kommandozeilenoption  I  kann eine Liste aller
        eingezogenen  Include-Files mit  ihrer Verschachtelung ausgege-
        ben werden (r3);
      - Beim  END-Statement  kann  jetzt  zusÑtzlich ein Einsprungpunkt
        fÅr das Programm angegeben werden (r3).
      - unterstÅtzt zusÑtzlich die 68HC16-Familie von Motorola (r3);
      - P2HEX  und  P2BIN  erlauben  es  jetzt,  den Inhalt einer Code-
        Datei adre·mÑ·ig zu verschieben (r4);
      - einem  SHARED-Befehl anhÑngende Kommentare  werden jetzt in die
        Share-Datei mit Åbertragen (r4);
      - unterstÅtzt zusÑtzlich die 68HC12-Familie von Motorola (r4);
      - unterstÅtzt zusÑtzlich die XA-Familie von Philips (r4);
      - unterstÅtzt zusÑtzlich die 68HC08-Familie von Motorola (r4);
      - unterstÅtzt zusÑtzlich die AVR-Familie von Atmel (r4);
      - aus   KompatibilitÑt   zum   AS11   von   Motorola   existieren
        zusÑtzlich die Befehle FCB, FDB, FCC und RMB (r5);
      - unterstÅtzt zusÑtzlich den M16C von Mitsubishi (r5);
      - unterstÅtzt  zusÑtzlich  den  COP8  von  National Semiconductor
        (r5);
      - zwei  neue Befehle  zur bedingten  Assemblierung: IFB  und IFNB
        (r5);
      - Mit  dem EXITM-Befehl  ist es  nun mîglich, eine Makroexpansion
        vorzeitig abzubrechen (r5);
      - unterstÅtzt zusÑtzlich den MSP430 von Texas Instruments (r5);
      - LISTING  kennt zusÑtzlich  die Varianten  NOSKIPPED und PURECO-
        DE,  um nicht  assemblierten Code  aus dem Listing auszublenden
        (r5);
      - unterstÅtzt zusÑtzlich die 78K0-Familie von NEC (r5);
      - BIGENDIAN ist jetzt auch im PowerPC-Modus verfÅgbar (r5);
      - zusÑtzlich  ein  BINCLUDE-Befehl,  um  BinÑrdaten  einbinden zu
        kînnen (r5);
      - zusÑtzliche  TOLOWER-  und  LOWSTRING-Funktionen,  um  Gro·- in
        Kleinbuchstaben umzuwandeln (r5);
      - es  ist jetzt mîglich,  auch in anderen  Segmenten als CODE Da-
        ten  abzulegen.  Das  Dateiformat  wurde entsprechend erweitert
        (r5);
      - der  DS-Befehl, mit dem  man Speicherbereiche reservieren kann,
        ist jetzt auch im Intel-Modus zulÑssig (r5);
      - Mit  der  Kommandozeilenoption  U  ist  es jetzt mîglich, AS in
        einen  case-sensitiven  Modus  umzuschalten,  in  dem Namen von
        Symbolen,  selbstdefinierten  Funktionen,  Makros, Makroparame-
        tern  sowie  Sektionen  nach  Gro·-  und Kleinschreibung unter-
        schieden werden (r5);
      - SFRB  berÅcksichtigt  jetzt  auch  die  Bildungsregeln fÅr Bit-
        adressen  im RAM-Bereich;  werden nicht  bitadressierbare Spei-
        cherstellen angesprochen, erfolgt eine Warnung (r5);
      - zusÑtzliche  Pseudobefehle PUSHV und  POPV, um Symbolwerte tem-
        porÑr zu sichern (r5);
      - zusÑtzliche  Funktionen  BITCNT,  FIRSTBIT,  LASTBIT und BITPOS
        zur Bitverarbeitung (r5);
      - bei   den   CPU32-Prozessoren   ist   jetzt   auch   der  68360
        berÅcksichtigt (r5);
      - unterstÅtzt zusÑtzlich die ST9-Familie von SGS-Thomson (r6);
      - unterstÅtzt  zusÑtzlich  den  SC/MP  von National Semiconductor
        (r6);
      - unterstÅtzt  zusÑtzlich die TMS70Cxx-Familie  von Texas Instru-
        ments (r6);
      - unterstÅtzt  zusÑtzlich die  TMS9900-Familie von  Texas Instru-
        ments (r6);
      - unterstÅtzt  zusÑtzlich die  Befehlssatzerweiterungen des 80296
        (r6);
      - die unterstÅtzten Z8-Derivate wurden erweitert (r6);
      - berÅcksichtigt  zusÑtzlich die Maskenfehler des 80C504 von Sie-
        mens (r6);
      - zusÑtzliche  Registerdefinitionsdatei fÅr  die C50x-Prozessoren
        von Siemens (r6);
      - unterstÅtzt zusÑtzlich die ST7-Familie von SGS-Thomson (r6);
      - die  Intel-Pseudobefehle  zur  Datenablage  sind jetzt auch fÅr
        65816 bzw. MELPS-7700 zulÑssig (r6);
      - fÅr  65816/MELPS-7700 kann  die Adre·lÑnge  jetzt durch PrÑfixe
        explizit festgelegt werden (r6);
      - unterstÅtzt zusÑtzlich die 8X30x-Familie von Signetics (r6);
      - PADDING  ist nur noch fÅr die 680x0-Familie defaultmÑ·ig einge-
        schaltet (r7);
      - Åber  das  neu  eingefÅhrte,  vordefinierte Symbol ARCHITECTURE
        kann  ausgelesen werden, fÅr welche Plattform AS Åbersetzt wur-
        de (r7);
      - ZusÑtzliche  Anweisungen  STRUCT  und  ENDSTRUCT zur Definition
        von Datenstrukturen (r7);
      - Hex-  und Objekt-Dateien fÅr die  AVR-Tools kînnen jetzt direkt
        erzeugt werden (r7);
      - MOVEC kennt jetzt auch die 68040-Steuerregister (r7);
      - zusÑtzliche  STRLEN-Funktion, um die LÑnge eines Strings zu er-
        mitteln (r7);
      - Mîglichkeit  zur Definition von  Registersymbolen (r7, momentan
        nur Atmel AVR);
      - kennt zusÑtzlich die undokumentierten 6502-Befehle (r7);
      - P2HEX  und P2BIN kînnen jetzt optional die Eingabedateien auto-
        matisch lîschen (r7);
      - P2BIN  kann  der  Ergebnisdatei  optional zusÑtzlich die Start-
        adresse voranstellen (r7);
      - unterstÅtzt  zusÑtzlich die  ColdFire-Familie von  Motorola als
        Variation des 680x0-Kerns (r7);
      - BYT/FCB,  ADR/FDB und  FCC erlauben  jetzt auch  den von DC her
        bekannten Wiederholungsfaktor (r7);
      - unterstÅtzt zusÑtzlich den M*Core von Motorola (r7);
      - der     SH7000-Teil    kennt    jetzt    auch    die    SH7700-
        Befehlserweiterungen (r7);
      - der  680x0-Teil kennt  jetzt auch  die zusÑtzlichen Befehle des
        68040 (r7);
      - der  56K-Teil  kennt  jetzt  auch  die Befehlserweiterungen bis
        zum 56300 (r7).
      - Mit  der  neuen  CODEPAGE-Anweisung  kînnen  jetzt auch mehrere
        Zeichentabellen gleichzeitig verwaltet werden (r8);
      - Die Argumentvarianten fÅr CHARSET wurden erweitert (r8);
      - Neue String-Funktionen SUBSTR und STRSTR (r8);
      - zusÑtzliches IRPC-Statement im Makroprozessor (r8);
      - zusÑtzlicher  RADIX-Befehl, um das Default-Zahlensystem fÅr In-
        teger-Konstanten festzulegen (r8);
      - statt ELSEIF darf auch einfach ELSE geschrieben werden (r8);
      - statt  = darf als Gleichheitsoperator  auch == geschrieben wer-
        den (r8);
      - BRANCHEXT  erlaubt es  beim Philips  XA jetzt,  die Sprungweite
        von kurzen SprÅngen automatisch zu erweitern (r8);
      - Debug-Ausgaben sind jetzt auch im NoICE-Format mîglich (r8);
      - unterstÅtzt zusÑtzlich die i960-Familie von Intel (r8);
      - unterstÅtzt  zusÑtzlich  die  ÊPD7720/7725-Signalprozssoren von
        NEC (r8);
      - unterstÅtzt  zusÑtzlich  den  ÊPD77230-Signalprozssor  von  NEC
        (r8);
      - unterstÅtzt  zusÑtzlich die SYM53C8xx-SCSI-Prozessoren von Sym-
        bios Logic (r8);
      - unterstÅtzt zusÑtzlich den 4004 von Intel (r8);
      - unterstÅtzt zusÑtzlich die SC14xxx-Serie von National (r8);
      - unterstÅtzt  zusÑtzlich  die  Befehlserweiterungen des PPC403GC
        (r8);
      - zusÑtzliche  Kommandozeilenoption  cpu,  um  den Zielprozessor-
        Default zu setzen (r8);
      - Key-Files  kînnen jetzt auch von der Kommandozeile aus referen-
        ziert werden (r8);
      - zusÑtzliche  Kommandozeilenoption  shareout,  um die Ausgabeda-
        tei fÅr SHARED-Definitionen zu setzen (r8);
      - neuer    Pseudobefehl   WRAPMODE,    um   AVR-Prozessoren   mit
        verkÅrztem ProgrammzÑhler zu unterstÅtzen (r8);
      - unterstÅtzt  zusÑtzlich die  C20x-Befehlsuntermenge im C5x-Teil
        (r8);
      - hexadezimale  AdreÑngaben der  Hilfsprogamme kînnen  jetzt auch
        in C-Notation gemacht werden (r8);
      - Das  Zahlensystem fÅr  Integerergebnisse in  \{...}- AusdrÅcken
        ist jetzt per OUTRADIX setzbar (r8);
      - Die  Registersyntax  fÅr  4004-Registerpaare  wurde  korrigiert
        (r8);
      - unterstÅtzt zusÑtzlich die F^2MC8L-Familie von Fujitsu (r8);
      - fÅr  P2HEX  kann  jetzt  die MinimallÑnge fÅr S-Record-Adressen
        angegeben werden (r8);
      - unterstÅtzt zusÑtzlich die ACE-Familie von Fairchild (r8);
      -  REG ist jetzt auch fÅr PowerPCs erlaubt (r8);
      - zusÑtzlicher  Schalter in P2HEX, um  alle Adressen zu verschie-
        ben (r8);
      - Mit  dem Schalter x kann man  jetzt zusÑtzlich in einer zweiten
        Stufe bie betroffene Quellzeile ausgeben (r8).
  - Version 1.42:
      - Die Default-Zahlensyntax fÅr Atmel AVR ist jetzt C-Syntax;
      - zusÑtzliche   Kommandozeilenoption   olist,   um  die  Listing-
        Ausgabedatei zu setzen;
      - unterstÅtzt zusÑtzlich die F^2MC16L-Familie von Fujitsu;
      - zusÑtzlicher Befehl PACKING fÅr die AVR-Familie;
      - zusÑtzliche implizite Makroparameter ALLARGS und ARGCOUNT;
      - zusÑtzlicher  Befehl SHIFT zum Abarbeiten variabler Argumentli-
        sten von Makros;
      - unterstÅtzt temporÑre Symbole;
      - zusÑtzlicher  Befehl MAXNEST zum  Einstellen der maximalen Ver-
        schachtelungstiefe von Makroexpansionen;
      - zusÑtzliche  Kommandozeilenoption noicemask,  um die  Menge der
        in einem NoICE-Debuginfofile gelisteten Segmente zu steuern;
      - unterstÅtzt zusÑtzlich die 180x-Familie von Intersil;
      - unterstÅtzt zusÑtzlich das address windowing des 68HC11K4;
      - P2HEX  kann jetzt die  Adre·feldlÑnge von AVR-Hex-Dateien vari-
        ieren;
      - mit  der neuen  Kommandozeilenoption -gnuerrors  kînnen Fehler-
        meldungen in einem GNU-C-artigen Format ausgegeben werden;
      - unterstÅtzt  zusÑtzlich  die  TMS320C54x-Familie  von Texas In-
        struments;
      - Neue Makro-Option INTLABEL;
      - die  neuen Instruktionen  und Register  der MEGA-AVRs 8/16 wur-
        den hinzugefÅgt;
      -  ENDIF/ENDCASE  zeigen  im  Listing  die  Zeilennummer  des zu-
        gehîrigen îffnenden Befehls an;
      - der  8051-Teil  unterstÅtzt  jetzt  auch  den  erweiterten  Ad-
        re·raum des Dallas DS80C390;
      - namenlose temporÑre Symbole hinzugefÅgt;
      - unterstÅtzt zusÑtzlich die undokumentierten 8085-Befehle;
      - verbesserte Behandlung von Strukturen;
      - Funktion EXPRTYPE() hinzugefÅgt;
      - Zeilenfortsetzungszeichen zulassen;
      - UnterstÅtzung  fÅr KCPSM/PicoBlaze von Andreass Wassatsch inte-
        griert;
      - unterstÅtzt  zusÑtzlich die 807x-Familie  von National Semicon-
        ductor;
      - unterstÅtzt zusÑtzlich den 4040 von Intel;
      - unterstÅtzt zusÑtzlich den eZ8 von Zilog;
      - unterstÅtzt zusÑtzlich die 78K2-Familie von NEC;
      - unterstÅtzt zusÑtzlich die KCPSM3-Variante von Xilinx;
      - unterstÅtzt zusÑtzlich den LatticeMico8;
      - unterstÅtzt  zusÑtzlich  die  12X-Befehlserweiterungen  und den
        XGATE-Kern der 68HC12-Familie;
      - unterstÅtzt zusÑtzlich den Signetics 2650;
      - unterstÅtzt  zusÑtzlich die COP4-Familie  von National Semicon-
        ductor;
      - unterstÅtzt zusÑtzlich die HCS08-Erweiterungen von Freescale;
      - unterstÅtzt zusÑtzlich die RS08-Familie von Freescale;
      - unterstÅtzt zusÑtzlich den 8008 von Intel;
      - weitere Syntax fÅr Integer-Konstanten;
      - Funktion CHARFROMSTR hinzugefÅgt;
      - Q fÅr Oktalkonstanten im Intel-Modus hinzugefÅgt;
      - weitere Variante fÅr temporÑre Symbole hinzugefÅgt;



        I. Hinweise zum Quellcode von AS
        ================================

Wie  in der Einleitung erwÑhnt, gebe  ich nach RÅcksprache den Quellco-
de  von AS heraus. Im folgenden  sollen einige Hinweise zu dessen Hand-
habung gegeben werden.


        I.1. Verwendete Sprache
        -----------------------

UrsprÅnglich  war AS  ein in  Turbo-Pascal geschriebenes  Programm. FÅr
diese  Entscheidung gab es Ende der  80er Jahre eine Reihe von GrÅnden:
Zum  einen  war  ich  damit  wesentlich  vertrauter  als  mit  jedem C-
Compiler,  zum anderen waren  alle C-Compiler unter  DOS verglichen mit
der  IDE von  Turbo-Pascal ziemliche  Schnecken. Anfang  1997 zeichnete
sich  jedoch ab,  da· sich  das Blatt  gewendet hatte:  Zum einen hatte
Borland  beschlossen, die  DOS-Entwickler im  Stich zu lassen (nochmals
ausdrÅcklich  keinen  schînen  Dank,  Ihr  Pappnasen von Borland!), und
Version  7.0  etwas  namens  'Delphi'  nachfolgen lie·en, was zwar wohl
wunderbar  fÅr  Windows-Programme  geeignet  ist,  die zu 90% aus Ober-
flÑche  und zufÑllig auch ein  bi·chen Funktion bestehen, fÅr kommando-
zeilenorientierte  Progamme wie AS aber  reichlich unbrauchbar ist. Zum
anderen  hatte  sich  bereits  vor  diesem  Zeitpunkt  mein betriebssy-
stemmÑ·iger  Schwerpunkt deutlich in Richtung  Unix verschoben, und auf
ein  Borland-Pascal  fÅr  Linux  hÑtte  ich  wohl beliebig lange warten
kînnen  (an alle die, die jetzt sagen, Borland wÅrde ja an soetwas neu-
erdings  basteln:  Leute,  das  ist  Vapourware,  und glaubt den Firmen
nichts,  solange Ihr  nicht wirklich  in den  Laden gehen und es kaufen
kînnt!).  Von daher  war also  klar, da·  der Weg  in Richtung  C gehen
mu·te.

Nach  der Erfahrung, wohin die  Verwendung von Inselsystemen fÅhrt, ha-
be  ich bei der Umsetzung auf C  Wert auf eine mîglichst gro·e Portabi-
litÑt  gelegt; da AS jedoch z.B.  BinÑrdateien in einem bestimmten For-
mat  erzeugen  mu·  und  an  einigen  Stellen betriebssystemspezifische
Funktionen  nutzt, gibt es  einige Stellen, an  denen man anpassen mu·,
wenn man AS zum ersten Mal auf einer neuen Plattform Åbersetzt.

AS  ist  auf  einen  C-Compiler  ausgelegt,  der dem ANSI-Standard ent-
spricht;  C++ ist ausdrÅcklich  nicht erforderlich. Wenn  Sie nur einen
Compiler   nach  dem  veralteten  Kernighan&Ritchie-Standard  besitzen,
sollten  Sie sich nach einem  neuen Compiler umsehen; der ANSI-Standard
ist  seit  1989  verabschiedet  und  fÅr jede aktuelle Plattform sollte
ein  ANSI-Compiler verfÅgbar  sein, zur  Not, indem  man mit  dem alten
Compiler  GNU-C baut.  Im Quellcode  sind zwar  einige Schalter vorhan-
den,  um den Code K&R-nÑher zu machen,  aber dies ist ein nicht offizi-
ell  unterstÅtztes Feature,  das ich  nur intern  fÅr ein  ziemlich an-
tikes  Unix benutze. Alles  weitere zum 'Thema  K&R' steht in der Datei
README.KR.

Der  Sourcenbaum ist durch einige in der Pascal-Version nicht vorhande-
ne  Features (z.B. dynamisch ladbare Nachrichtendateien, Testsuite, au-
tomatische  Generierung der Dokumentation  aus einem Quellformat) deut-
lich  komplizierter geworden.  Ich werde  versuchen, die  Sache Schritt
fÅr Schritt aufzudrîseln:


        I.2. Abfangen von SystemabhÑngigkeiten
        --------------------------------------

Wie  ich schon andeutete, ist AS  (glaube ich jedenfalls...) auf Platt-
formunabhÑngigkeit  und  leichte  Portierbarkeit  getrimmt. Dies bedeu-
tet,  da· man die PlattformunabhÑngigkeiten  in mîglichst wenige Datei-
en  zusammenzieht. Auf diese  Dateien werde ich  im folgenden eingehen,
und  dieser Abschnitt steht ganz vorne,  weil es sicher eines der wich-
tigsten ist:

Die  Generierung aller  Komponenten von  AS erfolgt  Åber ein zentrales
Makefile.  Damit dies funktioniert,  mu· man ihm  ein passendes Makefi-
le.def  anbieten,  das  die  plattformabhÑngigen Einstellungen wie z.B.
Compilerflags  vorgibt.  Im  Unterverzeichnis Makefile.def-samples fin-
den  sich eine Reihe von Includes, die fÅr gÑngige Plattformen funktio-
nieren  (aber nicht zwangsweise  optimal sein mÅssen...).  Wenn die von
Ihnen  benutzte Plattform nicht  dabei ist, kînnen  Sie die Beispielda-
tei  Makefile.def.tmpl  als  Ausgangspunkt  verwenden (und das Ergebnis
mir zukommen lassen!).

Ein  weiterer  Anlaufpunkt  zum  Abfangen  von SystemabhÑngigkeiten ist
die  Datei  sysdefs.h.  Praktisch  alle  Compiler definieren eine Reihe
von  PrÑprozessorsymbolen  vor,  die  den benutzten Zielprozessor sowie
das  benutzte Betriebsystem beschreiben. Auf  einer Sun Sparc unter So-
laris  mit  den  GNU-Compiler  sind  dies  z.B. die Symbole __sparc und
__SVR4.  In sysdefs.h werden diese Symbole  genutzt, um fÅr die restli-
chen,  systemunabhÑngigen Dateien eine  einheitliche Ungebung bereitzu-
stellen.  Insbesondere betrifft  dies Integer-Datentypen  einer bekann-
ten  LÑnge,  es  kann  aber  auch  die  Nach-  oder Redefinition von C-
Funktionen  betreffen, die  auf einer  bestimmten Plattform  nicht oder
nicht  standardgemÑ·  vorhanden  sind.  Was  da  so  an Sachen anfÑllt,
liest  man am besten  selber nach. Generell  sind die #ifdef-Statements
in  zwei Ebenen gegliedert: Zuerst  wird eine bestimmte Prozessorplatt-
form  ausgewÑhlt, dann  werden in  diesem Abschnitt die Betriebssysteme
auseinandersortiert.

Wenn  Sie AS  auf eine  neue Plattform  portieren, mÅssen  Sie zwei fÅr
diese  Plattform typische  Symbole finden  und sysdefs.h passend erwei-
tern (und wieder bin ich an dem Ergebnis interessiert...).


        I.3. SystemunabhÑngige Dateien
        ------------------------------

...stellen  den gî·ten  Teil aller  Module dar.  Alle Funktionen im De-
tail  zu  beschreiben,  wÅrde  den  Rahmen dieser Beschreibung sprengen
(wer  hier mehr  wissen will,  steigt am  besten selbst  in das Studium
der  Quellen  ein,  so  katastrophal  ist mein Programmierstil nun auch
wieder  nicht...), deshalb hier nur eine kurze Auflistung, welche Modu-
le vorhanden sind und was fÅr Funktionen sie beinhalten:


        I.3.1. Von AS genutzte Module
        - - - - - - - - - - - - - - -


        as.c
        ....

Diese  Datei ist  die Wurzel  von AS:  Sie enthÑlt  die main()-Funktion
von    AS,   die   Verarbeitung   aller   Kommandozeilenoptionen,   die
Åbergeordnete  Steuerung aller DurchlÑufe  durch die Quelldateien sowie
Teile des Makroprozessors.


        asmallg.c
        .........

In  diesem Modul werden  all die Befehle  bearbeitet, die fÅr alle Pro-
zessoren  definiert sind, z.B.  EQU und ORG.  Hier findet sich auch der
CPU-Befehl,  mit dem zwischen den einzelnen Prozessoren hin- und herge-
schaltet wird.


        asmcode.c
        .........

In  diesem Modul  befindet sich  die Verwaltung  der Code-Ausgabedatei.
Exportiert  wird  ein  Interface,  mit  dem sich eine Code-Datei îffnen
und   schlie·en   lÑ·t,   und   das   Routinen  zum  Einschreiben  (und
ZurÅcknehmen)  von Code  anbietet. Eine  wichtige Aufgabe dieses Moduls
ist  die Pufferung des  Schreibvorgangs, die die Ausgabegeschwindigkeit
erhîht, indem der erzeugte Code in grî·eren Blîcken geschrieben wird.


        asmdebug.c
        ..........

Optional  kann AS Debug-Informationen fÅr  andere Tools wie Simulatoren
oder  Debugger erzeugen, die  einen RÅckbezug auf  den Quellcode erlau-
ben,  in diesem Modul gesammelt und  nach Ende der Assemblierung in ei-
nem von mehreren Formaten ausgegeben werden kînnen.


        asmdef.c
        ........

Dieses  Modul  enthÑlt  lediglich  Deklarationen von Åberall benîtigten
Konstanten und gemeinsam benutzten Variablen.


        asmfnums.c
        ..........

Intern  vergibt AS fÅr jede  benutzte Quelldatei eine fortlaufende Num-
mer,  die zur schnellen  Referenzierung benutzt wird.  Die Vergabe die-
ser  Nummern  und  die  Umwandlung  zwischen Nummer und Dateinamen pas-
siert hier.


        asmif.c
        .......

Hier  befinden sich alle Routinen, die die bedingte Assemblierung steu-
ern.  Exportiert wird als  wichtigste Variable das  Flag IfAsm, welches
anzeigt, ob Codeerzeugung momentan ein- oder ausgeschaltet ist.


        asminclist.c
        ............

In  diesem Modul ist die Listenstruktur definiert, Åber die AS die Ver-
schachtelung von Include-Dateien im Listing ausgeben kann.


        asmitree.c
        ..........

Wenn  man in einer  Code-Zeile das benutzende  Mnemonic ermitteln will,
ist  das einfache Durchvergleichen mit  allen vorhandenen Befehlen (wie
es  noch in  vielen Codegeneratoren  aus Einfachheit  und Faulheit pas-
siert)  nicht  unbedingt  die  effizienteste  Variante. In diesem Modul
sind  zwei  verbesserte  Strukturen  (BinÑrbaum und Hash-Tabelle) defi-
niert,  die eine effizientere Suche ermîglichen und die einfache linea-
re Suche nach und nach ablîsen sollen...PrioritÑt nach Bedarf...


        asmmac.c
        ........

In  diesem Modul finden  sich die Routinen  zur Speicherung und Abfrage
von  Makros. Der eigentliche Makroprozessor  befindet sich (wie bereits
erwÑhnt) in as.c.


        asmpars.c
        .........

Hier  geht es ins Eingemachte: In  diesem Modul werden die Symboltabel-
len  (global und lokal) in  zwei BinÑrbÑumen verwaltet. Au·erdem findet
sich  hier eine  ziemlich gro·e  Prozedur EvalExpression,  welche einen
(Formel-)ausdruck  analysiert und  auswertet. Die  Prozedur liefert das
Ergebnis  (Integer, Gleitkomma  oder String)  in einem varianten Record
zurÅck.  Zur Auswertung  von AusdrÅcken  bei der  Codeerzeugung sollten
allerdings  eher die  Funktionen EvalIntExpression, EvalFloatExpression
und  EvalStringExpression  verwendet  werden.  énderungen  zum EinfÅgen
neuer  Prozessoren sind  hier nicht  erforderlich und  sollten auch nur
mit  Ñu·erster öberlegung erfolgen, da man hier sozusagen an ,,die Wur-
zel'' von AS greift.


        asmsub.c
        ........

Hier  finden  sich  gesammelt  einige  hÑufig gebrauchte Unterroutinen,
welche  in erster  Linie die  Bereiche Fehlerbehandlung  und 'gehobene'
Stringverarbeitung abdecken.


        bpemu.c
        .......

Wie  am Anfang erwÑhnt,  war AS ursprÅnglich  ein in Borland-Pascal ge-
schriebenes  Programm. Bei einigen  intrinsischen Funktionen des Compi-
lers  war es  einfacher, diese  zu emulieren,  anstatt alle betroffenen
Stelle im Quellcode zu Ñndern. Na ja...


        chunks.c
        ........

Dieses  Modul  definiert  einen  Datentyp,  mit  dem eine Liste von Ad-
re·bereichen  verwaltet  werden  kann.  Diese  Funktion wird von AS fÅr
die  Belegungslisten benîtigt, au·erdem benutzten  P2BIN und P2HEX die-
se Listen, um vor öberlappungen zu warnen.


        cmdarg.c
        ........

Dieses  Modul implementiert den  Mechanismus der Kommdozeilenparameter.
Es  benîtigt eine  Spezifikation der  erlaubten Parameter,  zerlegt die
Kommadozeile  und ruft die entsprechenden  Callbacks auf. Der Mechanis-
mus leistet im einzelnen folgendes:

  - Mitbearbeitung  von  Optionen  in  einer Environment-Variablen oder
    entsprechenden Datei;
  - RÅckgabe  einer Menge, welche die noch nicht bearbeiteten Kommando-
    zeilenparameter beschreibt;
  - Trenunng von positiven und negativen Schaltern;
  - Eine  HintertÅr,  falls  die  darÅberliegende  Entwicklungsumgebung
    die Kommandozeile nur in Gro·- oder Kleinschreibung Åbergibt.

Dieses  Modul wird nicht nur von AS, sondern auch von den Hilfsprogram-
men BIND, P2HEX und P2BIN verwendet.


        codepseudo.c
        ............

Hier  finden sich Pseudobefehle, die  von mehreren Codegeneratoren ver-
wendet  werden.  Dies  ist  einmal  die  Intel-Gruppe  mit  der DB..DT-
Gruppe,  zum  anderen  die  Pendants  fÅr  die 8/16-Bitter von Motorola
oder  Rockwell.  Wer  in  diesem  Bereich  um einen Prozessor erweitern
will,  kann mit  einem Aufruf  den grî·ten  Teil der  Pseudobefehle er-
schlagen.


        codevars.c
        ..........

Aus  SpeicherersparnisgrÅnden sind hier einige von diversen Codegenera-
toren benutzen Variablen gesammelt.


        endian.c
        ........

Doch  noch ein bi·chen  MaschinenabhÑngigkeit, jedoch ein  Teil, um den
man  sich nicht zu kÅmmern braucht:  Ob eine Maschine Little- oder Big-
Endianess  benutzt,  wird  in  diesem  Modul beim Programmstart automa-
tisch  bestimmt. Weiterhin wird geprÅft,  ob die in sysdefs.h gemachten
Typfestlegungen   fÅr  Integervariablen  auch  wirklich  die  korrekten
LÑngen ergeben.


        headids.c
        .........

Gesammelt  sind hier  alle von  AS unterstÅtzten Zielprozessorfamilien,
die  dafÅr in  Code-Dateien verwendeten  Kennzahlen (siehe Kapitel 5.1)
sowie  das von  P2HEX defaultmÑ·ig  zu verwendende  Ausgabeformat. Ziel
dieser   Tabelle  ist   es,  Das   HinzufÅgen  eines  neuen  Prozessors
mîglichst  zu zentralisieren, d.h. es sind  im Gegensatz zu frÅher kei-
ne  weiteren Modifikationen an den  Quellen der Hilfsprogramme mehr er-
forderlich.


        ioerrs.c
        ........

Hier  ist die  Umwandlung von  Fehlernummern in Klartextmeldungen abge-
legt.  Hoffentlich treffe ich  nie auf ein  System, auf dem die Nummern
nicht  als Makros  definiert sind,  dann kann  ich nÑmlich dieses Modul
komplett umschreiben...


        nlmessages.c
        ............

Die  C-Version von  AS liest  alle Meldungen  zur Laufzeit aus Dateien,
nachdem  die  zu  benutzende  Sprache  ermittelt  wurde. Das Format der
Nachrichtendateien  ist kein einfaches, sondern ein spezielles, kompak-
tes,  vorindiziertes Format,  das zur  öbersetzungszeit von  einem Pro-
gramm  namens 'rescomp' (dazu kommen wir noch) erzeugt wird. Dieses Mo-
dul  ist das  GegenstÅck zu  rescomp, die  den korrekten Sprachenanteil
einer  Datei in ein Zeichenfeld  einliest und Zugriffsfunktionen anbie-
tet.


        nls.c
        .....

In   diesem  Modul  wird  ermittelt,  welche  nationalen  Einstellungen
(Datums-  und Zeitformat,  LÑndercode) zur  Laufzeit vorliegen. Das ist
leider  eine hochgradig systemspezifische Sache,  und momentan sind nur
drei  Methoden definiert:  Die von  MS-DOS, die  von OS/2 und die typi-
sche  Unix-Methode Åber die locale-Funktionen.  FÅr alle anderen Syste-
me ist leider NO_NLS angesagt...


        stdhandl.c
        ..........

Zum  einen ist hier eine spezielle open-Funktion gelandet, die die Son-
derstrings  !0...!2 als Dateinamen kennt  und dafÅr Duplikate der Stan-
dard-Dateihandles  stdin, stdout  und stderr  erzeugt, zum anderen wird
hier  festgestellt, ob die Standardausgabe auf  ein GerÑt oder eine Da-
tei  umgeleitet wurde. Das bedingt  auf nicht-Unix-Systemen leider auch
einige Speziallîsungen.


        stringlists.c
        .............

Dies  ist nur ein kleiner ,,Hack'', der Routinen zur Verwaltung von li-
nearen  Listen mit Strings als Inhalt  definiert, welche z.B. im Makro-
prozessor von AS gebraucht werden.


        strutil.c
        .........

Hier sind einige hÑufig genutzte String-Operationen gelandet.


        version.c
        .........

Die  momentan gÅltige Version ist fÅr AS und alle anderen Hilfsprogram-
me hier zentral gespeichert.


        code????.c
        ..........

Dies  Module bilden den Hauptteil  der AS-Quellen: jedes Modul beinhal-
tet den Codegenerator fÅr eine bestimmte Prozessorfamilie.


        I.3.2.  ZusÑtzliche Module fÅr die Hilfsprogramme
        - - - - - - - - - - - - - - - - - - - - - - - - -


        hex.c
        .....

Ein  kleines Modul zur Umwandlung  von Integerzahlen in Hexadezimaldar-
stellung.  In C nicht  mehr unbedingt erforderlich  (au·er zur Wandlung
von   long  long-Variablen,  was  leider   nicht  alle  printf()'s  un-
terstÅtzen),  aber es ist im Rahmen  der Portierung eben auch stehenge-
blieben.


        p2bin.c
        .......

Die Quellen von P2BIN.


        p2hex.c
        .......

Die Quellen von P2HEX.


        pbind.c
        .......

Die Quellen von BIND.


        plist.c
        .......

Die Quellen von PLIST.


        toolutils.c
        ...........

Hier  sind gesammelt  die Unterroutinen,  die von allen Hilfsprogrammen
benîtigt werden, z.B. fÅr das Lesen von Code-Dateien.


        I.4. WÑhrend der Erzeugung von AS gebrauchte Module
        ---------------------------------------------------


        a2k.c
        .....

Dies  ist ein Minimalfilter, das  ANSI-C-Files in Kernighan-Ritchie um-
wandelt.  Um es genau zu sagen:  es werden nur die Funktionskîpfe umge-
wandelt,  und auch nur dann, wenn  sie ungefÑhr so formatiert sind, wie
es  mein Schreibstil eben ist.  Es komme also keiner  auf die Idee, das
wÑre ein universeller C-Parser!


        addcr.c
        .......

Ein  kleiner  Filter,  der  bei  der  Installation  auf DOS- oder OS/2-
Systemen  gebraucht wird. Da DOS und  OS/2 den Zeilenvorschub mit CR/LF
vornehmen,  Unix-Systeme jedoch nur mit  LF, werden sÑmtliche mitgelie-
ferten  Assembler-Includes bei der Installation durch diesen Filter ge-
schickt.


        bincmp.c
        ........

FÅr  DOS und OS/2 Åbernimmt dieses  Modul die Funktion die Funktion des
cmp-Befehls,  d.h. den binÑren Vergleich  von Dateien wÑhrend des Test-
laufes.  WÑhrend  dies  prinzipiell  auch  mit  dem mitgelieferten comp
mîglich  wÑre, hat bincmp keine lÑstigen interaktiven Abfragen (bei de-
nen  man erst einmal herausfinden mu·,  wie man sie auf allen Betriebs-
systemversionen abstellt...)


        findhyphen.c
        ............

Dies  ist das  Untermodul in  tex2doc, da·  fÅr die  Silbentrennung von
Worten  sorgt. Der verwendete Algorithmus  is schamlos von TeX abgekup-
fert.


        grhyph.c
        ........

Die Definition der Silbentrennungsregeln fÅr die deutsche Sprache.


        rescomp.c
        .........

Dies  ist der  'Resourcencompiler' von  AS, d.h.  das Werkzeug, das die
lesbaren  Dateien  mit  Stringresourcen  in  ein schnelles, indiziertes
Format umsetzt.


        tex2doc.c
        .........

Ein  Werkzeug, da· die  LaTeX-Dokumentation von AS  in ein ASCII-Format
umsetzt.


        tex2html.c
        ..........

Ein  Werkzeug, da· die LaTeX-Dokumentation  von AS in ein HTML-Dokument
umsetzt.


        umlaut.c und unumlaut.c
        .......................

Diese  ProgrÑmmchen besorgen die  Wandlung zwischen Sonderzeichenkodie-
rung  im ISO-Format (alle  AS-Dateien verwenden im Auslieferungszustand
die  ISO8859-1-Kodierung fÅr  Sonderzeichen) und Sonderzeichenkodierung
im  systemspezifischen Format.  Neben einer  Plain-ASCII7-Variante sind
dies im Augenblick die IBM-ZeichensÑtze 437 und 850.


        ushyph.c
        ........

Die Definition der Silbentrennungsregeln fÅr die englische Sprache.


        I.5. Generierung der Nachrichtendateien
        ---------------------------------------

Wie  bereits erwÑhnt,  verwendet der  C-Quellenbaum von  AS ein dynami-
sches  Ladeverfahren fÅr alle (Fehler-)Meldungen. GegenÅber den Pascal-
Quellen,  in denen alle  Meldungen in einem  Include-File gebÅndelt wa-
ren  und so  in die  Programme hineinÅbersetzt  wurden, macht es dieses
Verfahren   ÅberflÅssig,  mehrere  sprachliche  Varianten  von  AS  zur
VerfÅgung  zu stellen:  es gibt  nur noch  eine Version,  die beim Pro-
grammstart  die zu benutzende Variante  ermittelt und aus den Nachrich-
tendateien  die entsprechende Komponente lÑdt. Kurz zur Erinnerung: Un-
ter  DOS und  OS/2 wird  dazu die  gewÑhlte COUNTRY-Einstellung zu Rate
gezogen,  unter  Unix  werden  die  Environment-Variablen  LC_MESSAGES,
LC_ALL und LANG befragt.


        I.5.1.  Format der Quelldateien
        - - - - - - - - - - - - - - - -

Eine  Quelldatei  fÅr  den  Message-Compiler  rescomp hat Åblicherweise
die  Endung  .res.  Der  Message-Compiler  erzeugt aus dieser Datei ein
oder zwei Dateien:

  - eine  binÑre Datei, die zur Laufzeit  von AS bzw. den Hilfsprogram-
    men gelesen wird;
  - optional  eine weitere C-Header-Datei,  die allen vorhandenen Nach-
    richten  eine Indexnummer zuweist. öber  diese Indexnummern und ei-
    ne  Indextabelle  in  der  binÑren  Datei kann zur Laufzeit schnell
    auf einzelne Meldungen zugegriffen werden.


Die  Quelldatei fÅr  den Message-Compiler  ist eine  reine ASCII-Datei,
also  mit jedem  beliebigen Editor  bearbeitbar, und  besteht aus einer
Reihe  von Steueranweisungen  mit Parametern.  Leerzeilen sowie Zeilen,
die  mit einem  Semikolon beginnen,  werden ignoriert.  Das Inkludieren
anderer Dateien ist Åber das Include-Statement mîglich:

Include <Datei>


Am  Anfang jeder Quelldatei  mÅssen zwei Statements  stehen, die die im
folgenden  definierten Sprachen beschreiben.  Das wichtigere der beiden
Statements ist Langs, z.B.:

Langs DE(049) EN(001,061)

beschreibt,  da· zwei Sprachen  im folgenden definiert  werden. Der er-
ste  Nachrichtensatz soll benutzt  werden, wenn unter  Unix die Sprache
per  Environment-Variablen auf  DE gestellt  wurde bzw.  unter DOS bzw.
OS/2  der  Landescode  049  eingestellt  wurde.  Der  zweite Satz kommt
dementsprechend  bei den  Einstellungen EN  bzw. 061  oder 001 zum Ein-
satz.  WÑhrend bei den  'Telefonnummern' mehrere Codes  auf einen Nach-
richtensatz   verweisen  kînnen,   ist  die   Zuordnung  zu  den  Unix-
Landescodes  eineindeutig. Dies ist in  der Praxis aber kein Beinbruch,
weil  die LANG-Variablen  unter Unix  Unterversionen einer  Sprache als
AnhÑngsel beschreiben, z.B. so:

de.de
de.ch
en.us

AS  vergleicht nur  den Anfang  der Strings  und kommt  so trotzdem zur
richtigen  Entscheidung. Das Default-Statement  gibt vor, welcher Spra-
chensatz  verwendet werden soll, wenn  entweder Åberhaupt keine Sprache
gesetzt  wurde oder eine  Kennung verwendet wird,  die nicht in der Li-
ste von Langs vorhanden ist. Typischerweise ist dies Englisch:

Default EN

Nach  diesen beiden Definitionen folgt  eine beliebige Menge von Messa-
ge-Statements, d.h. Definitionen von Meldungen:

Message ErrName
 ": Fehler "
 ": error "

Wurden  n Sprachen im Langs-Statement  angekÅndigt, so nimmt der Messa-
ge-Compiler  genau  die  folgenden  n  Zeilen  als  die zu speichernden
Strings.  Es ist also nicht mîglich, bei einzelnen Nachrichten bestimm-
te  Sprachen fortzulassen, und eine  auf die Strings folgende Leerzeile
ist  keinesfalls als Endemarkierung fÅr  die Liste mi·zuverstehen; ein-
gefÅgte  Leerzeilen dienen  einzig und  allein der besseren Lesbarkeit.
Was  allerdings erlaubt ist, ist,  einzelne Meldungen Åber mehrere Zei-
len  in der  Quelldatei zu  verteilen; alle  Zeilen bis  auf die letzte
mÅssen dann mit einem Backslash als Fortsetzungszeichen enden:

Message TestMessage2
 "Dies ist eine" \  
 "zweizeilige Nachricht"
 "This is a" \
 "two-line message"

Wie  bereits erwÑhnt, handelt es sich bei den Quelldateien um reine AS-
CII-Dateien;  Sonderzeichen kînnen in den Meldungstexten zwar eingetra-
gen  werden (und der Compiler wird  sie auch so durchreichen), der gra-
vierende  Nachteil ist aber, da· eine solche Datei nicht mehr voll por-
tabel  ist: Wird sie auf ein anderes System gebracht, das z.B. eine an-
dere  Kodierung fÅr Umlaute  verwendet, bekommt der  Anwender zur Lauf-
zeit  nur merkwÅrdige  Zeichen zu  sehen...Sonderzeichern sollten daher
immer  mit Hilfe von  speziellen Sequenzen geschrieben  werden, die von
HTML  bzw. SGML  entlehnt wurden  (siehe Tabelle  I.1). ZeilenvorschÅbe
kînnen in eine Zeile wie von C her gewohnt mit \n eingebracht werden.

+-----------------------------------------------+-----------------------+
| Sequenz...                                    | ergibt...             |
+-----------------------------------------------+-----------------------+
+-----------------------------------------------+-----------------------+
|  &auml; &ouml; &uuml;                         | Ñ î Å (Umlaute)       |
|  &Auml; &Ouml; &Uuml;                         | é ô ö                 |
|  &szlig;                                      | · (scharfes s)        |
|  &agrave; &egrave; &igrave; &ograve; &ugrave; | † Ç ° ¢ £ (Accent     |
|  &Agrave; &Egrave; &Igrave; &Ograve; &Ugrave; | µ ê ÷ ‡ È grave)      |
|  &aacute; &eacute; &iacute; &oacute; &uacute; | Ö ä ç ï ó (Accent     |
|  &Aacute; &Eacute; &Iacute; &Oacute; &Uacute; | ∑ ‘ ﬁ „ Î agiu)       |
|  &acirc; &ecirc; &icirc; &ocirc; &ucirc;      | É à å ì ñ (Accent     |
|  &Acirc; &Ecirc; &Icirc; &Ocirc; &Ucirc;      | ∂ “ ◊ ‚ Í circonflex) |
|  &ccedil; &Ccedil;                            | á Ä(Cedilla)          |
|  &ntilde; &Ntilde;                            | § •                   |
|  &aring; &Aring;                              | Ü è                   |
|  &aelig; &Aelig;                              | ë í                   |
|  &iquest; &iexcl;                             | umgedrehtes ! oder ?  |
+-----------------------------------------------+-----------------------+

Tabelle I.1: Sonderzeichenschreibweise des rescomp



        I.6. Dokumentationserzeugung
        ----------------------------

In  einer Quellcodedistribution von AS  ist diese Dokumentation nur als
LaTeX-Dokument  enthalten. Andere  Formate werden  aus dieser mit Hilfe
von  mitgelieferten  Werkzeugen  automatisch  erzeugt.  Zum einen redu-
ziert  dies den Umfang einer  Quellcodedistribution, zum anderen mÅssen
énderungen  nicht  an  allen  Formatversionen eines Dokumentes parallel
vorgenommen werden, mit all den Gefahren von Inkonsistenzen.

Als  Quellformat  wurde  LaTeX  verwendet,  weil...weil...weil  es eben
schon  immer vorhanden war. Zudem ist  TeX fast beliebig portierbar und
pa·t  damit recht gut  zum Anspruch von  AS. Eine Standard-Distribution
erlaubt   damit  eine  'ordentliche'  Ausgabe  auf  so  ziemlich  jedem
Drucker;  fÅr eine Konvertierung in  die frÅher immer vorhandene ASCII-
Version  liegt der  Konverter tex2doc  bei; zusÑtzlich  einen Konverter
tex2html, so da· man die Anleitung direkt ins Internet stellen kann.

Die Erzeugung der Dokumentation wird mit einem schlichten

make docs

angesto·en;  daraufhin werden die  beiden erwÑhnten Hilfstools erzeugt,
auf  die TeX-Dokumentation angewandt und  schlu·endlich wird noch LaTeX
selber aufgerufen. Dies natÅrlich fÅr alle Sprachen nacheinander...


        I.7. Testsuite
        --------------

Da  AS mit  binÑren Daten  von genau  vorgegebener Struktur umgeht, ist
er    naturgemÑ·   etwas    empfindlich   fÅr    System-   und   Compi-
lerabhÑngigkeiten.  Um  wenigstens  eine  gewisse  Sicherheit zu geben,
da·  alles korrekt durchgelaufen ist,  liegt dem Assembler im Unterver-
zeichnis  tests  eine  Menge  von  Test-Assemblerquellen bei, mit denen
man  den  frisch  gebauten  Assembler  testen kann. Diese Testprogramme
sind  in erster Linie darauf getrimmt,  Fehler in der Umsetzung des Ma-
schinenbefehlssatzes  zu  finden,  die  besonders gern bei variierenden
WortlÑngen  auftreten. MaschinenunabhÑngige Features  wie der Makropro-
zessor  oder  bedingte  Assemblierung  werden  eher beilÑufig getestet,
weil  ich davon  ausgehe, da·  sie Åberall  funktionieren, wenn sie bei
mir funktionieren...

Der  Testlauf  wird  mit  einem  einfachen  make test angesto·en. Jedes
Testprogramm  wird assembliert,  in eine  BinÑrdatei gewandelt  und mit
einem  Referenz-Image verglichen. Ein Test gilt als bestanden, wenn Re-
ferenz  und die neu erzeugte Datei Bit  fÅr Bit identisch sind. Am Ende
wird  summarisch die Assemblierungszeit fÅr  jeden Test ausgegeben (wer
will,  kann mit diesen Ergebnissen  die Datei BENCHES ergÑnzen), zusam-
men  mit dem Erfolg oder  Mi·erfolg. Jedem Fehler ist  auf den Grund zu
gehen,  selbst wenn  er bei  einem Zielprozessor  auftritt, den Sie nie
nutzen  werden! Es  ist immer  mîglich, da·  dies auf einen Fehler hin-
weist,  der  auch  bei  anderen  Zielprozessoren auftritt, nur zufÑllig
nicht in den TestfÑllen.


        I.8. EinhÑngen eines neuen Zielprozessors
        -----------------------------------------

Der  mit  Abstand  hÑufigste  Grund,  im  Quellcode  von  AS  etwas  zu
verÑndern,  dÅrfte wohl  die Erweiterung  um einen  neuen Zielprozessor
sein.  Neben der ErgÑnzung  der Makefiles um  das neue Modul ist ledig-
lich  eine Modifikation  der Quellen  an wenigen  Stellen erforderlich,
den  Rest erledigt das neue Modul, indem es sich in der Liste der Code-
generatoren  registriert. Im  folgenden will  ich kochbuchartig die zum
EinhÑngen erforderlichen Schritte beschreiben:


        Festlegung des Prozessornamens
        ..............................

Der fÅr den Prozessor zu wÑhlende Name mu· zwei Kriterien erfÅllen:

  1 Der  Name darf noch nicht von  einem anderen Prozessor belegt sein.
    Beim  Aufruf von  AS ohne  Parameter erhÑlt  man eine Liste der be-
    reits vorhandenen Namen.
  2 Soll  der Prozessorname vollstÑndig in der Variablen MOMCPU auftau-
    chen,  so darf  er au·er  am Anfang  keine Buchstaben au·erhalb des
    Bereiches  von A..F  enthalten. In  der Variablen  MOMCPUNAME liegt
    aber  zur Assemblierzeit  immer der  volle Name  vor. Sonderzeichen
    sind  generell  nicht  erlaubt,  Kleinbuchstaben  werden  vom  CPU-
    Befehl  bei der Eingabe  in Gro·buchtaben umgewandelt  und sind da-
    her auch nicht im Prozessornamen sinnvoll.


Der  erste Schritt der Registrierung  ist die Eintragung des Prozessors
oder   der  Prozessorfamilie  in  der   Datei  headids.c.  Wie  bereits
erwÑhnt,  wird diese Datei von  den Hilfsprogrammen mitbenutzt und spe-
zifiziert  die einer Prozessorfamilie zugeordnete Kenn-ID in Codedatei-
en  sowie  das  zu  verwendende  Hex-Format.  Bei  der Wahl der Kenn-ID
wÅrde ich mir etwas Absprache wÅnschen...


        Definition des Codegeneratormoduls
        ..................................

Das  Modul, das fÅr den neuen Prozessor zustÑndig sein soll, sollte ei-
ner  gewissen Einheitlichkeit  wegen den  Namen code....  tragen, wobei
.....  etwas mit dem  Prozessornamen zu tun  haben sollte. Den Kopf mit
den  Includes Åbernimmt man am besten  direkt aus einem bereits vorhan-
denen Codegenerator.

Mit  Ausnahme einer Initialisierungsfunktion, die zu Anfang der main()-
Funktion  im Modul as.c  aufgerufen werden mu·,  braucht das neue Modul
keinerlei  Funktionen oder Variablen zu  exportieren, da die ganze Kom-
munikation  zur Laufzeit  Åber indirekte  SprÅnge abgewickelt wird. Die
dazu  erforderlichen  Registrierungen  mÅssen  in der Initialisierungs-
funktion  des Moduls vorgenommen  werden, indem fÅr  jeden von der Unit
zu behandelnden Prozessortyp ein Aufruf der Funktion AddCPU erfolgt:

   CPUxxxx = AddCPU("XXXX", SwitchTo_xxxx);

'XXXX'  ist dabei  der fÅr  den Prozessor  festgelegte Name, der spÑter
im  Assemblerprogramm verwendet werden  mu·, um AS  auf diesen Zielpro-
zessor    umzuschalten.   SwitchTo_xxxx   (im    folgenden   kurz   als
,,Umschalter''  bezeichnet)  ist  eine  parameterlose Prozedur, die von
AS  aufgerufen wird,  sobald auf  diesen Prozessor  umgeschaltet werden
soll.  Als  Ergebnis  liefert  AddCPU  eine Zahlenwert, der als interne
,,Kennung''  fÅr diesen  Prozessor fungiert.  In der globalen Variablen
MomCPU  wird stÑndig die Kennung  des momentan gesetzten Zielprozessors
mitgefÅhrt.  Der von  AddCPU gelieferte  Wert sollte  in einer privaten
Variable  des  Typs  CPUVar  (hier  CPUxxxx  genannt)  abgelegt werden.
Falls  ein Codegeneratormodul verschiedene  Prozessoren (z.B. einer Fa-
milie)  verwaltet, kann  es so  durch Vergleich  von MomCPU gegen diese
Werte feststellen, welche Befehlsuntermenge momentan zugelassen ist.

Dem   Umschalter   obliegt   es,   AS   auf   den  neuen  Zielprozessor
,,umzupolen''.  Dazu mÅssen im Umschalter  einige globale Variablen be-
setzt werden:

  - ValidSegs  :  Nicht  alle  Prozessoren  definieren  alle von AS un-
    terstÅtzten  Adre·rÑume. Mit dieser Menge legt man fest, welche Un-
    termenge  fÅr den jeweiligen  Prozessor von SEGMENT-Befehl zugelas-
    sen  wird. Im  mindesten mu·  das Code-Segment  freigeschaltet wer-
    den.  Die Gesamtmenge  aller vorhandenen  Segmenttypen kann  in der
    Datei fileformat.h nachgelesen werden (Seg.....-Konstanten).
  - SegInits  : Dieses  Feld speichert  die initialen (ohne ORG-Befehl)
    Startadressen  in  den  einzelnen  Segmenten. Nur in AusnahmefÑllen
    (physikalisch  Åberlappende,  aber  logisch  getrennte  Adre·rÑume)
    sind hier andere Werte als 0 sinnvoll.
  - Grans  : Hiermit  kann fÅr  jedes Segment  die Grî·e  des kleinsten
    adressierbaren  Elements  in  Bytes  festgelegt  werden,  d.h.  die
    Grî·e  des Elements, fÅr das eine  Adresse um eins erhîht wird. Bei
    den  allermeisten Prozessoren  (auch 16  oder 32  Bit) ist dies ein
    Byte,  nur z.B. Signalprozessoren und die  PICs fallen aus dem Rah-
    men.
  - ListGrans  : Hiermit kann wieder fÅr alle Segmente getrennt festge-
    legt  werden, in was fÅr Gruppen die Bytes im Assemblerlisting dar-
    gestellt  werden  sollen.  Beim  68000  sind z.B. Befehle immer ein
    mehrfaches  von 2  Bytes lang,  weshalb die  entsprechende Variable
    auf 2 gesetzt ist.
  - SegLimits  : Dieses  Feld legt  die hîchste  Adresse fÅr jedes Seg-
    ment  fest,  z.B.  65535  fÅr  einen  16-Bit-Adre·raum. Dieses Feld
    braucht  nicht  ausgefÅllt  zu  werden,  wenn der Codegenerator die
    ChkPC-Methode selber Åbernimmt.
  - ConstMode  : Diese Variable kann die Werte ConstModeIntel, ConstMo-
    deMoto  oder ConstModeC haben und bestimmt, in welcher Form Zahlen-
    systeme  bei Integerkonstanten  spezifiziert werden  sollen (sofern
    das Programm nicht vom Relaxed-Modus Gebrauch macht).
  - PCSymbol  : Diese Variable enthÑlt den  String, mit dem aus dem As-
    sembler-Programm  heraus  der  momentane  Stand des ProgrammzÑhlers
    abgefragt  werden  kann.  FÅr  Intel-Prozessoren  ist dies z.B. ein
    Dollarzeichen.
  - TurnWords  :  Falls  der  Prozessor  ein  Big-Endian-Prozessor sein
    sollte  und  eines  der  Elemente  von ListGrans ungleich eins ist,
    sollte  dieses  Flag  auf  True  gesetzt  werden, um korrekte Code-
    Dateien zu erhalten.
  - SetIsOccupied  : Einige Prozessoren  verwenden SET als Maschinenbe-
    fehl.  Ist diese Variable  gesetzt, so gibt  AS SET -Befehle an den
    Codegenerator weiter und verwendet stattdessen EVAL.
  - HeaderID  : Dieses Byte enthÑlt die Kennung, mit der in der Codeda-
    tei  die  Prozessorfamilie  gekennzeichnet  wird  (siehe  Abschnitt
    5.1).  Um Zweideutigkeiten  zu vermeiden,  bitte ich,  den Wert mit
    mir  abzusprechen. Bis  auf weiteres  sollten keine Werte au·erhalb
    des  Bereiches  $01..$7f  benutzt  werden,  diese  sind fÅr Sonder-
    zwecke  (wie z.B. eine zukÅnftige  Erweiterung um einen Linker) re-
    serviert.  Auch wenn dieser Wert in den meisten Ñlteren Codegenera-
    toren  hart gesetzt wird, ist es  die heute bevorzugte Methode, den
    Wert aus headids.h per FindFamilyByName zu holen.
  - NOPCode  : In bestimmten Situationen kann es sein, da· AS unbenutz-
    te  Bereiche im Code  mit NOPs auffÅllen  mu·. Diese Variable bein-
    haltet den dazu erforderlichen Code.
  - DivideChars  :  Dieser  String  enthÑlt  all  jene Zeichen, die als
    Trennzeichen  fÅr die  Parameter eines  Assemblerbefehls zugelassen
    sind.  Nur fÅr  extreme Ausrei·er  (wie den  DSP56) sollte  sich in
    diesem String etwas anderes finden als ein Komma.
  - HasAttrs  : Einige Prozessoren  wie die 68k-Reihe  teilen einen Ma-
    schinenbefehl  durch einen Punkt noch weiter in Mnemonic und Attri-
    but  auf. Ist dies beim neuen Prozessor  auch der Fall, so ist die-
    ses  Flag auf  True zu  setzen. AS  liefert dann die Einzelteile in
    den  Variablen OpPart und  AttrPart. Setzt man  es dagegen auf Fal-
    se,  so bleibt der Befehl in  OpPart zusammen, und AttrPart ist im-
    mer  leer. Sofern  der Prozessor  keine Attribute verwendet, sollte
    man  HasAttrs auf  jeden Fall  auf False  setzen, da man sich sonst
    die  Mîglichkeit nimmt, Makros  mit einem Punkt  im Namen (z.B. zur
    Emulation anderer Assembler) zu definieren.
  - AttrChars  : Falls HasAttrs gesetzt  wurde, mÅssen in diesem String
    alle  Zeichen eingetragen werden, die das Attribut vom Befehl tren-
    nen kînnen. Meist ist dies nur der Punkt.

Gehen  Sie nicht  davon aus,  da· eine  dieser Variablen einen vordefi-
nierten Wert hat, sondern besetzen Sie ALLE Felder neu!!

Neben  diesen  Variablen  mÅssen  noch  einige  Funktionszeiger besetzt
wird, mit denen der Codegenerator sich in AS einbindet:

  - MakeCode  : Diese  Routine wird  nach der  Zerlegung einer Zeile in
    Mnemonic  und Parameter aufgerufen.  Das Mnemonic liegt  in der Va-
    riablen  OpPart, die Parameter in dem Feld ArgStr. Die Zahl der Pa-
    rameter  kann  aus  der  Variablen  ArgCnt  ausgelesen  werden. Das
    binÑre  Ergebnis  mu·  in  dem  Byte-Feld BAsmCode abgelegt werden,
    dessen  LÑnge in der  Variablen CodeLen. Falls  der Prozessor wort-
    orientiert  wie der  68000 oder  viele Signalprozessoren  ist, kann
    Feld  auch wortweise als  WAsmCode adressiert werden.  FÅr ganz ex-
    treme  FÑlle gibt es auch noch DAsmCode... Die CodelÑnge wird eben-
    falls in solchen Einheiten angegeben.
  - SwitchFrom:  Diese parameterlose  Prozedur erlaubt  dem Codegenera-
    tormodul,  noch ,,AufrÑumarbeiten''  durchzufÅhren, wenn  auf einen
    anderen  Zielprozessor  umgeschaltet  wird.  So  kann man an dieser
    Stelle  z.B.  Speicher  freigeben,  der  im Umschalter belegt wurde
    und  nur  benîtigt  wird,  wÑhrend  dieses Codegeneratormodul aktiv
    ist.  Im  einfachsten  Fall  zeigt  diese Prozedurvariable auf eine
    leere  Prozedur.  Ein  Beispiel  fÅr  die Anwendung dieser Prozedur
    finden  Sie im Modul CODE370,  das seine Codetabellen dynamisch er-
    zeugt und wieder freigibt.
  - IsDef  : Bestimmte Prozessoren kennen neben EQU noch weitere Pseud-
    obefehle,  bei denen ein in  der ersten Spalte stehender Symbolname
    kein  Label darstellt, z.B. BIT beim  8051. Diese Funktion mu· TRUE
    zurÅckliefern,  falls  ein  solcher,  zusÑtzlicher Befehl vorliegt.
    Im einfachsten Fall braucht nur FALSE zurÅckgeliefert zu werden.


Optional  kann ein Codegenerator auch  noch folgende weitere Funktions-
zeiger besetzen:

  - ChkPC  :  Obwohl  AS  die  ProgrammzÑhler intern durchgÑngig mit 32
    oder  64 Bit verwaltet, benutzen  die meisten Prozessoren nur einen
    kleineren  Adre·raum. Diese  Funktion liefert  AS Informationen, ob
    der  momentane ProgrammzÑhler  den erlaubten  Bereich Åberschritten
    hat.  Bei Prozessoren  mit mehreren  Adre·rÑumen kann diese Routine
    natÅrlich  deutlich  komplizierter  ausfallen.  Ein  Beispiel dafÅr
    findet  sich  z.B.  im  Modul  code16c8x.c.  Falls alles in Ordnung
    ist,  mu· die  Funktion TRUE  zurÅckliefern, ansonsten FALSE. Diese
    Funktion  mu·  ein  Codegenerator  nur  implementieren, wenn er das
    Feld  SegLimits nicht belegt. Das  kann z.B. notwendig werden, wenn
    der  gÅltige  Adre·bereich  eines  Segments  nicht  zusammenhÑngend
    ist.
  - InternSymbol  : Manche Prozessoren, z.B. solche mit einer Register-
    bank  im internen RAM, defineren  diese 'Register' als Symbole vor,
    und  es wÅrde wenig Sinn machen,  diese in einer separaten Include-
    Datei  mit 256  oder mîglicherweise  noch mehr  EQUs zu definieren.
    Mit  dieser Funktion erhÑlt  man Zugang zum  Formel- Parser von AS:
    Sie  erhÑlt den Ausdruck  als ASCII-String, und  wenn sie eines der
    'eingebauten  Symbole' erkennt,  besetzt sie  die Åbergebene Struk-
    tur  des Typs TempResult entsprechend.  Falls die öberprÅfung nicht
    erfolgreich  war, mu· deren  Element Typ auf  TempNone gesetzt wer-
    den.  Die Routine sollte  im Falle eines  Mi·erfolges keine Fehler-
    meldungen  ausgeben, weil dies immer  noch anderweitig gÅltige Sym-
    bole  sein kînnen. Seien Sie  extrem vorsichtig mit dieser Routine,
    da sie einen Eingriff in den Parser darstellt!


Wer  will, kann sich Åbrigens  auch mit einem Copyright-Eintrag verewi-
gen,  indem  er  in  der  Initialisierung  des  Moduls (bei den AddCPU-
Befehlen)  einen Aufruf der Prozedur  AddCopyright einfÅgt, in der fol-
genden Art:

    AddCopyright("Intel 80986-Codegenerator (C) 2010 Hubert Simpel");

Der  Åbergebene String wird  dann nach dem  Programmstart zusÑtzlich zu
der Standardmeldung ausgegeben.

Bei  Bedarf kann  sich das  Modul im  Initialisierungsteil noch  in die
Kette  aller  Funktionen  eintragen,  die  vor Beginn eines Durchlaufes
durch  den Quelltext  ausgefÅhrt werden.  Dies ist  z.B. immer dann der
Fall,  wenn die Code-Erzeugung im  Modul abhÑngig vom Stand bestimmter,
durch  Pseudobefehle beeinflu·barer Flags  ist. Ein hÑufig auftretender
Fall  ist z.B., da· ein Prozessor im User- oder Supervisor-Modus arbei-
ten  kann, wobei im User-Modus bestimmte  Befehle gesperrt sind. Im As-
sembler-Quelltext  kînnte  dieses  Flag,  das  angibt, in welchem Modus
der  folgende Code ausgefÅhrt wird, durch einen Pseudobefehl umgeschal-
tet  werden. Es ist aber dann immer noch eine Initialisierung erforder-
lich,  die sicherstellt, da· in  allen DurchlÑufen ein identischer Aus-
gangszustand  vorliegt. Der Åber den Funktionszeiger InitPassProc ange-
botene  Haken bietet die  Mîglichkeit, derartige Initialisierungen vor-
zunehmen.  Das verwendete Prinzip  Ñhnelt dabei dem  EinhÑngen in einen
Interruptvektor:  In der  Initialisierung der  Unit wird  der alte Wert
von  InitPassProc gesichert.  Danach kann  InitPassProc auf  die hinzu-
zufÅgende  Funktion  (parameterlos,  kein  RÅckgabewert) umgebogen wer-
den.  Die neue Routine ruft dann zuerst die alte Initialisierungsrouti-
ne auf und fÅhrt danach ihre eigenen Operationen durch.

Analog  zu  InitPassProc  funktioniert  die Åber CleanUpProc aufgebaute
Funktionskette,  die es den Codegeneratoren  erlaubt, nach dem Abschlu·
der  Assemblierung noch  AufrÑumarbeiten (z.B.  das Freigeben von Lite-
raltabellen  o.Ñ.) durchzufÅhren.  Dies ist  sinnvoll, wenn mehrere Da-
teien  mit  einem  Aufruf  assembliert  werden,  sonst  hÑtte  man noch
,,MÅll''  aus einem vorigen  Lauf in den  Tabellen. Momentan nutzt kein
Modul diese Mîglichkeit.


        Schreiben des Codegenerators selber
        ...................................

Nach  diesen PrÑliminarien ist nun  endlich eigene KreativitÑt gefragt:
Wie  Sie es  schaffen, aus  dem Mnemonic  und den  Argumenten die Code-
Bytes  zu erzeugen, ist weitgehend Ihnen Åberlassen. Zur VerfÅgung ste-
hen  dafÅr  natÅrlich  Åber  den  Formelparser die Symboltabellen sowie
die  Routinen aus asmsub.c und asmpars.c.  Ich kann hier nur einige ge-
nerelle Hinweise geben:

  - Versuchen  Sie, die Prozessorbefehle  in Gruppen aufzusplitten, die
    gleiche  Operanden erwarten und sich nur in einigen Kennbits unter-
    scheiden.  Alle argumentlosen Befehle kann man z.B. so in einer Ta-
    belle abhandeln.
  - Die  meisten Prozessoren haben ein  festes Repertoire von Adressie-
    rungsarten.  Verlagern Sie das Parsing  eines Adre·ausdrucks in ei-
    ne getrennte Unterroutine.
  - Die  Routine WrError definiert eine  Vielzahl von mîglichen Fehler-
    meldungen  und ist bei  Bedarf leicht erweiterbar.  Nutzen Sie das!
    Bei  allen  Fehler  nur  lapidar  einen ,,Syntaxfehler'' zu melden,
    nÅtzt niemandem!

Mit  Sicherheit wird auch das Studium der vorhandenen Module weiterhel-
fen.


        énderungen fÅr die Dienstprogramme
        ..................................

Eine  winzige énderung ist auch noch  an den Quellen der Dienstprogram-
me  nîtig, und zwar in der  Routine Granularity() in toolutils.c: Falls
eines  der Adre·rÑume dieses Prozessors  eine andere GranularitÑt als 1
hat,  mu·  dort  die  Abfrage  passend  ergÑnzt werden, sonst verzÑhlen
sich PLIST, P2BIN und P2HEX...


        I.9. Lokalisierung auf eine neue Sprache
        ----------------------------------------

Sie  haben Interesse  an diesem  Thema? Wunderbar!  Das ist eine Sache,
die  von Programmierern  gerne au·en  vor gelassen  wird, insbesondere,
wenn sie aus dem Land der unbegrenzten Mîglichkeiten kommen...

Die  Lokalisierung auf eine  neue Sprache gliedert  sich in zwei Teile:
Die  Anpassung der  Programmmeldungen sowie  die öbersetzung der Anlei-
tung.  Letzteres  ist  sicherlich  eine  Aufgabe herkulischen Ausma·es,
aber  die Anpassung der Programmeldungen solle in ein bis zwei Nachmit-
tagen  Åber die BÅhne  zu bekommen sein,  wenn man sowohl  die neue als
auch  eine der  bisher vorhandenen  Sprachen gut  kennt. Leider ist die
öbersetzung  auch nichts,  was man  StÅck fÅr  StÅck machen  kann, denn
der  Ressourcencompiler kann im  Moment nicht mit  einer variablen Zahl
von  Sprachen  in  den  verschiedenen  Meldungen umgehen, es hei·t also
'alles oder nichts'.

Als  erstes ergÑnzt  man in  header.res die  neue Sprache.  Die fÅr die
Sprache  passende zweibuchstabige AbkÅrzung holt  man sich vom nÑchsten
Unix-System  (wenn man nicht ohnehin  darauf arbeitet...), die interna-
tionale Vorwahl aus dem nÑchsten DOS-Handbuch.

Im  zweiten Schritt geht man jetzt  durch alle anderen .res-Dateien und
ergÑnzt  die  Message-Statements.  Nocheinmal  sei  darauf hingewiesen,
Sonderzeichen  in der HTML-artigen Schreibweise und nicht direkt einzu-
setzen!

Wenn  dies geschafft ist, kann man mit einem make alle betroffenen Tei-
le  neu bauen und erhÑlt danach  einen Assembler, der eine Sprache mehr
schickt.  Bitte nicht  vergessen, die  Ergebnisse an  mich weiterzulei-
ten, damit mit der nÑchsten Release alle etwas davon haben :-)



        Literaturverzeichnis
        ====================

[ 1] Steve Williams:
     68030 Assembly Language Reference.
     Addison-Wesley, Reading, Massachusetts, 1989

[ 2] Advanced Micro Devices:
     AM29240, AM29245, and AM29243 RISC Microcontrollers.
     1993

[ 3] Atmel Corp.:
     AVR Enhanced RISC Microcontroller Data Book.
     May 1996

[ 4] Atmel Corp.:
     8-Bit   AVR   Assembler   and   Simulator   Object   File  Formats
     (Preliminary).
     (Teil der AVR-Tools-Dokumentation)

[ 5] CMD Microcircuits:
     G65SC802  /  G65SC816  CMOS  8/16-Bit  Microprocessor  Family Data
     Sheet.

[ 6] National Semiconductor:
     COP410L/COP411L/COP310L/COP311L  Single-Chip  N-Channel  Microcon-
     trollers. RRD-B30M105, March 1992

[ 7] National Semiconductor:
     COPS Family User's Guide.

[ 8] Digital Research :
     CP/M 68K Operating System User's Guide.
     1983

[ 9] Cyrix Corp. :
     FasMath 83D87 User's Manual.
     1990

[10] Dallas Semiconductor:
     DS80C320 High-Speed Micro User's Guide.
     Version 1.30, 1/94

[11] Fairchild Semiconductor:
     ACE1101 Data Sheet.
     Preliminary, May 1999

[12] Fairchild Semiconductor:
     ACE1202 Data Sheet.
     Preliminary, May 1999

[13] Fairchild Semiconductor:
     ACEx  Guide  to  Developer  Tools.  AN-8004, Version 1.3 September
     1998

[14] Freescale Semiconductor:
     S12XCPUV1 Reference Manual. S12XCPUV1, v01.01, 03/2005

[15] Freescale Semiconductor:
     RS08 Core Reference Manual. RS08RM, Rev. 1.0, 04/2006

[16] Freescale Semiconductor:
     MC9S12XDP512 Data Sheet. MC9S12XDP512, Rev. 2.11, 5/2005

[17] Fujitsu Limited:
     June 1998 Semiconductor Data Book.
     CD00-00981-1E

[18] Fujitsu Semiconductor:
     F˝MC16LX  16-Bit Microcontroller MB90500  Series Programming Manu-
     al.
     CM44-00201-1E, 1998

[19] Hitachi Ltd. :
     8-/16-Bit Microprocessor Data Book.
     1986

[20] Trevor J.Terrel & Robert J. Simpson :
     Understanding HD6301X/03X CMOS Microprocessor Systems.
     erschienen bei Hitachi

[21] Hitachi Microcomputer:
     H8/300H Series Programming Manual.
     (21-032, keine Jahresangabe)

[22] Hitachi Semiconductor Design & Development Center:
     SH Microcomputer Hardware Manual (Preliminary).

[23] Hitachi Semiconductor and IC Div.:
     SH7700 Series Programming Manual.
     1st Edition, September 1995

[24] Hitachi Semiconductor and IC Div.:
     H8/500 Series Programming Manual.
     (21-20, 1st Edition Feb. 1989)

[25] Hitachi Ltd.:
     H8/532 Hardware Manual.
     (21-30, keine Jahresangabe)

[26] Hitachi Ltd.:
     H8/534, H8/536 Hardware Manual.
     (21-19A, keine Jahresangabe)

[27] IBM Corp.:
     PPC403GA Embedded Controller User's Manual.
     First Edition, September 1994

[28] Intel Corp. : Embedded Controller Handbook.
     1987

[29] Intel Corp. :
     Microprocessor and Peripheral Handbook.
     Volume I Microprocessor, 1988

[30] Intel Corp. :
     80960SA/SB Reference Manual.
     1991

[31] Intel Corp.:
     8XC196NT Microcontroller User's Manual.
     June 1995

[32] Intel Corp.:
     8XC251SB High Performance CHMOS Single-Chip Microcontroller.
     Sept. 1995, Order Number 272616-003

[33] Intel Corp.:
     80296SA Microcontroller User's Manual.
     Sept. 1996

[34] Intel Corp.:
     4040: Single-Chip 4-Bit P-Channel Microprocessor.
     (keine Jahresangabe)

[35] Intersil:
     CDP1802A, CDP1802AC, CDP1802BC CMOS 8-Bit Microprocessors.
     March 1997

[36] Intersil:
     CDP1805AC,  CDP1806AC CMOS  8-Bit Microprocessor  with On-Chip RAM
     and Counter/Timer.
     March 1997

[37] Hirotsugu Kakugawa:
     A memo on the secret features of 6309.
     (erhÑltlich Åber WWW:
     http://www.cs.umd.edu/users/fms/comp/CPUs/6309.txt)

[38] Lattice Semiconductor Corporation:
     LatticeMico8 Microcontroller Users Guide.
     Reference Design RD1026, February 2008

[39] Microchip Technology Inc.:
     Microchip Data Book.
     1993 Edition

[40] Mitsubishi Electric:
     Single-Chip 8-Bit Microcomputers
     Vol.2, 1987

[41] Mitsubishi Electric:
     Single-Chip 16-Bit Microcomputers.
     Enlarged edition, 1991

[42] Mitsubishi Electric:
     Single-Chip 8 Bit Microcomputers.
     Vol.2, 1992

[43] Mitsubishi Electric:
     M34550Mx-XXXFP Users's Manual.
     Jan. 1994

[44] Mitsubishi Electric:
     M16 Family Software Manual.
     First Edition, Sept. 1994

[45] Mitsubishi Electric:
     M16C Software Manual.
     First Edition, Rev. C, 1996

[46] Mitsubishi Electric:
     M30600-XXXFP Data Sheet.
     First Edition, April 1996

[47] Dokumentation  zum M16/M32-Entwicklungspaket von Green Hills Soft-
     ware

[48] Motorola Inc. :
     Microprocessor, Microcontroller and Peripheral Data.
     Vol. I+II, 1988

[49] Motorola Inc. :
     MC68881/882 Floating Point Coprocessor User's Manual.
     Prentice-Hall, Englewood Cliffs, Second Edition 1989

[50] Motorola Inc. :
     MC68851 Paged Memory Management Unit User's Manual.
     Prentice-Hall, Englewood Cliffs, Second Edition 1989

[51] Motorola Inc.:
     CPU32 Reference Manual.
     Rev. 1, 1990

[52] Motorola Inc.:
     DSP56000/DSP56001 Digital Signal Processor User's Manual.
     Rev. 2, 1990

[53] Motorola Inc.:
     MC68340 Technical Summary.
     Rev. 2, 1991

[54] Motorola Inc.:
     CPU16 Reference Manual.
     Rev. 1, 1991

[55] Motorola Inc.:
     Motorola M68000 Family Programmer's Reference Manual.
     1992

[56] Motorola Inc.:
     MC68332 Technical Summary.
     Rev. 2, 1993

[57] Motorola Inc.:
     PowerPC 601 RISC Microprocessor User's Manual.
     1993

[58] Motorola Inc.:
     PowerPC(tm) MPC505 RISC Microcontroller Technical Summary.
     1994

[59] Motorola Inc.:
     CPU12 Reference Manual.
     1st. edition, 1996

[60] Motorola Inc.:
     CPU08 Reference Manual.
     Rev. 1 (keine Jahresangabe im PDF-File)

[61] Motorola Inc.:
     MC68360 User's Manual.

[62] Motorola Inc.:
     MCF 5200 ColdFire Family Programmer's Reference Manual.
     1995

[63] Motorola Inc.:
     M*Core Programmer's Reference Manual.
     1997

[64] Motorola Inc.:
     DSP56300 24-Bit Digital Signal Processor Family Manual.
     Rev. 0 (keine Jahresangabe im PDF-File)

[65] Motorola Inc.:
     MC68HC11K4 Technical Data. 1992

[66] National Semiconductor:
     SC/MP Programmier- und Assembler-Handbuch.
     Publication Number 4200094A, Aug. 1976

[67] National Semiconductor:
     COP800 Assembler/Linker/Librarian User's Manual.
     Customer  Order  Number  COP8-ASMLNK-MAN,  NSC  Publication Number
     424421632-001B, August 1993

[68] National Semiconductor:
     COP87L84BC  microCMOS  One-Time-Programmable  (OTP)  Microcontrol-
     ler.
     Preliminary, March 1996

[69] National Semiconductor:
     SC14xxx DIP commands Reference guide.
     Application Note AN-D-031, Version 0.4, 28.12.1998

[70] National Semiconductor:
     INS8070-Series Microprocessor Family. October 1980

[71] NEC Corp.:
     ÊpD70108 / ÊpD70116 / ÊpD70208 / ÊpD70216 / ÊpD72091 Data Book.
     (keine Jahresangabe)

[72] NEC Electronics Europe GmbH:
     User's Manual ÊCOM-87 AD Family.
     (keine Jahresangabe)

[73] NEC Corp.:
     ÊCOM-75x Family 4-bit CMOS Microcomputer User's Manual.
     Vol. I+II (keine Jahresangabe)

[74] NEC Corp.:
     Digital Signal Processor Product Description.
     PDDSP.....067V20 (keine Jahresangabe)

[75] NEC Corp.:
     ÊPD78070A,  78070AY 8-Bit Single-Chip Microcontroller User's Manu-
     al.
     Document No. U10200EJ1V0UM00 (1st edition), August 1995

[76] NEC Corp.:
     Data Sheet ÊPD78014.

[77] NEC Corp.:
     78K/II  Series 8-Bit  Single-Chip Microcontroller  User's Manual -
     Instructions.
     Document No. U10228EJ6V0UM00 (6th edition), December 1995

[78] Philips Semiconductor:
     16-bit 80C51XA Microcontrollers (eXtended Architecture).
     Data Handbook IC25, 1996

[79] SGS-Thomson Microelectronics:
     8 Bit MCU Families EF6801/04/05 Databook.
     1st edition, 1989

[80] SGS-Thomson Microelectronics:
     ST6210/ST6215/ST6220/ST6225 Databook.
     1st edition, 1991

[81] SGS-Thomson Microelectronics:
     ST7 Family Programming Manual.
     June 1995

[82] SGS-Thomson Microelectronics:
     ST9 Programming Manual.
     3rd edition, 1993

[83] Siemens AG:
     SAB80C166/83C166 User's Manual.
     Edition 6.90

[84] Siemens AG:
     SAB C167 Preliminary User's Manual.
     Revision 1.0, July 1992

[85] Siemens AG:
     SAB-C502 8-Bit Single-Chip Microcontroller User's Manual.
     Edition 8.94

[86] Siemens AG:
     SAB-C501 8-Bit Single-Chip Microcontroller User's Manual.
     Edition 2.96

[87] Siemens AG:
     C504 8-Bit CMOS Microcontroller User's Manual.
     Edition 5.96

[88] C.Vieillefond:
     Programmierung des 68000.
     Sybex-Verlag DÅsseldorf, 1985

[89] Symbios Logic Inc:
     Symbios Logic PCI-SCSI-I/O Processors Programming Guide.
     Version 2.0, 1995/96

[90] Texas Instruments:
     Model  990 Computer/TMS9900 Microprocessor  Assembly Language Pro-
     grammer's Guide.
     1977, Manual No. 943441-9701

[91] Texas Instruments:
     TMS9995 16-Bit Microcomputer Preliminary Data Manual.
     1981

[92] Texas Instruments:
     First-Generation TMS320 User's Guide.
     1988, ISBN 2-86886-024-9

[93] Texas Instruments:
     TMS7000 family Data Manual.
     1991, DB103

[94] Texas Instruments:
     TMS320C3x User's Guide.
     Revision E, 1991

[95] Texas Instruments:
     TMS320C2x User's Guide.
     Revision C, Jan. 1993

[96] Texas Instruments:
     TMS370 Family Data Manual.
     1994, SPNS014B

[97] Texas Instruments:
     MSP430 Family Software User's Guide.
     1994, SLAUE11

[98] Texas Instruments:
     MSP430 Metering Application.
     1996, SLAAE10A

[99] Texas Instruments:
     MSP430 Family Architecture User's Guide.
     1995, SLAUE10A

[100] Texas Instruments:
     TMS320C62xx CPU and Instruction Set Reference Manual.
     Jan. 1997, SPRU189A

[101] Texas Instruments:
     TMS320C20x User's Guide.
     April 1999, SPRU127C

[102] Texas Instruments:
     TMS320C54x DSP Reference Set; Volume 1: CPU and Peripherals.
     March 2001, SPRU172C

[103] Texas Instruments:
     TMS320C54x DSP; Volume 2: Mnemonic Instruction Set.
     March 2001, SPRU172C

[104] Toshiba Corp.:
     8-Bit Microcontroller TLCS-90 Development System Manual.
     1990

[105] Toshiba Corp.:
     8-Bit Microcontroller TLCS-870 Series Data Book.
     1992

[106] Toshiba Corp.:
     16-Bit Microcontroller TLCS-900 Series Users Manual.
     1992

[107] Toshiba Corp.:
     16-Bit Microcontroller TLCS-900 Series Data Book:
     TMP93CM40F/TMP93CM41F.
     1993

[108] Toshiba Corp.:
     4-Bit  Microcontroller TLCS-47E/47/470/470A Development System Ma-
     nual.
     1993

[109] Toshiba Corp.:
     TLCS-9000/16 Instruction Set Manual Version 2.2.
     10. Feb 1994

[110] Valvo GmbH:
     Bipolare Mikroprozessoren und bipolare LSI-Schaltungen.
     Datenbuch, 1985, ISBN 3-87095-186-9

[111] Ken Chapman (Xilinx Inc.):
     PicoBlaze  8-Bit Microcontroller  for Virtex-E  and Spartan-II/IIE
     Devices.
     Application Note XAPP213, Version 2.1, February 2003

[112] Xilinx Inc.:
     PicoBlaze  8-bit Embedded Microcontroller  User Guide for Spartan-
     3, Virtex-II, and Virtex-II Pro FPGAs.
     UG129 (v1.1) June 10, 2004

[113] DatenblÑtter der Firma Zilog zur Z80-Familie

[114] Zilog Inc.:
     Z8 Microcontrollers Databook.
     1992

[115] Zilog Inc.:
     Discrete Z8 Microcontrollers Databook.
     (keine Jahresangabe)

[116] Zilog Inc.:
     Z380 CPU Central Processing Unit User's Manual.
     (keine Jahresangabe)

[117] Zilog Inc.:
     eZ8 CPU User Manual.
     UM01285-0503




    ''Ich schlage vor, dem Parlament ein Gesetz vorzulegen,
    das einem Autor, der ein Buch ohne Index publiziert,
    das Copyright entzieht und ihn au·erdem fÅr sein Vergehen
    mit einer Geldstrafe belegt.''
              --Lord John Campbell



