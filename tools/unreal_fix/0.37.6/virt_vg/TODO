>>     Итого набор портов должен быть по логике такой:
>>     1F по записи пробрасывется в порт 9F, по чтению проброс из порта 9F
>>     2F переехавший реальный порт вгшки со все его логикой
>>     3F порт дорожки
>>     5F порт сектора
>>     7F порт данных
>>     9F по чтению что записано в 1F, по записи просрос в порт 1F (как вариант занять порт 4F)
>>     AF по чтению проброс записанного в порт FF, по записи проброс для чтения из порта FF (как вариант занять порт 6F)
>>     FF пишет напрямую как и было и проброс для чтения в порт 9F
>>      
 
Добавочка по порту AF при чтении биты 5-0 читать что проброшено при записи в порт FF, а биты 6-7 подменять статусными битами вгшки.


lvd:
1f<->9f
2f<->VG(1f)
3f<->VG(3f), writes to 4f
5f.. to 6f
7f.. to 8f
ff.wr ->vg(ff)[5..0], af[7..0]
ff.rd -<af[7..6]
af.rd -<vg(ff)[6..7], ff.wr[5..0]


Что сделано (точное описание):
запись:
1f -- пишется в ячейку 1f
2f -- пишется в ВГ93 рег. команд (то, что раньше было записью 1f)
3f -- пишется в ВГ93 как обычно, также сохраняется запись в ячейке 4f
4f -- пишется в ячейку 4f
5f -- пишется в ВГ93 как обычно, также сохраняется запись в ячейке 6f
6f -- пишется в ячейку 6f
7f,8f -- аналогично
9f -- пишется в ячейку 9f
af -- пишется в ячейку af
ff -- пишется в ячейку ff, выводится в контроллер ТРДОС как обычно (порт фф)

чтение:
1f -- читается ячейка 9f
2f -- читается статус ВГ93 (то, что раньше было чтением 1f)
3f,5f,7f -- читается ВГ93 как обычно
4f,6f,8f -- читаются ячейки 4f,6f,8f
9f -- читается ячейка 1f
af -- биты 5..0: ячейка ff, биты 7..6: intrq,drq (то же, что раньше читалось из порта FF ТРДОС)
ff -- читается ячейка af








20.10.2013: 

В общем нужен новый расклад по портам
 
1F - ячейка памяти - для отлова команд в сторону вгшки
2F переехавший реальный порт вгшки со все его логикой
порты 3F 5F 7F как уже переделаны щас
FF - читать в младших 5 битах то что туда было записано, все равно там проверяются только 2 старших бита. и проброс и лишний порт не нужен
 
И нужен 1 порт-ячейка для внутреннего использования. А то что читать кмос напрямую читать переменную в памяти получаются нехилые тормоза. Ибо переключение страниц с возвратом слишком много телодвижений надо. Пробросы по портам не нужны.

ффзапись = в вг и в теневой
ффчтение -- 6,7 из вг, остальное теневой

что сделано:

запись:
1f -- пишется в ячейку 1f
2f -- пишется в ВГ93 рег. команд (то, что раньше было записью 1f)
3f -- пишется в ВГ93 как обычно, также сохраняется запись в ячейке 4f
4f -- пишется в ячейку 4f
5f -- пишется в ВГ93 как обычно, также сохраняется запись в ячейке 6f
6f -- пишется в ячейку 6f
7f,8f -- аналогично
9f -- пишется в ячейку 9f
ff -- пишется в ячейку ff, выводится в контроллер ТРДОС как обычно (порт фф)

чтение:
1f -- читается ячейка 1f
2f -- читается статус ВГ93 (то, что раньше было чтением 1f)
3f,5f,7f -- читается ВГ93 как обычно
4f,6f,8f -- читаются ячейки 4f,6f,8f
9f -- читается ячейка 9f
ff -- биты 5..0: читается ячейка ff, биты 7..6: читается контроллер ТРДОС



================================================================================
2013.11.11:

что сделать: 1f вернуть как было (ВГшкино), запись 1f дублируется в 2f, 2f потом читает это. 9f оставить просто ячейкой.


что сделано:

запись:
1f -- пишется в ВГ93 рег. команд, пишется в ячейку 2f
2f -- пишется в ячейку 2f
3f -- пишется в ВГ93 как обычно, также сохраняется запись в ячейке 4f
4f -- пишется в ячейку 4f
5f -- пишется в ВГ93 как обычно, также сохраняется запись в ячейке 6f
6f -- пишется в ячейку 6f
7f,8f -- аналогично
9f -- пишется в ячейку 9f
ff -- пишется в ячейку ff, выводится в контроллер ТРДОС как обычно (порт фф)

чтение:
1f -- читается статус ВГ93
2f -- читается ячейка 2f
3f,5f,7f -- читается ВГ93 как обычно
4f,6f,8f -- читаются ячейки 4f,6f,8f
9f -- читается ячейка 9f
ff -- биты 5..0: читается ячейка ff, биты 7..6: читается контроллер ТРДОС



======================================================================================
2014.04.13

что сделать:

спрятать проброс из предыдущего пункта за бит БФ, если выключено, то как на железе
отдельно ячейки и порты ВГ

rst8: сделать после исполнения по адресу 8 включение паги ФФ и выключать потом как с нми (рубильник на бите БФ)
типа такого: m1 и address=8 и ПЗУ => включение фигни как при ловушке

делание трапа rst8: бит 6 порта BF


======================================================================================
2014.05.05

сделано:
трап по адресу 8: включается битом 6 порта BF, срабатывает при исполнении команды с адреса 8 из ПЗУ.
При срабатывании втыкает пагу ОЗУ ФФ и продолжает там исполнение. Выход -- так же, как из NMI: out(BE),a:nop:ret (или retn или reti)
ВНИМАНИЕ:
в эмуле команда по адресу 8 выполняется целиком из ПЗУ, после чего для следующей команды втыкается ОЗУ ФФ.
В железе только опкод (1ый байт) команды прочтётся из адреса 8, после чего воткнётся ОЗУ ФФ. Поэтому команда по адресу 8 должна
быть 1байтовая и не лезть в память (например nop).

(порты вг-невг требуют уточнения)

