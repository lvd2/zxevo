мысли про spi-обмен в penteve между авркой и фпгой.

1. когда /CS (spics_n) =1  - из аврки передаётся номер регистра (последние
переданные 8 бит), а в аврку - передаётся байт статуса (первые 8 бит после
перехода spics_n 0->1). 

в байте статуса нужна такая инфа, как наличие ваита на проце и его причина
(клава, часики, етц.). Какая ещё инфа - неясно/не помню.

2. Когда spics_n = 0 - идет обмен с регистром, номер которого установлен ранее.
Регистр на запись, как правило - сдвиговый неопределенной длины, который может
быть записан за несколько приёмов. Это нужно, например, чтобы прерывать запись в
клавиатурный регистр (5 байт) - по многочисленным просьбам фанатов тапок ;)

В записываемые регистры длиной 1 байт можно стробировать инфу при переходе
spics_n 0->1. В мультибайтовые (с возможностью приостанавливать их запись)
стробировать надо как-то по-другому. Пример - залили все 5 байт клавиатуры
(возможно, с перерывами), потом стробируем - эти 5 байт переписываются в рабочую
копию, которую читает з80.

Предлагаемый метод стробирования для мноргобайтовых регистров: другой номер
регистра, который надо установить (при spics_n=1) и передёрнуть spics_n через 0.

регистры, которые можно стробировать побайтно:

все 3 регистра мыши (понятно, что X-координата не зависит от кнопок и
Y-координаты).

регистр сброса (он один, и пока в нём достаточно места для указания
необходимости сброса и страницы ПЗУ, в которую сброситься).


Чтение регистров из fpga. Чтение статуса уже обговорено. Что ещё надо читать из
fpga?
 - Данные, записанные з80 для ваитовой периферии. 1 регистр.
 - что ещё?

Читать так же. Ставим номер регистра, опускаем spics_n, читаем данные. При этом
опускание spics_n (1->0) может служить стробом копирования данных в регистр
чтения, который выдвигается в avrку.


Проблема: что должно происходить с заданным номером регистра, когда передёрнули
spics_n? Если он не изменится, то, к примеру, возможны такие глюки:
1. послали 5 байт клавиатуры
2. послали строб копирования для клавиатуры (с передёргом spics_n в конце)
3. через время захотели прочитать статус: передёрнули spics_n и начали читать.
   В процессе передёрга, если остался установленным старый номер (регитср строба
   копирования для клавиаутры, см. выше), данные опять скопируются. Пока ничего
   плохого не произошло, но потенциальное зажопие налицо.

Потому предлагается:
1. по spics_n 0->1 обнулять номер регистра.
2. при нулевом номере регистра никакой реальный регист не должен быть выбран.
3. при необхоюдимости только прочитать статус без установки номера регистра,
   надо посылать 0.

Это приведет также к тому, что после каждого передерга spics_n надо заново
задавать номер регистра, даже если запись ведется в один и тот же многобайтовый.


...просьба также сообщить свои соображения.
