
;LAST UPDATE: 12.09.2019 savelij

;автоопределение кодировки работает неправильно

		RELAXED ON
		CPU Z80UNDOC

BUILD_DEBUG	EQU 0
REZIDENT	;включение резидента в сборку

DZ		MACRO DEFZ
		DB DEFZ,0
		ENDM 

DC		MACRO DEFC
		IF STRLEN(DEFC)>1
		DB SUBSTR(DEFC,0,STRLEN(DEFC)-1)
		ENDIF
		IF STRLEN(DEFC)>0
		DB CHARFROMSTR(DEFC,STRLEN(DEFC)-1)|80H
		ENDIF
		ENDM

SUM_HOB		MACRO STR,AA,BB,CC
		DB STR
		DW AA
		DW BB
		DB 0
		DB CC
$$I := 0
$$S := 0
		REPT 9
$$N := CHARFROMSTR (STR,STRLEN(STR)+$$S-9)
$$I := ($$I+$$S+$$N+($$N*256))&0XFFFF
$$S := $$S+1
		ENDM
$$I := ($$I+$$S+LOW (AA)+(LOW (AA)*0X100))&0XFFFF
$$S := $$S+1
$$I := ($$I+$$S+HIGH (AA)+(HIGH (AA)*0X100))&0XFFFF
$$S := $$S+1
$$I := ($$I+$$S+LOW (BB)+(LOW (BB)*0X100))&0XFFFF
$$S := $$S+1
$$I := ($$I+$$S+HIGH (BB)+(HIGH (BB)*0X100))&0XFFFF
$$S := $$S+1
$$I := ($$I+$$S+LOW (CC)+(LOW (CC)*0X100))&0XFFFF
$$S := $$S+1
$$I := ($$I+$$S+HIGH (CC)+(HIGH (CC)*0X100))&0XFFFF
$$S := $$S+1
		DW $$I
		ENDM

DUPL		MACRO LEN,FILL
DUPL:
$$N		EQU (LEN) / 1024
$$M		EQU (LEN) # 1024
		REPT $$N
		DB 1024 DUP(FILL)
		ENDM
		IF $$M <> 0
		IFB FILL
		DB $$M DUP(0)
		ELSE
		DB $$M DUP(FILL)
		ENDIF
		ENDIF
		ENDM

HIGH		FUNCTION X,((X >> 8) & 0XFF)
LOW		FUNCTION X,(X & 0XFF)

ROMCALL		MACRO ADR,PAGE
		RST 0X30
		DW ADR
		DB PAGE
		ENDM

RAMCALL		MACRO ADR,PAGE
		RST 0X20
		DW ADR
		DB PAGE
		ENDM

ATMPORT		MACRO PORT,BYTE
		LD BC,PORT
	IF BYTE = 0
		XOR A
	ELSE
		LD A,BYTE
	ENDIF
		OUT (C),A
		ENDM

EVOPORT		MACRO PORT,BYTE
		LD BC,PORT
	IF BYTE = 0
		XOR A
	ELSE
		LD A,BYTE
	ENDIF
		OUT (C),A
		ENDM

PEC_ON		MACRO BYTE
		IN A,(PEVO_CONF)
		OR BYTE
		OUT (PEVO_CONF),A
		ENDM

PEC_OFF		MACRO BYTE
		IN A,(PEVO_CONF)
		AND BYTE!0XFF
		OUT (PEVO_CONF),A
		ENDM

READ_7FFD	MACRO
		LD A,HIGH (RD_7FFD)
		IN A,(LOW (RD_7FFD))
		ENDM

SIZEDATE	EQU STRLEN (DATE)
SIZETIME	EQU STRLEN (TIME)

		IF SIZEDATE=10
MMOUNTH		EQU (CHARFROMSTR (DATE,0)-'0')*10+(CHARFROMSTR (DATE,1)-'0')
DDATE		EQU (CHARFROMSTR (DATE,3)-'0')*10+(CHARFROMSTR (DATE,4)-'0')
YYEAR		EQU (CHARFROMSTR (DATE,8)-'0')*10+(CHARFROMSTR (DATE,9)-'0')
		ELSEIF SIZEDATE=8
MMOUNTH		EQU (CHARFROMSTR (DATE,0)-'0')
DDATE		EQU (CHARFROMSTR (DATE,2)-'0')
YYEAR		EQU (CHARFROMSTR (DATE,6)-'0')*10+(CHARFROMSTR (DATE,7)-'0')
		ELSEIF (CHARFROMSTR (DATE,1))=0X2F
MMOUNTH		EQU (CHARFROMSTR (DATE,0)-'0')
DDATE		EQU (CHARFROMSTR (DATE,2)-'0')*10+(CHARFROMSTR (DATE,3)-'0')
YYEAR		EQU (CHARFROMSTR (DATE,7)-'0')*10+(CHARFROMSTR (DATE,8)-'0')
		ELSE
MMOUNTH		EQU (CHARFROMSTR (DATE,0)-'0')*10+(CHARFROMSTR (DATE,1)-'0')
DDATE		EQU (CHARFROMSTR (DATE,3)-'0')
YYEAR		EQU (CHARFROMSTR (DATE,7)-'0')*10+(CHARFROMSTR (DATE,8)-'0')
		ENDIF

		IF SIZETIME=7
HHOUR		EQU (CHARFROMSTR (TIME,0)-'0')
MMINUTE		EQU (CHARFROMSTR (TIME,2)-'0')*10+(CHARFROMSTR (TIME,3)-'0')
SSECUND		EQU (CHARFROMSTR (TIME,5)-'0')*10+(CHARFROMSTR (TIME,6)-'0')
		ELSE
HHOUR		EQU (CHARFROMSTR (TIME,0)-'0')*10+(CHARFROMSTR (TIME,1)-'0')
MMINUTE		EQU (CHARFROMSTR (TIME,3)-'0')*10+(CHARFROMSTR (TIME,4)-'0')
SSECUND		EQU (CHARFROMSTR (TIME,6)-'0')*10+(CHARFROMSTR (TIME,7)-'0')
		ENDIF

DATA_VERS	EQU DDATE+(MMOUNTH<<5)+(YYEAR<<9)+0X8000			;уже упаковано

FAT_DATE	EQU DDATE+(MMOUNTH<<5)+((2000+YYEAR-1980)&0x7F)<<9
FAT_TIME	EQU SSECUND/2+(MMINUTE<<5)+(HHOUR<<11)

TEXTDATE	MACRO
TDATE		DB ((DDATE/10)+'0'),(DDATE#10)+'0'
		DB "."
TMOUNTH		DB MMOUNTH/10+'0',MMOUNTH#10+'0'
		DB ".",CHARFROMSTR (DATE,SIZEDATE-4),CHARFROMSTR (DATE,SIZEDATE-3)
		DB CHARFROMSTR (DATE,SIZEDATE-2),CHARFROMSTR (DATE,SIZEDATE-1)
		ENDM

RST8		MACRO N1,N2,N3
		RST 8
		DB N1
		IFNB N2
		DB N2
		ENDIF
		IFNB N3
		DB N3
		ENDIF
		ENDM

BYTE		EQU 1
WORD		EQU 2
JUMP		EQU 3
DWORD		EQU 4
QWORD		EQU 8

BITMASK		MACRO NAME,NUM
B_NAME		EQU NUM
M_NAME		EQU 1<<NUM
		ENDM

SETVAR		MACRO NAME,SIZE
NAME		EQU INITVAR
		IFNB SIZE
INITVAR := INITVAR+SIZE
NAME_Size	EQU SIZE
		ELSE
INITVAR := INITVAR+BYTE
NAME_Size	EQU BYTE
		ENDIF
		ENDM

SUBVAR		MACRO SIZE
INITVAR := INITVAR-SIZE
		ENDM

ADDVAR		MACRO SIZE
INITVAR := INITVAR+SIZE
		ENDM

INIT_VAR	MACRO START
		IFNB START
INITVAR := START
		ELSE
INITVAR := 0
		ENDIF
		ENDM


MALIGN		MACRO
	IF LOW($) = 0
		DUPL (HIGH($) << 8) - $,0
	ELSE
		DUPL ((HIGH($) + 1) << 8) - $,0
	ENDIF
		ENDM

; выравнивание до сектора с учетом адреса компиляции
DALIGN		MACRO ADDRESS
	IF LOW(ADDRESS)
		DB LOW (-$)+LOW(ADDRESS) DUP(0)
	ELSE
		DB LOW (-$) DUP (0)
	ENDIF
		ENDM

; преобразование 16 битного числа в текст
WORD2TXT	MACRO WORD
$$DEC1 := (WORD)/10000
$$TMP := WORD-$$DEC1*10000
$$DEC2 := $$TMP/1000
$$TMP := $$TMP-$$DEC2*1000
$$DEC3 := $$TMP/100
$$TMP := $$TMP-$$DEC3*100
$$DEC4 := $$TMP/10
$$TMP := $$TMP-$$DEC4*10
$$DEC5 := $$TMP
	DB $$DEC1+'0',$$DEC2+'0',$$DEC3+'0',$$DEC4+'0',$$DEC5+'0'
		ENDM
